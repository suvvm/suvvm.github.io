<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/ortrait.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.suvvm.work","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:type" content="website">
<meta property="og:title" content="SUVVM">
<meta property="og:url" content="https://www.suvvm.work/page/10/index.html">
<meta property="og:site_name" content="SUVVM">
<meta property="og:description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SUVVM">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.suvvm.work/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SUVVM</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e5190116d64be66cac29daef18c94ac0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SUVVM</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">呜嗷SUVVM</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/01/22/PTA-Advanced-Level-1022-Digital-Library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/22/PTA-Advanced-Level-1022-Digital-Library/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1022 Digital Library</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-22 21:43:53" itemprop="dateCreated datePublished" datetime="2019-01-22T21:43:53+08:00">2019-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case. For each case, the first line contains a positive integer N (≤) which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines:</p>
<ul>
<li>Line #1: the 7-digit ID number;</li>
<li>Line #2: the book title — a string of no more than 80 characters;</li>
<li>Line #3: the author — a string of no more than 80 characters;</li>
<li>Line #4: the key words — each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;</li>
<li>Line #5: the publisher — a string of no more than 80 characters;</li>
<li>Line #6: the published year — a 4-digit number which is in the range [1000, 3000].</li>
</ul>
<p>　　It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.</p>
<p>　　After the book information, there is a line containing a positive integer M (≤) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below:</p>
<ul>
<li>1: a book title</li>
<li>2: name of an author</li>
<li>3: a key word</li>
<li>4: name of a publisher</li>
<li>5: a 4-digit number representing the year</li>
</ul>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print <code>Not Found</code> instead.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1111111</span><br><span class="line">The Testing Book</span><br><span class="line">Yue Chen</span><br><span class="line">test code debug sort keywords</span><br><span class="line">ZUCS Print</span><br><span class="line">2011</span><br><span class="line">3333333</span><br><span class="line">Another Testing Book</span><br><span class="line">Yue Chen</span><br><span class="line">test code sort keywords</span><br><span class="line">ZUCS Print2</span><br><span class="line">2012</span><br><span class="line">2222222</span><br><span class="line">The Testing Book</span><br><span class="line">CYLL</span><br><span class="line">keywords debug book</span><br><span class="line">ZUCS Print2</span><br><span class="line">2011</span><br><span class="line">6</span><br><span class="line">1: The Testing Book</span><br><span class="line">2: Yue Chen</span><br><span class="line">3: keywords</span><br><span class="line">4: ZUCS Print</span><br><span class="line">5: 2011</span><br><span class="line">3: blablabla</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1: The Testing Book</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">2: Yue Chen</span><br><span class="line">1111111</span><br><span class="line">3333333</span><br><span class="line">3: keywords</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">3333333</span><br><span class="line">4: ZUCS Print</span><br><span class="line">1111111</span><br><span class="line">5: 2011</span><br><span class="line">1111111</span><br><span class="line">2222222</span><br><span class="line">3: blablabla</span><br><span class="line">Not Found</span><br></pre></td></tr></table></figure>
<p>题目解析<br>　　本题给出n个书本信息，每个书本给出id，书名，作者，关键词，出版社，发行年份，这五个信息，要求分别按照五个信息建立索引，之后给出m行查询，查询格式如下：</p>
<p>1：书名</p>
<p>2：作者</p>
<p>3：<strong><em>一个\</em></strong>关键词</p>
<p>4：出版商</p>
<p>5：年份</p>
<p>　　要求输出查询信息所包含的所有书的id。</p>
<p>　　虽然这是一个30分的题目但是它并不是膨胀困难，书名，作者，关键词，出版社，发行年份我们都可以用string类型保存，对于书籍id我们则用int进行存储，这里可以用map建立string与set<int>的对应关系，set<int>里储存的便是对应string所包含所有书的id（由于书的id一定不重复，且最后要求由小到大输出id，用set会方便很多）。注意关键词有很多个，每个都需要建立对应关系。</int></int></p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; title, author, keyWord, publisher, year;</span><br><span class="line"><span class="comment">//分别对应 同名的书 同作者的书 同关键词的书 同出版社的书 同年的书</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);    <span class="comment">//输入书的个数；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">string</span>  tTitle, tAuthor, tKeyWord, tPublisher, tYear;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id;  <span class="comment">//输入id</span></span><br><span class="line">        getchar();  <span class="comment">//吸收换行符</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, tTitle);   <span class="comment">//输入书名</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, tAuthor);  <span class="comment">//输入作者</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, tKeyWord); <span class="comment">//输入该书所有关键词</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, tPublisher); <span class="comment">//输入出版社</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, tYear);    <span class="comment">//输入年份</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        title[tTitle].insert(id);   <span class="comment">//对应书名的集合中加入id</span></span><br><span class="line">        author[tAuthor].insert(id); <span class="comment">//对应作者的集合中加入id</span></span><br><span class="line">        <span class="built_in">string</span> temp;    <span class="comment">//temp用来获取每一个关键词</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">cinKeyWord</span><span class="params">(tKeyWord)</span></span>; <span class="comment">//用tKeyWord作为输入流输入每一个关键词</span></span><br><span class="line">        <span class="keyword">while</span>(cinKeyWord &gt;&gt; temp)&#123;</span><br><span class="line">            keyWord[temp].insert(id);   <span class="comment">//每一个关键词对应的集合中都加入id</span></span><br><span class="line">        &#125;</span><br><span class="line">        publisher[tPublisher].insert(id);   <span class="comment">//对应出版社的集合加入id</span></span><br><span class="line">        year[tYear].insert(id); <span class="comment">//对应年份的集合加入id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);    <span class="comment">//输入查询个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> query;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d: "</span>, &amp;query);  <span class="comment">//输入查询控制符</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, temp); <span class="comment">//输入查询内容</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; query &lt;&lt; <span class="string">": "</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//由于string传送速度较慢，若将查询过程包装为一个函数，最后一个结点会超时</span></span><br><span class="line">        <span class="comment">//不过传引用仿佛可以解决这个问题</span></span><br><span class="line">        <span class="keyword">if</span>(query == <span class="number">1</span>)&#123; <span class="comment">//控制符为1 输出 对应书名集合中包含的书</span></span><br><span class="line">            <span class="keyword">if</span>(title.find(temp) == title.end())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not Found\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i : title[temp])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%07d\n"</span>, i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query == <span class="number">2</span>)&#123;   <span class="comment">//控制符为2 输出 对应作者集合中包含的书</span></span><br><span class="line">            <span class="keyword">if</span>(author.find(temp) == author.end())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not Found\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i : author[temp])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%07d\n"</span>, i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query == <span class="number">3</span>)&#123;   <span class="comment">//控制符为3 输出 对应关键词集合中包含的书</span></span><br><span class="line">            <span class="keyword">if</span>(keyWord.find(temp) == keyWord.end())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not Found\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i : keyWord[temp])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%07d\n"</span>, i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query == <span class="number">4</span>)&#123;   <span class="comment">//控制符为4 输出 对应出版社集合中包含的书</span></span><br><span class="line">            <span class="keyword">if</span>(publisher.find(temp) == publisher.end())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not Found\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i : publisher[temp])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%07d\n"</span>, i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(query == <span class="number">5</span>)&#123;   <span class="comment">//控制符为5 输出 对应年份集合中包含的书</span></span><br><span class="line">            <span class="keyword">if</span>(year.find(temp) == year.end())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Not Found\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i : year[temp])</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%07d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/01/08/PTA-Advanced-Level-1020-Tree-Traversals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/08/PTA-Advanced-Level-1020-Tree-Traversals/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1020 Tree Traversals</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-08 21:01:30" itemprop="dateCreated datePublished" datetime="2019-01-08T21:01:30+08:00">2019-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case. For each case, the first line gives a positive integer N (≤), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 6 3 5 7 2</span><br></pre></td></tr></table></figure>
<p>题目解析<br>　　本题第一行给出二叉树的结点数量n，之后第二行给出二叉树的后序遍历，第三行给出二叉树的中序遍历，要求输出二叉树的层序遍历。（保证树中的每个结点数据都不同）</p>
<p>　　后序遍历中最后一个元素便是当前树的根结点，在中序遍历中找到根结点对应的值，其左侧便是左子树的中序遍历，在知道左子树中序遍历后可以根据结点数量在后续遍历中找到左子树的后续遍历，确定了左子树与根结点后剩下的便是右子树信息了，以此类推可以得到整棵二叉树。</p>
<p>　　建立二叉树后使用广搜，由于广搜二叉树维护队列时，每次出队一个结点并将其对应的左孩子与右孩子入队，这就是层序遍历。</p>
<p>　　AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> postorder[maxn];    <span class="comment">//储存后续遍历</span></span><br><span class="line"><span class="keyword">int</span> inorder[maxn];      <span class="comment">//储存中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>    <span class="comment">//二叉树结点信息</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node *lchild;</span><br><span class="line">    node *rchild;</span><br><span class="line">    node(<span class="keyword">int</span> tdata)&#123;    <span class="comment">//构造函数</span></span><br><span class="line">        data = tdata;</span><br><span class="line">        lchild = <span class="literal">NULL</span>;</span><br><span class="line">        rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node *<span class="title">create</span><span class="params">(<span class="keyword">int</span> postL, <span class="keyword">int</span> postR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;   </span><br><span class="line">    <span class="comment">//由于要递归建树我们并不需要将每个树的左子树右子树的后序遍历与中序遍历储存下来</span></span><br><span class="line">    <span class="comment">//只需要在原始postorder与inorder数组中标记出其位置即可</span></span><br><span class="line">    <span class="comment">//postL与postR表示当前后续遍历的左右两端，inL与inR表示当前中序遍历的左右两端</span></span><br><span class="line">    <span class="keyword">if</span>(postL &gt; postR)   <span class="comment">//如果后续遍历左端位置大于右端位置，证明当前正在建立的树为空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node *root = <span class="keyword">new</span> node(postorder[postR]);    <span class="comment">//建立根结点，权值为postorder[postR]左右子树都为空</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = inL; inorder[i] != postorder[postR]; i++);  <span class="comment">//在中序遍历中找到根结点</span></span><br><span class="line">    <span class="keyword">int</span> lenl = i - inL; <span class="comment">//记录左子树长度</span></span><br><span class="line">    root-&gt;lchild = create(postL, postL + lenl - <span class="number">1</span>, inL, inL + lenl - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//建立左子树</span></span><br><span class="line">    root-&gt;rchild = create(postL + lenl, postR - <span class="number">1</span>, inL + lenl + <span class="number">1</span>, inR);</span><br><span class="line">    <span class="comment">//建立右子树</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//n记录结点数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelorder</span><span class="params">(node *root)</span></span>&#123;    <span class="comment">//层序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; Q;</span><br><span class="line">    Q.push(root);   <span class="comment">//根结点入队</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;    <span class="comment">//记录当前已经输出了几个数，用于之后判断是否输出空格</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        node *top = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, top-&gt;data);<span class="comment">//输出结点权值</span></span><br><span class="line">        <span class="keyword">if</span>(cnt != n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(top-&gt;lchild != <span class="literal">NULL</span>) <span class="comment">//左儿子入队</span></span><br><span class="line">            Q.push(top-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(top-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">//右儿子入队</span></span><br><span class="line">            Q.push(top-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);    <span class="comment">//输入结点数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;postorder[i]); <span class="comment">//输入后序遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inorder[i]);   <span class="comment">//输入中序遍历</span></span><br><span class="line">    node *root = create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);    <span class="comment">//建树</span></span><br><span class="line">    levelorder(root);   <span class="comment">//输出层序遍历</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/01/01/PTA-Advanced-Level-1019-General-Palindromic-Number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/01/PTA-Advanced-Level-1019-General-Palindromic-Number/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1019 General Palindromic Number</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-01 20:05:20" itemprop="dateCreated datePublished" datetime="2019-01-01T20:05:20+08:00">2019-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p>
<p>Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N&gt;0 in base b≥2, where it is written in standard notation with k+1 digits ai as (. Here, as usual, 0for all i and ak is non-zero. Then N is palindromic if and only if ai=ak−i for all i. Zero is written 0 in any base and is also palindromic by definition.</p>
<p>Given any positive decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case consists of two positive numbers N and b, where 0 is the decimal number and 2 is the base. The numbers are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in one line <code>Yes</code> if N is a palindromic number in base b, or <code>No</code> if not. Then in the next line, print N as the number in base b in the form “ak ak−1 … a0”. Notice that there must be no extra space at the end of output.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">1 1 0 1 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121 5</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No</span><br><span class="line">4 4 1</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题有多组测试数据，每组数据给出一个十进制数字n，与目标进制b，要求将b转化为b进制后，判断转化完成的数字是否为回文数字。</p>
<p>　　我们可以写一个函数，将十进制数字n转化为b进制并将其每一位都记录在一个容器num中，之后从num第一位开始到中心为止，判断该位与其对称位置是否全相等即可。若全相等，则目标数字是回文数字，否则不是回文数字。</p>
<p>　　AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;    <span class="comment">//用来储存进制转换后数字的容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeRadix</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> radix)</span></span>&#123; <span class="comment">//进制转换函数</span></span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = (n % radix);</span><br><span class="line">        num.push_back(temp);</span><br><span class="line">        n /= radix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;   <span class="comment">//回文判断函数</span></span><br><span class="line">    <span class="keyword">int</span> len = num.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] != num[len - i - <span class="number">1</span>])  <span class="comment">//判断该位置与其对称位置是否相等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;b) != EOF)&#123;    <span class="comment">//输入数字n与目标进制b</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123; <span class="comment">//0的所有进制都是回文数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num.clear();    <span class="comment">//清空容器num</span></span><br><span class="line">        changeRadix(n, b);  <span class="comment">//将n转化为b进制</span></span><br><span class="line">        <span class="keyword">if</span>(judge())&#123;    <span class="comment">//判断转换进制后是否为回文数字</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);    <span class="comment">//是则输出Yes</span></span><br><span class="line">            <span class="comment">//由于我们是逆序储存转换后的数字的，所以在输出前要将其反转</span></span><br><span class="line">            reverse(num.begin(), num.end());</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : num)&#123;  <span class="comment">//输出转换后数字</span></span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//不是回文数字输出No，其余操作同上</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            reverse(num.begin(), num.end());</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : num)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/01/01/PTA-Advanced-Level-1018-Public-Bike-Management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/01/PTA-Advanced-Level-1018-Public-Bike-Management/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1018 Public Bike Management</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-01 19:42:15" itemprop="dateCreated datePublished" datetime="2019-01-01T19:42:15+08:00">2019-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>　　There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.</p>
<p>　　The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfectcondition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.</p>
<p>　　When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.</p>
<p><img src="https://images.ptausercontent.com/213" alt="img"></p>
<p>　　The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10. To solve the problem at S3, we have 2 different shortest paths:</p>
<ol>
<li>PBMC -&gt; S1 -&gt; S3. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S1 and then take 5 bikes to S3, so that both stations will be in perfect conditions.</li>
<li>PBMC -&gt; S2 -&gt; S3. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.</li>
</ol>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case. For each case, the first line contains 4 numbers: Cmax (≤), always an even number, is the maximum capacity of each station; N (≤), the total number of stations; Sp, the index of the problem station (the stations are numbered from 1 to N, and PBMC is represented by the vertex 0); and M, the number of roads. The second line contains N non-negative numbers Ci (,) where each Ci is the current number of bikes at Si respectively. Then Mlines follow, each contains 3 numbers: Si, Sj, and Tij which describe the time Tij taken to move betwen stations Si and Sj. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of Sp is adjusted to perfect.</p>
<p>　　Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 3 3 5</span><br><span class="line">6 7 0</span><br><span class="line">0 1 1</span><br><span class="line">0 2 1</span><br><span class="line">0 3 3</span><br><span class="line">1 3 1</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 0-&gt;2-&gt;3 0</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题题意是，杭州市有一些共享单车站，给出车站的最大容量（一定是偶数），给出车站数量与车站之间道路的信息，车站的最优状态为最大容量的一半。给定目标车站，控制中心现在要携带或从路过的其他车站取出一些自行车，使路程中路过的所有车站和目标车站都变为最优状态，多的自行车将被带回控制中心。要求计算并输出最短路径和最短路径情况下的携带数与带回数，如果有多条最短路径那么选择携带数最少的一条，如果还有是多条路径，那么选择带回数最少的一条。（到达目标车站后之间带着多余的自行车之间传送回控制中心，不在经过任何车站）。</p>
<p>　　输入信息：第一行给出4个整数，分别为 最大容量Cmax ，车站数量n， 目标车站sp，道路数量m，下一行给出n个整数代表每个车站当前自行车数量，之后跟随m行，每行3个整数，分别为，道路连接的两个车站和道路长度。</p>
<p>　　车站的范围为1 ~ n，0为控制中心。</p>
<p>　　可以先用迪杰斯特拉获得所有最短路径。之后搜索所有最短路径获得携带数（携带数相同获得最小的带回数）最小的路径，按要求输出。</p>
<p>　　利用Dijkstra建立一颗最短路径树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> st)</span></span>&#123;  <span class="comment">//传入起点，这里之间传入0控制中心即可</span></span><br><span class="line">    dis[st] = <span class="number">0</span>;    <span class="comment">//dis储存控制中心到所有车站的最短距离</span></span><br><span class="line">    <span class="comment">//控制中心到自己的最短距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;    <span class="comment">//获取没有访问过的车站中距离控制中心最近的车站</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minLength = INT_MAX;</span><br><span class="line">        <span class="comment">//u记录最近的车站， minLength记录最短距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="comment">//vis记录车站是否已经访问</span></span><br><span class="line">            <span class="keyword">if</span>(dis[j] &lt; minLength &amp;&amp; !vis[j])&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minLength = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="comment">//如果u还是-1表示其他车站和控制中心不连通</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;  <span class="comment">//将最近的车站标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;    <span class="comment">//遍历所有结点用u车站优化控制中心与其他未访问车站的距离</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; G[u][j] != INT_MAX)&#123;  <span class="comment">//j车站未访问且与u车站之间有道路</span></span><br><span class="line">                <span class="keyword">if</span>(dis[j] &gt; dis[u] + G[u][j])&#123;  <span class="comment">//判断是否能优化</span></span><br><span class="line">                    dis[j] = dis[u] + G[u][j];  <span class="comment">//如果能优化</span></span><br><span class="line">                    pre[j].clear(); <span class="comment">//j车站的前驱车站清空并重新记录为u</span></span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[j] == dis[u] + G[u][j])&#123;</span><br><span class="line">                    <span class="comment">//若不能优化但是以u为中转是j车站到控制中心的距离和dis数组中记录的 j车站到控制中心的距离相等</span></span><br><span class="line">                    <span class="comment">//j车站的前驱增加u</span></span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 之后深搜遍历最短路径树获得携带数最少（如果仍有多条道路则获得带回数最少）的路线。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">0</span>)&#123; <span class="comment">//这里我们逆序遍历路径，从终点车站开始到控制中心0为止</span></span><br><span class="line">        <span class="comment">//应为最短路径树中记录控制0为叶子结点，目标车站sp为根结点</span></span><br><span class="line">        path.push_back(<span class="number">0</span>);</span><br><span class="line">        judge();    <span class="comment">//判断当前路径的携带数与带回树是否可以优化答案</span></span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : pre[v])&#123;</span><br><span class="line">        DFS(i);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　　由于DFS中我们时倒序遍历的最短路径，所以在判断每条路径是否可以优化答案时，要先将DFS中获取的路径反转，之后遍历这条路径获得其携带数与带回数即可。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>, backn = <span class="number">0</span>;    <span class="comment">//need记录携带数 backn记录带回数</span></span><br><span class="line">    <span class="keyword">int</span> half = Cmax / <span class="number">2</span>;    <span class="comment">//half记录最优状态车站中车辆数</span></span><br><span class="line">    reverse(path.begin(), path.end());</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//道路开始位置为控制中心0，我们不需要将控制中心的车辆数调整为最优状态</span></span><br><span class="line">    <span class="comment">//所以我们用flag = false表示正在访问控制中心</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : path)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;  <span class="comment">//跳过控制中心</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(spValue[i] &gt; half)&#123;  <span class="comment">//当前车站中的共享单车数量大于最优状态数量</span></span><br><span class="line">            backn += spValue[i] - half; <span class="comment">//将多出的车辆带走</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(backn &gt; half - spValue[i])   <span class="comment">//如果当前携带的车辆足以将该车站补充为最优状态</span></span><br><span class="line">                backn -= half - spValue[i]; <span class="comment">//当前携带数减去缺少车辆数</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                need += (half - spValue[i]) - backn;    </span><br><span class="line">                <span class="comment">//如果不足以补足当前车站就将所有携带车辆放入该车站，之后还是不足的车辆从控制中心携带</span></span><br><span class="line">                backn = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(need &lt; minNeed)&#123; <span class="comment">//比较答案与当前路径的携带数</span></span><br><span class="line">        minNeed = need;</span><br><span class="line">        minBack = backn;</span><br><span class="line">        ansPath = path;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(need == minNeed &amp;&amp; backn &lt; minBack)&#123;   <span class="comment">//携带数一致比较带回数</span></span><br><span class="line">        minBack = backn;</span><br><span class="line">        ansPath = path;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(path.begin(), path.end());  <span class="comment">//为了继续DFS重新将路径反转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> AC代码 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Cmax, sp; <span class="comment">//n记录车站数量， m记录道路数量， Cmax记录车站最大容量（Cmax/2就是车站最优数量）</span></span><br><span class="line"><span class="keyword">int</span> G[maxn][maxn];  <span class="comment">//G储存车站之间的邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> spValue[maxn], dis[maxn];   <span class="comment">//spValue记录每个车站当前的车辆数， dis记录每个车站到控制中心的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;   <span class="comment">//vis用于在寻找最短路径时判断车站是否已经访问</span></span><br><span class="line"><span class="keyword">int</span> minNeed, minBack;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, ansPath, pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> st)</span></span>&#123;  <span class="comment">//传入起点，这里之间传入0控制中心即可</span></span><br><span class="line">    dis[st] = <span class="number">0</span>;    <span class="comment">//dis储存控制中心到所有车站的最短距离</span></span><br><span class="line">    <span class="comment">//控制中心到自己的最短距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;    <span class="comment">//获取没有访问过的车站中距离控制中心最近的车站</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minLength = INT_MAX;</span><br><span class="line">        <span class="comment">//u记录最近的车站， minLength记录最短距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="comment">//vis记录车站是否已经访问</span></span><br><span class="line">            <span class="keyword">if</span>(dis[j] &lt; minLength &amp;&amp; !vis[j])&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minLength = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="comment">//如果u还是-1表示其他车站和控制中心不连通</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;  <span class="comment">//将最近的车站标记为已访问</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;    <span class="comment">//遍历所有结点用u车站优化控制中心与其他未访问车站的距离</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; G[u][j] != INT_MAX)&#123;  <span class="comment">//j车站未访问且与u车站之间有道路</span></span><br><span class="line">                <span class="keyword">if</span>(dis[j] &gt; dis[u] + G[u][j])&#123;  <span class="comment">//判断是否能优化</span></span><br><span class="line">                    dis[j] = dis[u] + G[u][j];  <span class="comment">//如果能优化</span></span><br><span class="line">                    pre[j].clear(); <span class="comment">//j车站的前驱车站清空并重新记录为u</span></span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[j] == dis[u] + G[u][j])&#123;</span><br><span class="line">                    <span class="comment">//若不能优化但是以u为中转是j车站到控制中心的距离和dis数组中记录的 j车站到控制中心的距离相等</span></span><br><span class="line">                    <span class="comment">//j车站的前驱增加u</span></span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>, backn = <span class="number">0</span>;    <span class="comment">//need记录携带数 backn记录带回数</span></span><br><span class="line">    <span class="keyword">int</span> half = Cmax / <span class="number">2</span>;    <span class="comment">//half记录最优状态车站中车辆数</span></span><br><span class="line">    reverse(path.begin(), path.end());</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//道路开始位置为控制中心0，我们不需要将控制中心的车辆数调整为最优状态</span></span><br><span class="line">    <span class="comment">//所以我们用flag = false表示正在访问控制中心</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : path)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;  <span class="comment">//跳过控制中心</span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(spValue[i] &gt; half)&#123;  <span class="comment">//当前车站中的共享单车数量大于最优状态数量</span></span><br><span class="line">            backn += spValue[i] - half; <span class="comment">//将多出的车辆带走</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(backn &gt; half - spValue[i])   <span class="comment">//如果当前携带的车辆足以将该车站补充为最优状态</span></span><br><span class="line">                backn -= half - spValue[i]; <span class="comment">//当前携带数减去缺少车辆数</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                need += (half - spValue[i]) - backn;</span><br><span class="line">                <span class="comment">//如果不足以补足当前车站就将所有携带车辆放入该车站，之后还是不足的车辆从控制中心携带</span></span><br><span class="line">                backn = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(need &lt; minNeed)&#123; <span class="comment">//比较答案与当前路径的携带数</span></span><br><span class="line">        minNeed = need;</span><br><span class="line">        minBack = backn;</span><br><span class="line">        ansPath = path;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(need == minNeed &amp;&amp; backn &lt; minBack)&#123;   <span class="comment">//携带数一致比较带回数</span></span><br><span class="line">        minBack = backn;</span><br><span class="line">        ansPath = path;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(path.begin(), path.end());  <span class="comment">//为了继续DFS重新将路径反转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">0</span>)&#123; <span class="comment">//这里我们逆序遍历路径，从终点车站开始到控制中心0为止</span></span><br><span class="line">        <span class="comment">//应为最短路径树中记录控制0为叶子结点，目标车站sp为根结点</span></span><br><span class="line">        path.push_back(<span class="number">0</span>);</span><br><span class="line">        judge();    <span class="comment">//判断当前路径的携带数与带回树是否可以优化答案</span></span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : pre[v])&#123;</span><br><span class="line">        DFS(i);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;Cmax, &amp;n, &amp;sp, &amp;m) != EOF)&#123;    <span class="comment">//输入最大容量 车站数量 目标车站 道路数量</span></span><br><span class="line">        fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxn * maxn, INT_MAX);    <span class="comment">//将所有车站之间设为不可达</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">            pre[i].clear(); <span class="comment">//清空最短路径树</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.clear();   <span class="comment">//清空用来记录每个路径的容器</span></span><br><span class="line">        ansPath.clear();    <span class="comment">//清空用来记录答案路径的容器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;spValue[i]);   <span class="comment">//输入每个车站当前的车辆数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//输入路径</span></span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[u][v]);</span><br><span class="line">            G[v][u] = G[u][v];  <span class="comment">//双向路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));    <span class="comment">//将所有车站设为未访问</span></span><br><span class="line">        fill(dis, dis + maxn, INT_MAX); <span class="comment">//所有车站到控制中心的距离为无穷大</span></span><br><span class="line">        Dijkstra(<span class="number">0</span>);    <span class="comment">//迪杰斯特拉获取最短路径树</span></span><br><span class="line">        minNeed = INT_MAX, minBack = INT_MAX;   <span class="comment">//记录答案携带数与带回数为无穷多</span></span><br><span class="line">        DFS(sp);    <span class="comment">//深搜最短路径树获取答案</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, minNeed); <span class="comment">//输出携带数</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ansPath)&#123;  <span class="comment">//输出路径</span></span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d\n"</span>, minBack);   <span class="comment">//输出带回数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/20/PTA-Advanced-Level-1016-Phone-Bills/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/20/PTA-Advanced-Level-1016-Phone-Bills/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1016 Phone Bills</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-20 19:33:16" itemprop="dateCreated datePublished" datetime="2018-12-20T19:33:16+08:00">2018-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　A long-distance telephone company charges its customers by the following rules:</p>
<p>　　Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.</p>
<p>　　The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day.</p>
<p>　　The next line contains a positive number N (≤), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (<code>mm:dd:hh:mm</code>), and the word <code>on-line</code>or <code>off-line</code>.</p>
<p>　　For each test case, all dates will be within a single month. Each <code>on-line</code> record is paired with the chronologically next record for the same customer provided it is an <code>off-line</code> record. Any <code>on-line</code> records that are not paired with an <code>off-line</code> record are ignored, as are <code>off-line</code> records not paired with an <code>on-line</code> record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each test case, you must print a phone bill for each customer.</p>
<p>　　Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (<code>dd:hh:mm</code>), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10</span><br><span class="line">10</span><br><span class="line">CYLL 01:01:06:01 on-line</span><br><span class="line">CYLL 01:28:16:05 off-line</span><br><span class="line">CYJJ 01:01:07:00 off-line</span><br><span class="line">CYLL 01:01:08:03 off-line</span><br><span class="line">CYJJ 01:01:05:59 on-line</span><br><span class="line">aaa 01:01:01:03 on-line</span><br><span class="line">aaa 01:02:00:01 on-line</span><br><span class="line">CYLL 01:28:15:41 on-line</span><br><span class="line">aaa 01:05:02:24 on-line</span><br><span class="line">aaa 01:04:23:59 off-line</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CYJJ 01</span><br><span class="line">01:05:59 01:07:00 61 $12.10</span><br><span class="line">Total amount: $12.10</span><br><span class="line">CYLL 01</span><br><span class="line">01:06:01 01:08:03 122 $24.40</span><br><span class="line">28:15:41 28:16:05 24 $3.85</span><br><span class="line">Total amount: $28.25</span><br><span class="line">aaa 01</span><br><span class="line">02:00:01 04:23:59 4318 $638.80</span><br><span class="line">Total amount: $638.80</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题是一个计算电话费用的题目，每组测试首先给出24个整数，代表一天中00：00 ~ 24：00每个小时每分钟通话的收费（单位是美分），下一行给出一个整数n表示通话记录的数量，之后n行跟随表示每条通话记录的信息，包括用户名 时间（月:日:时:分） 开始通话或结束通话标识（on-line / off-line）。要求按时间输出所有用户的通话信息，格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户名  通话月份</span><br><span class="line">开始通话时间  结束通话时间  本次通话金额（单位为美元）</span><br><span class="line">……</span><br><span class="line">……</span><br><span class="line">Total amount: 全部通话金额总和单位为美元）</span><br></pre></td></tr></table></figure>
<p>　　这里首先用一个数组toll[25]记录24小时通话各自的收费，用一个结构体node记录每条通话记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int toll[25];   &#x2F;&#x2F;记录每个小时每分钟通话的收费</span><br><span class="line">struct node&#123;    </span><br><span class="line">    string name;    &#x2F;&#x2F;客户名</span><br><span class="line">    int month, dd, hh,mm;   &#x2F;&#x2F;时间</span><br><span class="line">    bool line;  &#x2F;&#x2F;结束通话标识 true表示on-line false表示off—line</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　我们想要在输入是将每个客户的通话记录都分开记录，这里可以利用map将每个客户名映射到一个vector容器，容器中装载通话记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, vector&lt;node&gt; &gt; customer;    </span><br><span class="line">&#x2F;&#x2F;customer[&quot;张三&quot;]现在就代表着姓名为张三的用户的所有通话记录</span><br></pre></td></tr></table></figure>
<p>　　这样我们就可以开始录入通话记录了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        node temp;  <span class="comment">//temp记录当前输入的通话记录信息</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name;   <span class="comment">//输入姓名</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d:%d"</span>, &amp;temp.month, &amp;temp.dd, &amp;temp.hh, &amp;temp.mm);</span><br><span class="line">        <span class="comment">//输入时</span></span><br><span class="line">        <span class="built_in">string</span> tline;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tline;   <span class="comment">//输入通话标识</span></span><br><span class="line">        temp.line = mp[tline];  <span class="comment">//这里的mp将"on-line"映射为true将"off-line"映射为false</span></span><br><span class="line">        customer[temp.name].push_back(temp);</span><br><span class="line">        <span class="comment">//将当前信息记录入其客户所对应的容器中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 之后我们就需要遍历所有客户与其通话记录，将客户的通话记录按时间升序排序，根据排序后的通话记录，我们就可以获得该客户的所有完整通话（时间相邻最近的on_line与off-line，中间不能夹着其他on_line与off-line）。我们需要获得每一个完整通话并将其记录在对应用户名下，我们用结构体call记录每一个完整通话的信息，包括客户名，开始通话时间，结束通话时间，通话时长，通话消费。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">call</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">//客户名</span></span><br><span class="line">    <span class="keyword">int</span> onMonth, onDd, onHh, onMm;  <span class="comment">//开始通话时间</span></span><br><span class="line">    <span class="keyword">int</span> offMonth, offDd, offHh, offMm;  <span class="comment">//结束通话时间</span></span><br><span class="line">    <span class="keyword">int</span> sumTime;    <span class="comment">//通话时长</span></span><br><span class="line">    <span class="keyword">int</span> cost;   <span class="comment">//通话消耗</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　为了记录每个客户的完整通话，我们可以采用和每个客户通话记录一样的记录方式，利用map将每个客户名映射到一个vector容器，只不过这次容器中装载的是完整通话。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;call&gt; &gt; costInf;</span><br><span class="line"><span class="comment">//costInf["张三"]现在就代表着姓名为张三的客户的所有完整通话</span></span><br></pre></td></tr></table></figure>
<p>　　遍历信息　　</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : customer)&#123; <span class="comment">//遍历所有客户</span></span><br><span class="line">        sort((i.second).begin(), (i.second).end(), cmp);</span><br><span class="line">        <span class="comment">//将每个用户的通话记录按时间升序排序</span></span><br><span class="line">        <span class="keyword">bool</span> isOnLine = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//isOnLine用来标记客户当前是否正在通话</span></span><br><span class="line">        call temp;  <span class="comment">//temp记录一次完整通话</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : (i.second))&#123;   <span class="comment">//遍历该客户所有通话记录</span></span><br><span class="line">            <span class="keyword">if</span>(j.line)&#123; <span class="comment">//遇到开始通话的通话记录</span></span><br><span class="line">                isOnLine = <span class="literal">true</span>;    <span class="comment">//标记当前状态为正在通话</span></span><br><span class="line">                temp.onMonth = j.month, temp.onDd = j.dd, temp.onHh = j.hh, temp.onMm = j.mm;</span><br><span class="line">                <span class="comment">//记录开始通话时间</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!j.line &amp;&amp; isOnLine)&#123;  <span class="comment">//如果现在正在通话且当前通话记录为结束通话</span></span><br><span class="line">                isOnLine = <span class="literal">false</span>;   <span class="comment">//标记当前状态为结束通话</span></span><br><span class="line">                temp.offMonth = j.month, temp.offDd = j.dd, temp.offHh = j.hh, temp.offMm = j.mm;</span><br><span class="line">                <span class="comment">//记录通话结束时间</span></span><br><span class="line">                temp.sumTime = <span class="number">0</span>;</span><br><span class="line">                temp.cost = <span class="number">0</span>;</span><br><span class="line">                clt(temp.onDd, temp.onHh, temp.onMm, temp.offDd, temp.offHh, temp.offMm, temp.sumTime, temp.cost);</span><br><span class="line">                <span class="comment">//计算本次通话的时长于消耗</span></span><br><span class="line">                costInf[j.name].push_back(temp);</span><br><span class="line">                <span class="comment">//将当前完整通话信息记录入其客户所在容器中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　由于我们之前已经将通话记录排序，所以获取的完整通话记录一定是时间升序。</p>
<p>　　对与计算每次完整通话时间与消耗，我们只需要由开始通话时间开始，每次加一分钟，到开始时间等于结束时间为止，在过程中记录通话时间与花费金额即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clt</span><span class="params">(<span class="keyword">int</span> bgdd, <span class="keyword">int</span> bghh, <span class="keyword">int</span> bgmm, <span class="keyword">int</span> eddd, <span class="keyword">int</span> edhh, <span class="keyword">int</span> edmm, <span class="keyword">int</span> &amp;sumTime, <span class="keyword">int</span> &amp;cost)</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入开始时间与结束时间，把我们要计算的两个值传引用。</span></span><br><span class="line">    <span class="keyword">while</span>(bgdd &lt; eddd || bghh &lt; edhh || bgmm &lt; edmm)&#123;   <span class="comment">//开始时间小于结束时间</span></span><br><span class="line">        sumTime++;  <span class="comment">//通话时间加一分钟</span></span><br><span class="line">        cost += toll[bghh]; <span class="comment">//将该分钟的收费计入消耗</span></span><br><span class="line">        bgmm++; <span class="comment">//开始时间加一分钟</span></span><br><span class="line">        <span class="keyword">if</span>(bgmm == <span class="number">60</span>)&#123; <span class="comment">//分钟进位</span></span><br><span class="line">            bgmm = <span class="number">0</span>;</span><br><span class="line">            bghh++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bghh == <span class="number">24</span>)&#123; <span class="comment">//小时进位</span></span><br><span class="line">            bghh = <span class="number">0</span>;</span><br><span class="line">            bgdd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> AC代码 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> toll[<span class="number">25</span>];   <span class="comment">//记录每个小时每分钟通话的收费</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">//客户名</span></span><br><span class="line">    <span class="keyword">int</span> month, dd, hh,mm;   <span class="comment">//时间</span></span><br><span class="line">    <span class="keyword">bool</span> line;  <span class="comment">//结束通话标识 true表示on-line false表示off—line</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">call</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">//客户名</span></span><br><span class="line">    <span class="keyword">int</span> onMonth, onDd, onHh, onMm;  <span class="comment">//开始通话时间</span></span><br><span class="line">    <span class="keyword">int</span> offMonth, offDd, offHh, offMm;  <span class="comment">//结束通话时间</span></span><br><span class="line">    <span class="keyword">int</span> sumTime;    <span class="comment">//通话时长</span></span><br><span class="line">    <span class="keyword">int</span> cost;   <span class="comment">//通话消耗</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; mp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;node&gt; &gt; customer;</span><br><span class="line"><span class="comment">//customer["张三"]现在就代表着姓名为张三的用户的所有通话记录</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;call&gt; &gt; costInf;</span><br><span class="line"><span class="comment">//costInf["张三"]现在就代表着姓名为张三的客户的所有完整通话</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;   <span class="comment">//按时间升序排序</span></span><br><span class="line">    <span class="keyword">if</span>(a.month != b.month)</span><br><span class="line">        <span class="keyword">return</span> a.month &lt; b.month;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.dd != b.dd)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.dd &lt; b.dd;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.hh != b.hh)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.hh &lt; b.hh;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.mm != b.mm)</span><br><span class="line">        <span class="keyword">return</span> a.mm &lt; b.mm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clt</span><span class="params">(<span class="keyword">int</span> bgdd, <span class="keyword">int</span> bghh, <span class="keyword">int</span> bgmm, <span class="keyword">int</span> eddd, <span class="keyword">int</span> edhh, <span class="keyword">int</span> edmm, <span class="keyword">int</span> &amp;sumTime, <span class="keyword">int</span> &amp;cost)</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入开始时间与结束时间，把我们要计算的两个值传引用。</span></span><br><span class="line">    <span class="keyword">while</span>(bgdd &lt; eddd || bghh &lt; edhh || bgmm &lt; edmm)&#123;   <span class="comment">//开始时间小于结束时间</span></span><br><span class="line">        sumTime++;  <span class="comment">//通话时间加一分钟</span></span><br><span class="line">        cost += toll[bghh]; <span class="comment">//将该分钟的收费计入消耗</span></span><br><span class="line">        bgmm++; <span class="comment">//开始时间加一分钟</span></span><br><span class="line">        <span class="keyword">if</span>(bgmm == <span class="number">60</span>)&#123; <span class="comment">//分钟进位</span></span><br><span class="line">            bgmm = <span class="number">0</span>;</span><br><span class="line">            bghh++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bghh == <span class="number">24</span>)&#123; <span class="comment">//小时进位</span></span><br><span class="line">            bghh = <span class="number">0</span>;</span><br><span class="line">            bgdd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mp[<span class="string">"on-line"</span>] = <span class="literal">true</span>;</span><br><span class="line">    mp[<span class="string">"off-line"</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;toll[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        node temp;  <span class="comment">//temp记录当前输入的通话记录信息</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name;   <span class="comment">//输入姓名</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d:%d"</span>, &amp;temp.month, &amp;temp.dd, &amp;temp.hh, &amp;temp.mm);</span><br><span class="line">        <span class="comment">//输入时</span></span><br><span class="line">        <span class="built_in">string</span> tline;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tline;   <span class="comment">//输入通话标识</span></span><br><span class="line">        temp.line = mp[tline];  <span class="comment">//这里的mp将"on-line"映射为true将"off-line"映射为false</span></span><br><span class="line">        customer[temp.name].push_back(temp);</span><br><span class="line">        <span class="comment">//将当前信息记录入其客户所对应的容器中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : customer)&#123; <span class="comment">//遍历所有客户</span></span><br><span class="line">        sort((i.second).begin(), (i.second).end(), cmp);</span><br><span class="line">        <span class="comment">//将每个用户的通话记录按时间升序排序</span></span><br><span class="line">        <span class="keyword">bool</span> isOnLine = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//isOnLine用来标记客户当前是否正在通话</span></span><br><span class="line">        call temp;  <span class="comment">//temp记录一次完整通话</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : (i.second))&#123;   <span class="comment">//遍历该客户所有通话记录</span></span><br><span class="line">            <span class="keyword">if</span>(j.line)&#123; <span class="comment">//遇到开始通话的通话记录</span></span><br><span class="line">                isOnLine = <span class="literal">true</span>;    <span class="comment">//标记当前状态为正在通话</span></span><br><span class="line">                temp.onMonth = j.month, temp.onDd = j.dd, temp.onHh = j.hh, temp.onMm = j.mm;</span><br><span class="line">                <span class="comment">//记录开始通话时间</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!j.line &amp;&amp; isOnLine)&#123;  <span class="comment">//如果现在正在通话且当前通话记录为结束通话</span></span><br><span class="line">                isOnLine = <span class="literal">false</span>;   <span class="comment">//标记当前状态为结束通话</span></span><br><span class="line">                temp.offMonth = j.month, temp.offDd = j.dd, temp.offHh = j.hh, temp.offMm = j.mm;</span><br><span class="line">                <span class="comment">//记录通话结束时间</span></span><br><span class="line">                temp.sumTime = <span class="number">0</span>;</span><br><span class="line">                temp.cost = <span class="number">0</span>;</span><br><span class="line">                clt(temp.onDd, temp.onHh, temp.onMm, temp.offDd, temp.offHh, temp.offMm, temp.sumTime, temp.cost);</span><br><span class="line">                <span class="comment">//计算本次通话的时长于消耗</span></span><br><span class="line">                costInf[j.name].push_back(temp);</span><br><span class="line">                <span class="comment">//将当前完整通话信息记录入其客户所在容器中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : costInf)&#123;  <span class="comment">//遍历所有客户，输出信息</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (i.first) &lt;&lt; <span class="string">" "</span>;   <span class="comment">//输出客户名</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//标记月份是否已经输出</span></span><br><span class="line">        <span class="keyword">double</span> tam = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : (i.second))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;  <span class="comment">//没有输出月份</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%02d\n"</span>, j.onMonth);</span><br><span class="line">                flag = <span class="literal">true</span>;    <span class="comment">//格式化输出月份并将flag标记为true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d %02d:%02d:%02d %d $%.2f\n"</span>, j.onDd, j.onHh, j.onMm, j.offDd, j.offHh, j.offMm, j.sumTime, j.cost / <span class="number">100.0</span>);</span><br><span class="line">            <span class="comment">//格式化输出开始时间 结束时间 通话时长 通话消耗（美分转为美元）</span></span><br><span class="line">            tam += j.cost/ <span class="number">100.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Total amount: $%.2f\n"</span>, tam);</span><br><span class="line">        <span class="comment">//输出总消耗</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/18/PTA-Advanced-Level-1015-Reversible-Primes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/18/PTA-Advanced-Level-1015-Reversible-Primes/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1015 Reversible Primes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-18 16:47:54" itemprop="dateCreated datePublished" datetime="2018-12-18T16:47:54+08:00">2018-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　A reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p>
<p>　　Now given any two positive integers N (&lt;) and D (1), you are supposed to tell if N is a reversible prime with radix D.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　The input file consists of several test cases. Each case occupies a line which contains two integers N and D. The input is finished by a negative N.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each test case, print in one line <code>Yes</code> if N is a reversible prime with radix D, or <code>No</code> if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">73 10</span><br><span class="line">23 2</span><br><span class="line">23 10</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出一个十进制数字n，之后给出其进制d，要求判断其是不是可逆素数，若是可逆素数输出Yes否则输出No。</p>
<p>　　本题的可逆素数要求给出数字本身是素数且，将其转化为给出的进制，反转后重新转化为十进制还是素数。</p>
<p>　　如：23的2进制为10111反转后为11101 = 29，29与23都是素数，所以23是可逆素数。</p>
<p>　　由于本题有多组输入，所以可以用素数筛（埃氏筛法）先将素数打表。</p>
<p>　　埃氏筛法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPrime</span><span class="params">()</span></span>&#123;   <span class="comment">//埃氏筛法</span></span><br><span class="line">    <span class="comment">//每找到一个一个素数将其倍数都标记为不是素数</span></span><br><span class="line">    <span class="comment">//时间复杂度O(n loglogn)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="literal">false</span>)&#123;    <span class="comment">//i是素数</span></span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; maxn; j += i)&#123;</span><br><span class="line">                vis[j] = <span class="literal">true</span>;  <span class="comment">//标记所以i的倍数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后根据我们得到的素数判断输入的数是否为素数，若不是素数直接输出No，若是素数则将其转化为对应进制的数字后反转，将反转后得到的数字重新转化为10进制，在判断其是不是素数，是的话输出Yes否则输出No。</p>
<p>　　这样我们就需要两个函数，一个用来将其他进制数转化为10进制。另一个用来将10进制转化为其他进制并反转。</p>
<p>转化为d进制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decimalToOther</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> radix)</span></span>&#123;  <span class="comment">//将十进制数转化为其他进制数</span></span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="comment">//ans从最低位开始记录，结束后得到的直接就是转化后数字的反转</span></span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        ans += (num % radix) + <span class="string">'0'</span>;</span><br><span class="line">        num /= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 转化为10进制 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">toDecimal</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> radix)</span></span>&#123;    <span class="comment">//将某进制数转化为10进制</span></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++)&#123;</span><br><span class="line">        ans = ans * radix + (num[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> AC代码 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPrime</span><span class="params">()</span></span>&#123;   <span class="comment">//埃氏筛法</span></span><br><span class="line">    <span class="comment">//每找到一个一个素数将其倍数都标记为不是素数</span></span><br><span class="line">    <span class="comment">//时间复杂度O(n loglogn)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="literal">false</span>)&#123;    <span class="comment">//i是素数</span></span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt; maxn; j += i)&#123;</span><br><span class="line">                vis[j] = <span class="literal">true</span>;  <span class="comment">//标记所以i的倍数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">toDecimal</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> radix)</span></span>&#123;    <span class="comment">//将某进制数转化为10进制</span></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++)&#123;</span><br><span class="line">        ans = ans * radix + (num[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">decimalToOther</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> radix)</span></span>&#123;  <span class="comment">//将十进制数转化为其他进制数</span></span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="comment">//ans从最低位开始记录，结束后得到的直接就是转化后数字的反转</span></span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        ans += (num % radix) + <span class="string">'0'</span>;</span><br><span class="line">        num /= radix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    findPrime();    <span class="comment">//素数打表</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//输入n，n &lt; 0时直接结束运算</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">        <span class="comment">//输入进制d</span></span><br><span class="line">        <span class="keyword">if</span>(vis[n] == <span class="literal">true</span> || n &lt;= <span class="number">1</span>)&#123;   <span class="comment">//若n不是素数直接输出No进行下一次运算</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> toRadix = decimalToOther(n, d);</span><br><span class="line">        <span class="comment">//将n转化为d进制并反转</span></span><br><span class="line">        <span class="keyword">int</span> ans = toDecimal(toRadix, d);</span><br><span class="line">        <span class="comment">//将反转的数重新转化为10进制</span></span><br><span class="line">        <span class="keyword">if</span>(vis[ans] == <span class="literal">true</span> || ans &lt;= <span class="number">1</span>)&#123;<span class="comment">//若反转的数不是素数输出No</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);    <span class="comment">//否则输出Yes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/17/PTA-Advanced-Level-1014-Waiting-in-Line/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/17/PTA-Advanced-Level-1014-Waiting-in-Line/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1014 Waiting in Line</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-17 21:47:51" itemprop="dateCreated datePublished" datetime="2018-12-17T21:47:51+08:00">2018-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　Suppose a bank has N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are:</p>
<ul>
<li>The space inside the yellow line in front of each window is enough to contain a line with Mcustomers. Hence when all the N lines are full, all the customers after (and including) the (st one will have to wait in a line behind the yellow line.</li>
<li>Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number.</li>
<li>Customeri will take Ti minutes to have his/her transaction processed.</li>
<li>The first N customers are assumed to be served at 8:00am.</li>
</ul>
<p>　　Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done.</p>
<p>　　For example, suppose that a bank has 2 windows and each window may have 2 custmers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer1 is served at window1 while customer2 is served at window2. Customer3 will wait in front of window1 and customer4 will wait in front of window2. Customer5 will wait behind the yellow line.</p>
<p>　　At 08:01, customer1 is done and customer5 enters the line in front of window1 since that line seems shorter now. Customer2 will leave at 08:02, customer4 at 08:06, customer3 at 08:07, and finally customer5 at 08:10.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case. Each case starts with a line containing 4 positive integers: N (≤, number of windows), M (≤, the maximum capacity of each line inside the yellow line), K (≤, number of customers), and Q (≤, number of customer queries).</p>
<p>　　The next line contains K positive integers, which are the processing time of the K customers.</p>
<p>　　The last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format <code>HH:MM</code> where <code>HH</code> is in [08, 17] and <code>MM</code> is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output <code>Sorry</code> instead.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 2 7 5</span><br><span class="line">1 2 6 4 3 534 2</span><br><span class="line">3 4 5 6 7</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">08:07</span><br><span class="line">08:06</span><br><span class="line">08:10</span><br><span class="line">17:00</span><br><span class="line">Sorry</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题意思是银行有n个窗口，每个窗口前最多可以排m个人，现在有k个人，所有窗口从8点开始服务，到17点停止<strong>接受</strong>服务，不过如果17点前接受了服务，无论多晚也会服务完该客户。要求按查询输出客户完成服务的时间（愚蠢的顾客们只要选定一个排队的窗口就会一直排到关门，即使其他窗口空了也不换）。</p>
<p>　　本题每组测试数据首先给出4个整数，分别为窗口数量n、最大排队人数m、客户人数k、查询数量q，之后一行包括k个整数，代表服务每个客户所需要的时间（分钟），下一行包括q个整数，代表查询的客户。</p>
<p>　　首先分析一下样例<br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217204731686-2120059976.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217204906854-2084365850.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217205006622-109122127.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217205048366-1862476535.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217205127835-1367261046.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217205356305-1536761116.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217205504799-729189424.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217205639679-1335197869.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217205917604-2026796990.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217210136247-1425635367.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217210252125-877684797.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217210404646-320711987.png" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217210547699-456260582.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181217211203699-1805800642.png" alt="img"></p>
<p>我们可以吧每一个窗口看作一个先进先出的队列，队列的容量为m，一共有n个这样的队列。queue<int> win[maxw]　，win[ i ]便代表第i窗口的队列。由于客户总是会选择最短的队列，所以在所有队列被填满时不会有出队操作。每个队列在开始处理今天第一名客户时记录现在以及消耗的时间为0，在所有队列都被填满后就要执行出队操作了，我们需要找到哪个窗口的客户先处理完，对其所在的窗口进行出队，同时获得当前处理的客户的结束时间与下一名客户的开始时间，之后将下一名客户入队。</int></p>
<p>　　在所有客户都入队后需要对所有窗口进行出队操作，这样便可以获得所有客户的开始时间与结束时间。</p>
<p>找到排队最短的窗口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinSize</span><span class="params">(<span class="keyword">int</span> &amp;w)</span></span>&#123; <span class="comment">//获得当前排队长度最短的窗口</span></span><br><span class="line">    <span class="keyword">int</span> minSize = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(win[i].size() &lt; minSize)&#123;</span><br><span class="line">            minSize = win[i].size();</span><br><span class="line">            w = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 找到最先处理完的客户所在的窗口并执行出队 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123; <span class="comment">//找到最先处理完的客户所在的窗口并执行出队</span></span><br><span class="line">    <span class="keyword">int</span> disWin; <span class="comment">//记录最先处理完的客户所在的窗口</span></span><br><span class="line">    <span class="keyword">int</span> disEdTime = INT_MAX;    <span class="comment">//记录记录最先处理完的客户的结束时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(disEdTime &gt; nowTime[i] + needTime[win[i].front()])&#123;</span><br><span class="line">            <span class="comment">//服务结束时间为当前窗口消耗时间假设处理该客户需要消耗的时间</span></span><br><span class="line">            disWin = i; <span class="comment">//记录窗口与结束时间</span></span><br><span class="line">            disEdTime = nowTime[i] + needTime[win[i].front()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    edTime[win[disWin].front()] = disEdTime;    <span class="comment">//记录客户结束时间</span></span><br><span class="line">    win[disWin].pop();  <span class="comment">//出队</span></span><br><span class="line">    nowTime[disWin] = disEdTime;    <span class="comment">//记录该窗口现在已经消耗的时间</span></span><br><span class="line">    <span class="keyword">if</span>(!win[disWin].empty())</span><br><span class="line">        bgTime[win[disWin].front()] = disEdTime;</span><br><span class="line">        <span class="comment">//下一名客户的开始时间就是上一名客户的结束时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 某窗口全部出队 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disposeAll</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//处理某窗口全部出队</span></span><br><span class="line">    <span class="keyword">while</span>(!win[w].empty())&#123;</span><br><span class="line">        edTime[win[w].front()] = nowTime[w] + needTime[win[w].front()];</span><br><span class="line">        <span class="comment">//获得用户结束时间</span></span><br><span class="line">        nowTime[w] = edTime[win[w].front()];</span><br><span class="line">        <span class="comment">//记录当前窗口消耗时间</span></span><br><span class="line">        win[w].pop();</span><br><span class="line">        <span class="keyword">if</span>(!win[w].empty())<span class="comment">//记录下一个用户的开始时间</span></span><br><span class="line">            bgTime[win[w].front()] = nowTime[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后读入查询，判断所查询的客户的开始时间是否在17：00前，如果在17：00前输出其结束时间，否则输出Sorry。</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw = <span class="number">25</span>;    <span class="comment">//最大窗口数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">1e3</span>+<span class="number">10</span>;    <span class="comment">//最大客户数</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; win[maxw];   <span class="comment">//窗口队列</span></span><br><span class="line"><span class="keyword">int</span> nowTime[maxw];  <span class="comment">//记录每个窗口当前服务客户已经消耗的时间</span></span><br><span class="line"><span class="keyword">int</span> needTime[maxk]; <span class="comment">//记录服务每个客户需要消耗的时间</span></span><br><span class="line"><span class="keyword">int</span> bgTime[maxk];   <span class="comment">//记录每个客户开始被服务的时间</span></span><br><span class="line"><span class="keyword">int</span> edTime[maxk];   <span class="comment">//记录每个客户服务结束的时间</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, q; <span class="comment">//n窗口数，m队列长度，k客户数，q查询数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinSize</span><span class="params">(<span class="keyword">int</span> &amp;w)</span></span>&#123; <span class="comment">//获得当前排队长度最短的窗口</span></span><br><span class="line">    <span class="keyword">int</span> minSize = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(win[i].size() &lt; minSize)&#123;</span><br><span class="line">            minSize = win[i].size();</span><br><span class="line">            w = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123; <span class="comment">//找到最先处理完的客户所在的窗口并执行出队</span></span><br><span class="line">    <span class="keyword">int</span> disWin; <span class="comment">//记录最先处理完的客户所在的窗口</span></span><br><span class="line">    <span class="keyword">int</span> disEdTime = INT_MAX;    <span class="comment">//记录记录最先处理完的客户的结束时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(disEdTime &gt; nowTime[i] + needTime[win[i].front()])&#123;</span><br><span class="line">            <span class="comment">//服务结束时间为当前窗口消耗时间假设处理该客户需要消耗的时间</span></span><br><span class="line">            disWin = i; <span class="comment">//记录窗口与结束时间</span></span><br><span class="line">            disEdTime = nowTime[i] + needTime[win[i].front()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    edTime[win[disWin].front()] = disEdTime;    <span class="comment">//记录客户结束时间</span></span><br><span class="line">    win[disWin].pop();  <span class="comment">//出队</span></span><br><span class="line">    nowTime[disWin] = disEdTime;    <span class="comment">//记录该窗口现在已经消耗的时间</span></span><br><span class="line">    <span class="keyword">if</span>(!win[disWin].empty())</span><br><span class="line">        bgTime[win[disWin].front()] = disEdTime;</span><br><span class="line">        <span class="comment">//下一名客户的开始时间就是上一名客户的结束时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disposeAll</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//处理某窗口全部出队</span></span><br><span class="line">    <span class="keyword">while</span>(!win[w].empty())&#123;</span><br><span class="line">        edTime[win[w].front()] = nowTime[w] + needTime[win[w].front()];</span><br><span class="line">        <span class="comment">//获得用户结束时间</span></span><br><span class="line">        nowTime[w] = edTime[win[w].front()];</span><br><span class="line">        <span class="comment">//记录当前窗口消耗时间</span></span><br><span class="line">        win[w].pop();</span><br><span class="line">        <span class="keyword">if</span>(!win[w].empty())<span class="comment">//记录下一个用户的开始时间</span></span><br><span class="line">            bgTime[win[w].front()] = nowTime[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;q) != EOF)&#123;</span><br><span class="line">        <span class="comment">//输入n窗口数，m队列长度，k客户数，q查询数</span></span><br><span class="line">        <span class="built_in">memset</span>(nowTime, <span class="number">0</span>, <span class="keyword">sizeof</span>(nowTime));</span><br><span class="line">        <span class="built_in">memset</span>(needTime, <span class="number">0</span>, <span class="keyword">sizeof</span>(needTime));</span><br><span class="line">        <span class="built_in">memset</span>(edTime, <span class="number">0</span>, <span class="keyword">sizeof</span>(edTime));</span><br><span class="line">        <span class="built_in">memset</span>(bgTime, <span class="number">0</span>, <span class="keyword">sizeof</span>(bgTime));</span><br><span class="line">        <span class="comment">//将所有时间初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;needTime[i]);</span><br><span class="line">            <span class="comment">//输入服务每个客户所需要的时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minSize, minWin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;    <span class="comment">//遍历所有客户</span></span><br><span class="line">            minSize = getMinSize(minWin);   <span class="comment">//找到当前排队最短的窗口</span></span><br><span class="line">            <span class="keyword">if</span>(minSize &gt;= m)&#123;   <span class="comment">//如果所有窗口的队都满了</span></span><br><span class="line">                dispose();  <span class="comment">//执行最先处理完客户所在的窗口出队</span></span><br><span class="line">                minSize = getMinSize(minWin);   <span class="comment">//重新获得最短的队</span></span><br><span class="line">            &#125;</span><br><span class="line">            win[minWin].push(i);    <span class="comment">//入队</span></span><br><span class="line">            <span class="keyword">if</span>(win[minWin].empty())&#123;    <span class="comment">//每个窗口的第一个客户信息</span></span><br><span class="line">                nowTime[minSize] = <span class="number">0</span>;   <span class="comment">//当前窗口消耗时间为0</span></span><br><span class="line">                bgTime[i] = <span class="number">0</span>;  <span class="comment">//第一名客户的开始时间为0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//遍历所有窗口全部出队</span></span><br><span class="line">            <span class="keyword">if</span>(!win[i].empty())&#123;</span><br><span class="line">                disposeAll(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123; <span class="comment">//获得查询</span></span><br><span class="line">            <span class="keyword">int</span> query;</span><br><span class="line">            <span class="keyword">int</span> endtime, begintime;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);</span><br><span class="line">            endtime = edTime[query];</span><br><span class="line">            begintime = bgTime[query];</span><br><span class="line">            <span class="comment">//获得查询用户的开始与结束时间</span></span><br><span class="line">            <span class="keyword">int</span> beginhours = <span class="number">8</span> + (begintime / <span class="number">60</span>);</span><br><span class="line">            <span class="keyword">int</span> beginminutes = begintime % <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">int</span> endhours = <span class="number">8</span> + (endtime / <span class="number">60</span>);</span><br><span class="line">            <span class="keyword">int</span> endminutes = endtime % <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">if</span>(beginhours &gt;= <span class="number">17</span>)&#123;   <span class="comment">//开始时间大于17输出Sorry</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Sorry\n"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%02d:%02d\n"</span>, endhours, endminutes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/16/PTA-Advanced-Level-1013-Battle-Over-Cities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/16/PTA-Advanced-Level-1013-Battle-Over-Cities/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1013 Battle Over Cities</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-16 20:34:57" itemprop="dateCreated datePublished" datetime="2018-12-16T20:34:57+08:00">2018-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.</p>
<p>For example, if we have 3 cities and 2 highways connecting city1-city2 and city1-city3. Then if city1 is occupied by the enemy, we must have 1 highway repaired, that is the highway city2-city3.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;), Mand K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>解题思路：</p>
<p>　　城市之间本来有一些道路，现在有某个城市被攻陷了，与该城市连通的道路就都不能走了，如果剩下还在我们手里的城市不连通，就要修筑新道路使他们连通，任意两个城市都可以修筑新道路。<br>　　本题每组数据首先给出城市数量n，道路数量m，查询数量k，每次查询只有一个城市被攻陷，之后给出m行数据为每条道路连接的两个城市，随后一行有k个数，表示当前次查询中被攻陷的城市，要求输出最少需要新修筑多少条道路才可以使我们手里剩下的城市都连通。</p>
<p>　　这里使用并查集解答本题。（本题需要路径压缩，否则会T）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != father[x])</span><br><span class="line">        father[x] = getFather(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　首先使用邻接表记录所有道路信息，每次查询遍历所有道路，通过并查集合并所有不与被攻陷城市连接的道路两端的城市。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//遍历所有道路</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != closed &amp;&amp; it != closed)&#123;    <span class="comment">//道路不能与被攻陷的城市相连</span></span><br><span class="line">                        <span class="keyword">int</span> fu = getFather(i);</span><br><span class="line">                        <span class="keyword">int</span> fv = getFather(it);</span><br><span class="line">                        <span class="keyword">if</span>(fu != fv)    <span class="comment">//如果两个城市不在同一个连通块中，合并这两个连通块</span></span><br><span class="line">                            father[fu] = fv;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p> 之后对于还在我们手里的城市，获得合并后的连通块数量ans，ans - 1即可获得最少需要新修筑的道路数量。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//获得连通块数量</span></span><br><span class="line">    <span class="keyword">if</span>(getFather(i) == i &amp;&amp; i != closed)&#123;   <span class="comment">//只要某个城市所在连通块父节点为自己且这个城市不是被攻陷的城市</span></span><br><span class="line">        ans++;  <span class="comment">//连通块加一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> father[maxn];   <span class="comment">//father[i]记录i所在连通块的父节点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];    <span class="comment">//临界表记录边信息</span></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;   <span class="comment">//并查集路径压缩找爹函数</span></span><br><span class="line">    <span class="keyword">if</span>(x != father[x])</span><br><span class="line">        father[x] = getFather(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k) != EOF)&#123;  <span class="comment">//输入城市数量 道路数量 查询数量</span></span><br><span class="line">        <span class="keyword">while</span>(m--)&#123; <span class="comment">//输入道路信息</span></span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="comment">//G[i]记录与i城市连通的道路</span></span><br><span class="line">            G[u].push_back(v);</span><br><span class="line">            G[v].push_back(u);</span><br><span class="line">            <span class="comment">//道路是双向的，所以道路两端的城市都要记录这条道路</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> closed; <span class="comment">//closed记录当前被攻陷的城市</span></span><br><span class="line">        <span class="keyword">while</span>(k--)&#123; <span class="comment">//k条查询</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)  <span class="comment">//初始化每个城市自己单独在一个连通块</span></span><br><span class="line">                father[i] = i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;closed);   <span class="comment">//输入被攻陷的城市</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//遍历所有道路</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it : G[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != closed &amp;&amp; it != closed)&#123;    <span class="comment">//道路不能与被攻陷的城市相连</span></span><br><span class="line">                        <span class="keyword">int</span> fu = getFather(i);</span><br><span class="line">                        <span class="keyword">int</span> fv = getFather(it);</span><br><span class="line">                        <span class="keyword">if</span>(fu != fv)    <span class="comment">//如果两个城市不在同一个连通块中，合并这两个连通块</span></span><br><span class="line">                            father[fu] = fv;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//获得连通块数量</span></span><br><span class="line">                <span class="keyword">if</span>(getFather(i) == i &amp;&amp; i != closed)&#123;   <span class="comment">//只要某个城市所在连通块父节点为自己且这个城市不是被攻陷的城市</span></span><br><span class="line">                    ans++;  <span class="comment">//连通块加一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);    <span class="comment">//输出答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/15/PTA-Advanced-Level-1012-The-Best-Rank/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/15/PTA-Advanced-Level-1012-The-Best-Rank/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1012 The Best Rank</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-15 20:30:56" itemprop="dateCreated datePublished" datetime="2018-12-15T20:30:56+08:00">2018-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: <code>C</code> - C Programming Language, <code>M</code> - Mathematics (Calculus or Linear Algrbra), and <code>E</code> - English. At the mean time, we encourage students by emphasizing on their best ranks — that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.</p>
<p>　　For example, The grades of <code>C</code>, <code>M</code>, <code>E</code> and <code>A</code> - Average of 4 students are given as the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StudentID  C  M  E  A</span><br><span class="line">310101     98 85 88 90</span><br><span class="line">310102     70 95 88 84</span><br><span class="line">310103     82 87 94 88</span><br><span class="line">310104     91 91 91 91</span><br></pre></td></tr></table></figure>
<p>　　Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of <code>C</code>, <code>M</code> and <code>E</code>. Then there are M lines, each containing a student ID.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.</p>
<p>　　The priorities of the ranking methods are ordered as <code>A</code> &gt; <code>C</code> &gt; <code>M</code> &gt; <code>E</code>. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.</p>
<p>　　If a student is not on the grading list, simply output <code>N/A</code>.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">310101 98 85 88</span><br><span class="line">310102 70 95 88</span><br><span class="line">310103 82 87 94</span><br><span class="line">310104 91 91 91</span><br><span class="line">310105 85 90 90</span><br><span class="line">310101</span><br><span class="line">310102</span><br><span class="line">310103</span><br><span class="line">310104</span><br><span class="line">310105</span><br><span class="line">999999</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 C</span><br><span class="line">1 M</span><br><span class="line">1 E</span><br><span class="line">1 A</span><br><span class="line">3 A</span><br><span class="line">N&#x2F;A</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出学生数量n，与查询数量m，之后n行为学生信息，包括id，C语言得分， 数学得分，英语得分，按照平均分、C语言、数学、英语分别排序（项目名分别为A, C, M, E），之后m行查询为学生id，要求输出查询学生的这四个排名中的最高排名，若出现某几项排名相同且都该学生最高排名，输出优先级平均分 &gt; C语言 &gt; 数学 &gt; 英语。</p>
<p>　　定义一个结构体student记录每个学生的信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//记录学号</span></span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>];   <span class="comment">//score[0]为平均分 score[1]C语言 score[2]数学 score[3]英语 </span></span><br><span class="line">    <span class="comment">//为了方便输出直接按优先级顺序记录学生分数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>　　用一个vector容器储存所有学生信息，一个int型的二维数组rank_stu[ i ][ j ]记录排名信息，i为学生排名， j为排名依照项，同样 0 为平均分 1 C语言 2 数学 3 英语 。之后对所有项目进行排名，将得到的排名记录入rank_stu中就可以开始查找了。</p>
<p>　　查找时要先判断输入的查询学号存不存在，可以将rank_stu初始化为0，如果查询当前学号某一排名为 0 证明该学号不存在，若存在，比较其所有项目排名并输出最高项排名与项目名。</p>
<p>　　AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> inf = INT_MAX;</span><br><span class="line"><span class="comment">//无穷大</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000000</span>;</span><br><span class="line"><span class="comment">//学号最大值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> course[<span class="number">4</span>] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line"><span class="comment">//记录项目名</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//记录学号</span></span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">4</span>];   <span class="comment">//score[0]为平均分 score[1]C语言 score[2]数学 score[3]英语</span></span><br><span class="line">    <span class="comment">//为了方便输出直接按优先级顺序记录学生分数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;student&gt; stu;    <span class="comment">//记录学生信息</span></span><br><span class="line"><span class="keyword">int</span> rank_stu[maxn][<span class="number">4</span>];  <span class="comment">//记录排名</span></span><br><span class="line"><span class="keyword">int</span> courseNow;  <span class="comment">//当前正在排名的课程</span></span><br><span class="line"><span class="keyword">int</span> n, m;   <span class="comment">//学生数量，查询数量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(student a, student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score[courseNow] &gt; b.score[courseNow];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序依照当前courseNow的对应成绩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRank</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rank_stu, <span class="number">0</span>, <span class="keyword">sizeof</span>(rank_stu));</span><br><span class="line">    <span class="comment">//初始化rank_stu为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//获得并记录四个项目的排名</span></span><br><span class="line">        courseNow = i;  <span class="comment">//设定当前排名课程</span></span><br><span class="line">        sort(stu.begin(), stu.end(), cmp);  <span class="comment">//对stu进行排序</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;student&gt;::iterator preit = stu.begin();  <span class="comment">//preit记录获取排名过程中上一个位置迭代器</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;student&gt;::iterator it = stu.begin(); it != stu.end(); it++)&#123;</span><br><span class="line">            cnt++;  <span class="comment">//记录当前学生位置</span></span><br><span class="line">            <span class="keyword">if</span>(it == stu.begin())&#123;  <span class="comment">//若it排名第一直接记录排名为cnt（cnt当前值为1）</span></span><br><span class="line">                rank_stu[it-&gt;id][courseNow] = cnt;</span><br><span class="line">                preit = it; <span class="comment">//记录下一个学生的前一个迭代器为it</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(preit-&gt;score[courseNow] == it-&gt;score[courseNow])&#123;</span><br><span class="line">                    <span class="comment">//前一个学生与本学生成绩相同则排名相同</span></span><br><span class="line">                    rank_stu[it-&gt;id][courseNow] = rank_stu[preit-&gt;id][courseNow];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    rank_stu[it-&gt;id][courseNow] =  cnt;</span><br><span class="line">                    <span class="comment">//否则记录当前排名为cnt</span></span><br><span class="line">                &#125;</span><br><span class="line">                preit = it;<span class="comment">//记录下一个学生的前一个迭代器为it</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)&#123;    <span class="comment">//输入学生数量与排名数量</span></span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            student temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;temp.id, &amp;temp.score[<span class="number">1</span>], &amp;temp.score[<span class="number">2</span>], &amp;temp.score[<span class="number">3</span>]);</span><br><span class="line">            <span class="comment">//输入学生信息</span></span><br><span class="line">            temp.score[<span class="number">0</span>] = (temp.score[<span class="number">1</span>] + temp.score[<span class="number">2</span>] + temp.score[<span class="number">3</span>]) / <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//计算平均分</span></span><br><span class="line">            stu.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getRank();</span><br><span class="line">        <span class="comment">//获取排名</span></span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> query;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;query);</span><br><span class="line">            <span class="comment">//输入查询id</span></span><br><span class="line">            <span class="keyword">if</span>(rank_stu[query][<span class="number">0</span>] == <span class="number">0</span>)&#123;    <span class="comment">//学生不存在</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"N/A\n"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> hRank = inf;    <span class="comment">//初始化最高排名为无穷大</span></span><br><span class="line">            <span class="keyword">int</span> hRcourse = <span class="number">-1</span>;  <span class="comment">//hRcourse记录最高排名对应的项目</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rank_stu[query][i] &lt; hRank)&#123;</span><br><span class="line">                    hRank = rank_stu[query][i];</span><br><span class="line">                    hRcourse = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %c\n"</span>, hRank, course[hRcourse]);</span><br><span class="line">            <span class="comment">//输出排名与项目名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/14/PTA-Advanced-Level-1010-Radix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/14/PTA-Advanced-Level-1010-Radix/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1010 Radix</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-14 14:38:12" itemprop="dateCreated datePublished" datetime="2018-12-14T14:38:12+08:00">2018-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is <code>yes</code>, if 6 is a decimal number and 110 is a binary number.</p>
<p>　　Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case. Each case occupies a line which contains 4 positive integers:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">N1 N2 tag radix</span><br></pre></td></tr></table></figure>
<p>　　Here <code>N1</code> and <code>N2</code> each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, <code>a</code>-<code>z</code> } where 0-9 represent the decimal numbers 0-9, and <code>a</code>-<code>z</code> represent the decimal numbers 10-35. The last number <code>radix</code> is the radix of <code>N1</code> if <code>tag</code> is 1, or of <code>N2</code> if <code>tag</code> is 2.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each test case, print in one line the radix of the other number so that the equation <code>N1</code> = <code>N2</code> is true. If the equation is impossible, print <code>Impossible</code>. If the solution is not unique, output the smallest possible radix.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 110 1 10</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ab 1 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出两个数字n1、n2，给出其中一个数字tag的进制radix，要求判断是否存在某一进制可以使另一个数字与给定数字相等。</p>
<p>　　为了方便运算，用字符串tn1、tn2记录输入的两个数字，字符串n1记录给定进制的数字，字符串n2记录未确定数字。用map<char, int> mp，记录每个字符所对应的数值，之后，可以先将给定进制的数字n1转化为10进制，n2的进制最小为其包含的最大数字+1记为leftn，且由于n2是整数，所以其进制最大不会超过n1的十进制与leftn中较大的一个+1，记为rightn。以leftn和rightn分别为左右边界二分所有进制，记mid为中点进制，将n2按mid进制转化为10进制与n1的十进制进行比较，如果n2较大证明mid取值过大，将rightn记为mid - 1；若小了，证明mid取值过小，leftn记为mid+1，若正好相等则找到答案。若无法找到某进制使得n1与n2相等，返回-1，如果返回的答案不为-1，输出答案，否则输出Impossible。</char,></p>
<p>　　AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, LL&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i = <span class="string">'0'</span>; i &lt;= <span class="string">'9'</span>; i++)&#123;</span><br><span class="line">        mp[i] = i - <span class="string">'0'</span>;    <span class="comment">//初始化0 - 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; i++)&#123;</span><br><span class="line">        mp[i] = i - <span class="string">'a'</span> + <span class="number">10</span>;   <span class="comment">//初始化a - z</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">toDecimal</span><span class="params">(<span class="built_in">string</span> a, LL radix, LL maxn)</span></span>&#123;  <span class="comment">//转化为10进制的函数，所转化后的数不会超过给出的maxn</span></span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        ans = ans * radix + mp[a[i]];</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; <span class="number">0</span> || ans &gt; maxn)&#123;  <span class="comment">//如果数据溢出了或超过上限</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//返回-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//返回转化后的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a, LL radix, LL n1)</span></span>&#123; <span class="comment">//比较函数，用于比较n2的radix进制转化为10进制后与n1的十进制的大小</span></span><br><span class="line">    LL n2_10 = toDecimal(a, radix, n1);</span><br><span class="line">    <span class="comment">//获得n2转化为10进制的值</span></span><br><span class="line">    <span class="keyword">if</span>(n2_10 == n1) <span class="comment">//如果n2的10进制与n1的十进制相同证明该进制是我们要获得的进制，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n2_10 &lt; <span class="number">0</span>)  <span class="comment">//如果toDecimal函数返回的n2小于0，证明n2在该进制下转化为十进制后大于n1的十进制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//进制过大返回1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n1 &gt; n2_10) <span class="comment">//如果n2在当前进制下转化为10进制小于n1的十进制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//进制过小返回-1</span></span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">//否则返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getRadix</span><span class="params">(<span class="built_in">string</span> a, LL leftn, LL rightn, LL n1)</span></span>&#123;</span><br><span class="line">    <span class="comment">//二分函数传入n2字符串，最小进制，最大进制，n1的十进制值</span></span><br><span class="line">    <span class="keyword">while</span>(leftn &lt;= rightn)&#123;</span><br><span class="line">        LL mid = (leftn + rightn) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//获得中点</span></span><br><span class="line">        LL flag = cmp(a, mid, n1);</span><br><span class="line">        <span class="comment">//判断终点进制n1与n2状态</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)   <span class="comment">//若比较函数返回了0，证明在mid进制下n1与n2相等</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//返回mid</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">-1</span>)&#123;    <span class="comment">//进制过小</span></span><br><span class="line">            leftn = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;    <span class="comment">//进制过大</span></span><br><span class="line">            rightn = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxNum</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;    <span class="comment">//获得n2中最大的数字</span></span><br><span class="line">    LL ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span>::iterator it = a.begin(); it != a.end(); it++)&#123;</span><br><span class="line">        ans = max(ans, mp[*it]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="comment">//初始化mp</span></span><br><span class="line">    <span class="built_in">string</span> tn1, tn2, n1, n2;</span><br><span class="line">    <span class="keyword">int</span> tag, radix;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tn1 &gt;&gt; tn2 &gt;&gt; tag &gt;&gt; radix;</span><br><span class="line">    <span class="comment">//输入 tn1 tn2 tag radix;</span></span><br><span class="line">    <span class="keyword">if</span>(tag == <span class="number">1</span>)&#123;</span><br><span class="line">        n1 = tn1;</span><br><span class="line">        n2 = tn2;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        n1 = tn2;</span><br><span class="line">        n2 = tn1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n1记录已经确定进制的数字，n2记录未确定的数字</span></span><br><span class="line">    LL n1_10 = toDecimal(n1, radix, INT_MAX);</span><br><span class="line">    <span class="comment">//将n1转化为10进制其上限为无穷大</span></span><br><span class="line">    LL leftn = getMaxNum(n2) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获得n2的最小进制</span></span><br><span class="line">    LL rightn = max(leftn, n1_10) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获得n2的最大进制</span></span><br><span class="line">    LL ans = getRadix(n2, leftn, rightn, n1_10);</span><br><span class="line">    <span class="comment">//二分所有进制</span></span><br><span class="line">    <span class="keyword">if</span>(tn1 == tn2)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, radix);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SUVVM"
      src="/images/ortrait.jpg">
  <p class="site-author-name" itemprop="name">SUVVM</p>
  <div class="site-description" itemprop="description">SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suvvm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suvvm" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/suvvm@foxmail.com" title="E-Mail → suvvm@foxmail.com"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SUVVM</span>
	<a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">鲁ICP备19040043号-2</a>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  

</body>
</html>
