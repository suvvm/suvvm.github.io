<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/ortrait.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.suvvm.work","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:type" content="website">
<meta property="og:title" content="SUVVM">
<meta property="og:url" content="https://www.suvvm.work/page/7/index.html">
<meta property="og:site_name" content="SUVVM">
<meta property="og:description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SUVVM">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.suvvm.work/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SUVVM</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e5190116d64be66cac29daef18c94ac0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SUVVM</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">呜嗷SUVVM</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/22/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B-L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B-L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/" class="post-title-link" itemprop="url">PTA (天梯赛) L3-005 垃圾箱分布</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 22:20:33" itemprop="dateCreated datePublished" datetime="2019-11-22T22:20:33+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="L3-005-垃圾箱分布-30-分"><a href="#L3-005-垃圾箱分布-30-分" class="headerlink" title="L3-005 垃圾箱分布 (30 分)"></a>L3-005 垃圾箱分布 (30 分)</h2><p>大家倒垃圾的时候，都希望垃圾箱距离自己比较近，但是谁都不愿意守着垃圾箱住。所以垃圾箱的位置必须选在到所有居民点的最短距离最长的地方，同时还要保证每个居民点都在距离它一个不太远的范围内。</p>
<p>现给定一个居民区的地图，以及若干垃圾箱的候选地点，请你推荐最合适的地点。如果解不唯一，则输出到所有居民点的平均距离最短的那个解。如果这样的解还是不唯一，则输出编号最小的地点。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出4个正整数：<em>N</em>（≤103）是居民点的个数；<em>M</em>（≤10）是垃圾箱候选地点的个数；<em>K</em>（≤104）是居民点和垃圾箱候选地点之间的道路的条数；<em>D**S</em>是居民点与垃圾箱之间不能超过的最大距离。所有的居民点从1到<em>N</em>编号，所有的垃圾箱候选地点从<em>G</em>1到<em>G**M</em>编号。</p>
<p>随后<em>K</em>行，每行按下列格式描述一条道路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1 P2 Dist</span><br></pre></td></tr></table></figure>
<p>其中<code>P1</code>和<code>P2</code>是道路两端点的编号，端点可以是居民点，也可以是垃圾箱候选点。<code>Dist</code>是道路的长度，是一个正整数。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第一行输出最佳候选地点的编号。然后在第二行输出该地点到所有居民点的最小距离和平均距离。数字间以空格分隔，保留小数点后1位。如果解不存在，则输出<code>No Solution</code>。</p>
<h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 3 11 5</span><br><span class="line">1 2 2</span><br><span class="line">1 4 2</span><br><span class="line">1 G1 4</span><br><span class="line">1 G2 3</span><br><span class="line">2 3 2</span><br><span class="line">2 G2 1</span><br><span class="line">3 4 2</span><br><span class="line">3 G3 2</span><br><span class="line">4 G1 3</span><br><span class="line">G2 G1 1</span><br><span class="line">G3 G2 2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G1</span><br><span class="line">2.0 3.3</span><br></pre></td></tr></table></figure>
<h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1 2 10</span><br><span class="line">1 G1 9</span><br><span class="line">2 G1 20</span><br></pre></td></tr></table></figure>
<h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure>
<p>作者: 陈越</p>
<p>单位: 浙江大学</p>
<p>时间限制: 200 ms</p>
<p>内存限制: 64 MB</p>
<p>代码长度限制: 16 KB</p>
<p>这是个中规中矩的最短路题目，没有要求记录路径，只是在最后结果判断时有些许繁琐。</p>
<p>输入时需要判断一下输入的时数字还是垃圾桶候选点，PTA是支持c11的，c11的string封装了stringToInt的函数std::stoi所以在输入时将P1与P2全部以string类型读入之后进行处理即可。</p>
<p>处理函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span> inp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inp[<span class="number">0</span>] != <span class="string">'G'</span>)</span><br><span class="line">        <span class="keyword">return</span> stoi(inp);</span><br><span class="line">    <span class="keyword">if</span>(inp.size() == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> inp[<span class="number">1</span>] - <span class="string">'0'</span> + n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里起点的个数最多只有10个，所以直接遍历起点执行dijkstra即可。</p>
<p>dijkstra</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> bg)</span></span>&#123;</span><br><span class="line">    fill(d, d +MAXN, INF);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    d[bg] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Node&gt; Q;</span><br><span class="line">    Q.push(Node&#123;bg, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        Node top = Q.top();</span><br><span class="line">        <span class="keyword">int</span> u = top.v;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i.v;</span><br><span class="line">            <span class="keyword">int</span> dis = i.dis;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; d[u] + dis &lt; d[v])&#123;</span><br><span class="line">                d[v] = d[u] + dis;</span><br><span class="line">                Q.push(Node&#123;v,d[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意最终要求中最优为存在最长最短距离最长的最短路，若有多个最长最短距离相等的答案则取其中到每个点平均值最小的，若依旧有多个解则取其中垃圾桶标号最小的。</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, k, ds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tNode) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; tNode.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span> inp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inp[<span class="number">0</span>] != <span class="string">'G'</span>)</span><br><span class="line">        <span class="keyword">return</span> stoi(inp);</span><br><span class="line">    <span class="keyword">if</span>(inp.size() == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> inp[<span class="number">1</span>] - <span class="string">'0'</span> + n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> bg)</span></span>&#123;</span><br><span class="line">    fill(d, d +MAXN, INF);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    d[bg] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Node&gt; Q;</span><br><span class="line">    Q.push(Node&#123;bg, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        Node top = Q.top();</span><br><span class="line">        <span class="keyword">int</span> u = top.v;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i.v;</span><br><span class="line">            <span class="keyword">int</span> dis = i.dis;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; d[u] + dis &lt; d[v])&#123;</span><br><span class="line">                d[v] = d[u] + dis;</span><br><span class="line">                Q.push(Node&#123;v,d[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> p1, p2;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; ds;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis;</span><br><span class="line">        Adj[toInt(p1)].push_back(Node&#123;toInt(p2), dis&#125;);</span><br><span class="line">        Adj[toInt(p2)].push_back(Node&#123;toInt(p1), dis&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>,ansMin = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> ansSum = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; n + m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dijkstra(i);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">double</span> nowSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nowMin = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; ds)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d[j] &lt; nowMin)&#123;</span><br><span class="line">                nowMin = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nowSum += d[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nowMin &gt; ansMin)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                ansMin = nowMin;</span><br><span class="line">                ansSum = nowSum;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nowMin == ansMin) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ansSum &gt; nowSum)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    ansSum = nowSum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'G'</span> &lt;&lt; ans-n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f %.1f\n"</span>, (<span class="keyword">double</span>)ansMin, ((ansSum / (<span class="keyword">double</span>)n) * <span class="number">100.0</span>+<span class="number">0.5</span>)/<span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Floyd原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 17:23:17" itemprop="dateCreated datePublished" datetime="2019-11-16T17:23:17+08:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Floyd（弗洛伊德算法）"><a href="#Floyd（弗洛伊德算法）" class="headerlink" title="Floyd（弗洛伊德算法）"></a>Floyd（弗洛伊德算法）</h2><h3 id="Floyd算法原理"><a href="#Floyd算法原理" class="headerlink" title="Floyd算法原理"></a>Floyd算法原理</h3><p>Floyd算法是用来解决全源最短路问题的算法，其原理支持便是如果给定的图中存在一个顶点k，使得以k点作为中介点时可以使图中另外两个顶点，顶点i与顶点j之间的最短距离缩短。假设以d[i][j]作为当前顶点i与顶点j之间的最短距离，则上述原理可以表示为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(d[i][k] + d[k][i] &lt; d[i][j]) &#123;</span><br><span class="line">	d[i][j] = d[i][k] + d[k][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd过程模拟"><a href="#Floyd过程模拟" class="headerlink" title="Floyd过程模拟"></a>Floyd过程模拟</h3><p>以下图为例，进行一次Floyd运行过程的模拟。</p>
<p><img src="/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/floyd1-1.svg" alt="img"></p>
<h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><p>初始将所有点之间的最短距离都记为无穷大，每个点到其本身距离为0，在输入时记录更新路径两端的点的最短距离。</p>
<p>初始最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第一个k（k为A点）"><a href="#第一个k（k为A点）" class="headerlink" title="第一个k（k为A点）"></a>第一个k（k为A点）</h4><p>遍历所有顶点，查看以A点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;B当前为无穷大 C-&gt;A当前为4 A-&gt;B当前为2 C-&gt;B被A优化为4+2&#x3D;6</span><br><span class="line">C-&gt;D当前为无穷大 C-&gt;A当前为4 A-&gt;D当前为1 C-&gt;D被A优化为4+1&#x3D;5</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td><code>6</code></td>
<td>0</td>
<td><code>5</code></td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第二个k（k为B点）"><a href="#第二个k（k为B点）" class="headerlink" title="第二个k（k为B点）"></a>第二个k（k为B点）</h4><p>遍历所有顶点，查看以B点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;E当前为无穷大 A-&gt;B当前为2 B-&gt;E当前为10 A-&gt;E被B优化为2+10&#x3D;12</span><br><span class="line">C-&gt;E当前为无穷大 C-&gt;B当前为6 B-&gt;E当前为10 C-&gt;E被B优化为6+10&#x3D;16</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td><code>12</code></td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td><code>16</code></td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第三个k（k为C点）"><a href="#第三个k（k为C点）" class="headerlink" title="第三个k（k为C点）"></a>第三个k（k为C点）</h4><p>遍历所有顶点，查看以C点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D-&gt;A当前为无穷大 D-&gt;C当前为2 C-&gt;A当前为4 D-&gt;A被C优化为2+4&#x3D;6</span><br><span class="line">D-&gt;B当前为无穷大 D-&gt;C当前为2 C-&gt;B当前为6 D-&gt;B被C优化为2+6&#x3D;8</span><br><span class="line">D-&gt;F当前为8 D-&gt;C当前为2 C-&gt;F当前为5 D-&gt;F被C优化为2+5&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>12</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>16</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td><code>6</code></td>
<td><code>8</code></td>
<td>2</td>
<td>0</td>
<td>2</td>
<td><code>7</code></td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第四个k（k为D点）"><a href="#第四个k（k为D点）" class="headerlink" title="第四个k（k为D点）"></a>第四个k（k为D点）</h4><p>遍历所有顶点，查看以D点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;C当前为无穷大 A-&gt;D当前为1 D-&gt;C当前为2 A-&gt;C被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;E当前为12 A-&gt;D当前为1 D-&gt;E当前为2 A-&gt;E被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;F当前为无穷大 A-&gt;D当前为1 D-&gt;F当前为7 A-&gt;F被D优化为1+7&#x3D;8</span><br><span class="line">A-&gt;G当前为无穷大 A-&gt;D当前为1 D-&gt;G当前为4 A-&gt;G被D优化为1+4&#x3D;5</span><br><span class="line">B-&gt;A当前为无穷大 B-&gt;D当前为3 D-&gt;A当前为6 B-&gt;A被D优化为3+6&#x3D;9</span><br><span class="line">B-&gt;C当前为无穷大 B-&gt;D当前为3 D-&gt;C当前为2 B-&gt;C被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;E当前为10 B-&gt;D当前为3 D-&gt;E当前为2 B-&gt;E被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;F当前为无穷大 B-&gt;D当前为3 D-&gt;F当前为7 B-&gt;F被D优化为3+7&#x3D;10</span><br><span class="line">B-&gt;G当前为无穷大 B-&gt;D当前为3 D-&gt;G当前为4 B-&gt;G被D优化为3+4&#x3D;7</span><br><span class="line">C-&gt;E当前为16 C-&gt;D当前为5 D-&gt;E当前为2 C-&gt;E被D优化为2+5&#x3D;7</span><br><span class="line">C-&gt;G当前为无穷大 C-&gt;D当前为5 D-&gt;G当前为4 C-&gt;G被D优化为5+4&#x3D;9</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td><code>3</code></td>
<td>1</td>
<td><code>3</code></td>
<td><code>8</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><strong>B</strong></td>
<td><code>9</code></td>
<td>0</td>
<td><code>5</code></td>
<td>3</td>
<td><code>5</code></td>
<td><code>10</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td><code>7</code></td>
<td>5</td>
<td><code>9</code></td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第五个k（k为E点）"><a href="#第五个k（k为E点）" class="headerlink" title="第五个k（k为E点）"></a>第五个k（k为E点）</h4><p>遍历所有顶点，查看以E点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>找不到可被优化的点。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第六个k（k为F点）"><a href="#第六个k（k为F点）" class="headerlink" title="第六个k（k为F点）"></a>第六个k（k为F点）</h4><p>遍历所有顶点，查看以F点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>找不到可被优化的点。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第七个k（k为G点）"><a href="#第七个k（k为G点）" class="headerlink" title="第七个k（k为G点）"></a>第七个k（k为G点）</h4><p>遍历所有顶点，查看以G点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;F当前为8 A-&gt;G当前为5 G-&gt;F当前为1 A-&gt;F被G优化为5+1&#x3D;6</span><br><span class="line">B-&gt;F当前为10 B-&gt;G当前为7 G-&gt;F当前为1 B-&gt;F被G优化为7+1&#x3D;8</span><br><span class="line">D-&gt;F当前为7 D-&gt;G当前为4 G-&gt;F当前为1 D-&gt;F被G优化为4+1&#x3D;5</span><br><span class="line">E-&gt;F当前为无穷大 E-&gt;G当前为6 G-&gt;F当前为1 E-&gt;F被G优化为6+1&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td><code>6</code></td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td><code>8</code></td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td><code>5</code></td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td><code>7</code></td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++)&#123;    <span class="comment">//存在顶点k可以使得顶点i到顶点j的最小距离缩短</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">                   <span class="comment">// printf("%c优化%c-&gt;%c:%7d\n",'A' + k ,'A'+i, 'A'+j,dis[i][j]);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 输出每次优化的数据</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; n; i ++)&#123;</span></span><br><span class="line"><span class="comment">            for( int j = 0; j &lt; n; j ++)&#123;</span></span><br><span class="line"><span class="comment">                printf("%c-&gt;%c:%7d ", 'A'+i, 'A'+j,dis[i][j]);</span></span><br><span class="line"><span class="comment">                // cout &lt;&lt; dis[i][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; i ++)&#123;    // 错误写法</span></span><br><span class="line"><span class="comment">        for(int j = 0; j &lt; n; j ++)&#123;</span></span><br><span class="line"><span class="comment">            for(int k = 0; k &lt; n; k ++)&#123;</span></span><br><span class="line"><span class="comment">                if(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span></span><br><span class="line"><span class="comment">                    dis[i][j] = dis[i][k] + dis[k][j];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边 (端点1 端点2 权值):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dis[u][v] = w;</span><br><span class="line">        <span class="comment">//dis[v][u] = dis;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i ++)&#123;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"初始状态："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c-&gt;%c:%7d "</span>, <span class="string">'A'</span>+i, <span class="string">'A'</span>+j,dis[i][j]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dis[i][j] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Floyd();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最终状态："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c-&gt;%c:%7d "</span>, <span class="string">'A'</span>+i, <span class="string">'A'</span>+j,dis[i][j]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dis[i][j] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>对于Floyd算法来说，最外层循环的k不能放到内层，如果将k放到内层会导致最终结果出错，这是因为如果先对被优化的点进行遍历的话，当其遍历过去后相当于已经固定之后再也无法优化。</p>
<p>例如，如果当前有一条路径i-&gt;u-&gt;v-&gt;j若u &gt; i 在遍历到u时出现了点k可以将u-&gt;v的距离缩短，但这时却无法重新对i-&gt;j进行优化，这就导致了错误。</p>
<h3 id="错误模拟"><a href="#错误模拟" class="headerlink" title="错误模拟"></a>错误模拟</h3><p>以下图为例，进行一次Floyd错误运行的模拟。</p>
<p><img src="/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/floyd1-1.svg" alt="img"></p>
<h4 id="初始状态-1"><a href="#初始状态-1" class="headerlink" title="初始状态"></a>初始状态</h4><p>初始将所有点之间的最短距离都记为无穷大，每个点到其本身距离为0，在输入时记录更新路径两端的点的最短距离。</p>
<p>初始最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第一个i（i为A点）"><a href="#第一个i（i为A点）" class="headerlink" title="第一个i（i为A点）"></a>第一个i（i为A点）</h4><p>遍历所有顶点，查看以A点为起点时是否存在A到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;C当前为无穷大 A-&gt;D当前为1 D-&gt;C当前为2 A-&gt;C被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;E当前为无穷大 A-&gt;B当前为2 B-&gt;E当前为10 A-&gt;E被B优化为2+10&#x3D;12</span><br><span class="line">A-&gt;E当前为12 A-&gt;D当前为1 D-&gt;E当前为2 A-&gt;E被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;F当前为无穷大 A-&gt;C当前为3 C-&gt;F当前为5 A-&gt;F被C优化为3+5&#x3D;8</span><br><span class="line">A-&gt;G当前为无穷大 A-&gt;D当前为1 D-&gt;G当前为4 A-&gt;G被C优化为1+4&#x3D;5</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td><code>3</code></td>
<td>1</td>
<td><code>3</code></td>
<td><code>8</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第二个i（i为B点）"><a href="#第二个i（i为B点）" class="headerlink" title="第二个i（i为B点）"></a>第二个i（i为B点）</h4><p>遍历所有顶点，查看以B点为起点时是否存在B到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B-&gt;C当前为无穷大 B-&gt;D当前为3 D-&gt;C当前为2 B-&gt;C被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;E当前为10 B-&gt;D当前为3 D-&gt;E当前为2 B-&gt;E被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;F当前为无穷大 B-&gt;C当前为5 C-&gt;F当前为5 B-&gt;F被C优化为5+5&#x3D;10</span><br><span class="line">B-&gt;G当前为无穷大 B-&gt;D当前为3 D-&gt;G当前为4 B-&gt;G被D优化为3+4&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td><code>5</code></td>
<td>3</td>
<td><code>5</code></td>
<td><code>10</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第三个i（i为C点）"><a href="#第三个i（i为C点）" class="headerlink" title="第三个i（i为C点）"></a>第三个i（i为C点）</h4><p>遍历所有顶点，查看以C点为起点时是否存在C到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;B当前为无穷大 C-&gt;A当前为4 A-&gt;B当前为2 C-&gt;B被A优化为4+2&#x3D;6</span><br><span class="line">C-&gt;D当前为无穷大 C-&gt;A当前为4 A-&gt;D当前为1 C-&gt;D被A优化为4+1&#x3D;5</span><br><span class="line">C-&gt;E当前为无穷大 C-&gt;A当前为4 A-&gt;E当前为3 C-&gt;E被A优化为4+3&#x3D;7</span><br><span class="line">C-&gt;G当前为无穷大 C-&gt;A当前为4 A-&gt;G当前为5 C-&gt;G被A优化为4+5&#x3D;9</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td><code>6</code></td>
<td>0</td>
<td><code>5</code></td>
<td><code>7</code></td>
<td>5</td>
<td><code>9</code></td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第四个i（i为D点）"><a href="#第四个i（i为D点）" class="headerlink" title="第四个i（i为D点）"></a>第四个i（i为D点）</h4><p>遍历所有顶点，查看以D点为起点时是否存在D到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D-&gt;A当前为无穷大 D-&gt;C当前为2 C-&gt;A当前为4 D-&gt;A被C优化为2+4&#x3D;6</span><br><span class="line">D-&gt;B当前为无穷大 D-&gt;A当前为6 A-&gt;B当前为2 D-&gt;B被A优化为6+2&#x3D;8</span><br><span class="line">D-&gt;F当前为8 D-&gt;C当前为2 C-&gt;F当前为5 D-&gt;F被C优化为2+5&#x3D;7</span><br><span class="line">D-&gt;F当前为7 D-&gt;G当前为4 G-&gt;F当前为1 D-&gt;F被G优化为4+1&#x3D;5</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td><code>6</code></td>
<td><code>8</code></td>
<td>2</td>
<td>0</td>
<td>2</td>
<td><code>5</code></td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第五个i（i为E点）"><a href="#第五个i（i为E点）" class="headerlink" title="第五个i（i为E点）"></a>第五个i（i为E点）</h4><p>遍历所有顶点，查看以E点为起点时是否存在E到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E-&gt;F当前为无穷大 E-&gt;G当前为6 G-&gt;F当前为1 E-&gt;F被G优化为6+1&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td><code>7</code></td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第六个i（i为F点）"><a href="#第六个i（i为F点）" class="headerlink" title="第六个i（i为F点）"></a>第六个i（i为F点）</h4><p>遍历所有顶点，查看以F点为起点时是否存在F到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>没有可优化的情况。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第七个i（i为G点）"><a href="#第七个i（i为G点）" class="headerlink" title="第七个i（i为G点）"></a>第七个i（i为G点）</h4><p>遍历所有顶点，查看以G点为起点时是否存在G到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>没有可优化的情况。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="错误结果"><a href="#错误结果" class="headerlink" title="错误结果"></a>错误结果</h4><p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>明显与上方正确答案存在很大差异</p>
<p>所以对中介点k的遍历一定要放在最外层。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">SPFA原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-13 08:13:28" itemprop="dateCreated datePublished" datetime="2019-11-13T08:13:28+08:00">2019-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SPFA原理分析"><a href="#SPFA原理分析" class="headerlink" title="SPFA原理分析"></a>SPFA原理分析</h2><h3 id="贝尔曼-福特算法时间复杂度"><a href="#贝尔曼-福特算法时间复杂度" class="headerlink" title="贝尔曼 福特算法时间复杂度"></a>贝尔曼 福特算法时间复杂度</h3><p>针对N个顶点E条边的连通图，由于Bellman Ford算法需要对所有的边遍历N-1次后再添加一次额外的遍历(<a href="https://www.suvvm.work/2019/11/12/Bellman-Ford原理分析/">详见</a>)，其时间复杂度为 $ O(N\times E)$ 。这个复杂度依旧不尽人意，现在要对其进行优化，之前针对贝尔曼 福特算法的分析中指出，如果最短路存在，松弛操作的次数不会超过N-1，正因如此，每个点被优化的次数也不会超过N-1，且只有当某个顶点u到源点的最短距离发生改变，它所发出的边所指向的另外一点v到源点的最短路才有可能会发生改变。</p>
<h3 id="进行优化"><a href="#进行优化" class="headerlink" title="进行优化"></a>进行优化</h3><p>以上方思想为指导进行优化，初始将源点到所有顶点最短路距离视为无穷大，之后维护一个队列，每次将队首的顶点u取出，对从u出发的所有边进行遍历，如果u可以使边另一端的顶点v到达源点的最短距离缩短，则进行优化操作，如果当前v不在队列中则将v入队，这样一旦队列为空时证明所有的优化已经完成，便可以成功获得源点到所有点的最短路长度，而一旦某个点被优化的次数超过N-1则说明给出的图中有从源点可达的负环。</p>
<h3 id="模拟SPFA运行过程"><a href="#模拟SPFA运行过程" class="headerlink" title="模拟SPFA运行过程"></a>模拟SPFA运行过程</h3><p>以下图为例，进行一次SPFA运行过程的模拟。</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-1.svg" alt="img"></p>
<p>以A为起点，依旧用其他最短路算法一样，将初始状态的，源点到所有点之间的最短距离视为无穷大。</p>
<h4 id="优化源点"><a href="#优化源点" class="headerlink" title="优化源点"></a>优化源点</h4><p>记录源点到其本身的距离为0，并将其入队。</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-2.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h4><p>将队首的元素A出队，遍历所有以A为起点的边</p>
<p>以A为起点的边有权值为2的$A\rightarrow B$与权值为3的$A\rightarrow C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(∞)	将B点到源点的最短距离由无穷大优化为0+2&#x3D;2</span><br><span class="line">边A(0)	3	C(∞)	将C点到源点的最短距离由无穷大优化为0+2&#x3D;3</span><br></pre></td></tr></table></figure>
<p>将被优化的B点和C点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-3.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h4><p>将队首的元素B出队，遍历所有以B为起点的边</p>
<p>以B为起点的边有权值为6的$B\rightarrow E$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边B(2)	6	E(∞)	将E点到源点的最短距离由无穷大优化为2+6&#x3D;8</span><br></pre></td></tr></table></figure>
<p>将被优化的E点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-4.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>C</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">8</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第三次优化"><a href="#第三次优化" class="headerlink" title="第三次优化"></a>第三次优化</h4><p>将队首的元素C出队，遍历所有以C为起点的边</p>
<p>以B为起点的边有权值为-2的$C\rightarrow B$与权值为5的$C\rightarrow E$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边C(3)	-2	B(2)	将B点到源点的最短距离由无穷大优化为3-2&#x3D;1</span><br><span class="line">边C(3)	5	E(8)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>将被优化的B点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-5.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>E</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">8</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第四次优化"><a href="#第四次优化" class="headerlink" title="第四次优化"></a>第四次优化</h4><p>将队首的元素E出队，遍历所有以E为起点的边</p>
<p>以E为起点的边有权值为-5的$E\rightarrow D$与权值为8的$E\rightarrow F$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边E(8)	-5	D(∞)	将D点到源点的最短距离由无穷大优化为8-5&#x3D;3</span><br><span class="line">边E(8)	8	F(∞)	将F点到源点的最短距离由无穷大优化为8+8&#x3D;16</span><br></pre></td></tr></table></figure>
<p>将被优化的点D点F入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-6.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>B</th>
<th>D</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>16</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">8</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第五次优化"><a href="#第五次优化" class="headerlink" title="第五次优化"></a>第五次优化</h4><p>将队首的元素B出队，遍历所有以B为起点的边</p>
<p>以B为起点的边有权值为6的$B\rightarrow E$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边B(1)	4	E(8)	将E点到源点的最短距离由8优化为1+6&#x3D;7</span><br></pre></td></tr></table></figure>
<p>将被优化的E点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-7.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>D</th>
<th>F</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>16</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第六次优化"><a href="#第六次优化" class="headerlink" title="第六次优化"></a>第六次优化</h4><p>将队首的元素D出队，遍历所有以D为起点的边</p>
<p>以D为起点的边有权值为4的$D\rightarrow B$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边D(3)	6	B(1)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-8.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>F</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第七次优化"><a href="#第七次优化" class="headerlink" title="第七次优化"></a>第七次优化</h4><p>将队首的元素F出队，遍历所有以F为起点的边</p>
<p>以F为起点的边有权值为3的$F\rightarrow C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边F(16)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-9.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第八次优化"><a href="#第八次优化" class="headerlink" title="第八次优化"></a>第八次优化</h4><p>将队首的元素E出队，遍历所有以E为起点的边</p>
<p>以E为起点的边有权值为-5的$E\rightarrow D$与权值为8的$E\rightarrow F$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边E(7)	-5	D(3)	将D点到源点的最短距离由无穷大优化为7-5&#x3D;2</span><br><span class="line">边E(7)	8	F(16)	将F点到源点的最短距离由无穷大优化为7+8&#x3D;15</span><br></pre></td></tr></table></figure>
<p>将被优化的点D点F入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-10.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>D</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第九次优化"><a href="#第九次优化" class="headerlink" title="第九次优化"></a>第九次优化</h4><p>将队首的元素D出队，遍历所有以D为起点的边</p>
<p>以D为起点的边有权值为4的$D\rightarrow B$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边D(2)	4	B(1)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-11.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第十次优化"><a href="#第十次优化" class="headerlink" title="第十次优化"></a>第十次优化</h4><p>将队首的元素F出队，遍历所有以F为起点的边</p>
<p>以F为起点的边有权值为3的$F\rightarrow C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边F(15)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-12.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>没啦！</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<p>到此为止所有的优化都完成了，虽然比较原生的Bellman-Ford要多了五次优化，但SPFA的每次优化并不需要遍历所有边，只需要遍历以出队点为源点的边即可，这就将SPFA的时间复杂度大大降低，降为了$O(M\times E)$而且通常情况下M不会超过2，这使得SPFA再处理没有负环的情况下的速度往往要优于堆优化的dijkstra，但是不要太寄希望于SPFA，都知道它快，所以有很多题目都会有专门的一组数据来卡SPFA（具体请随便找一个搜索引擎搜索卡SPFA），而且SPFA在有负环时时间复杂度会退化为$O(N\times E)$ 我比较懒，就不模拟负环运行了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d, d + MAXN, INF); <span class="comment">//初始化起点到所有点的最短路长度为无穷大</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; Q;</span><br><span class="line">    d[s] = <span class="number">0</span>;   <span class="comment">//起点至本身的距离为0</span></span><br><span class="line">    Q.push(Node&#123;s, <span class="number">0</span>&#125;); <span class="comment">//这里队列中Node.v为当前点 Node.dis为当前点至起点的距离</span></span><br><span class="line">    inq[s] = <span class="literal">true</span>;  <span class="comment">//将s标记为已入队</span></span><br><span class="line">    num[s]++;   <span class="comment">//s入队次数加一</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        Node f = Q.front();   <span class="comment">//获取队首元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" 出队点："</span> &lt;&lt; f.v;</span><br><span class="line">        Q.pop();    <span class="comment">//出队</span></span><br><span class="line">        inq[f.v] = <span class="literal">false</span>; <span class="comment">//将队首对应的点标记为未入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[f.v])&#123; <span class="comment">//遍历所有该点的相邻点</span></span><br><span class="line">            <span class="keyword">int</span> v = i.v;</span><br><span class="line">            <span class="keyword">int</span> dis = i.dis;</span><br><span class="line">            <span class="keyword">if</span>(d[f.v] + i.dis &lt; d[i.v])&#123;    <span class="comment">//判断是否可以优化</span></span><br><span class="line">                d[i.v] = d[f.v] + i.dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[i.v])&#123;  <span class="comment">//优化并入队</span></span><br><span class="line">                    Q.push(Node&#123;i.v, d[i.v]&#125;);</span><br><span class="line">                    inq[i.v] = <span class="literal">true</span>;</span><br><span class="line">                    num[i.v] ++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v] &gt;= n) <span class="comment">//入队次数超过n-1则有负环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边 (端点1 端点2 权值):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, dis;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; dis;</span><br><span class="line">        Adj[u].push_back(Node&#123;v, dis&#125;);</span><br><span class="line">        <span class="comment">//Adj[v].push_back(Node&#123;u, dis&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入起点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入终点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    <span class="keyword">if</span>(SPFA(s))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"起点到终点最短路长度:"</span> &lt;&lt; d[e] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" : "</span> &lt;&lt; d[i] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Bellman Ford原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 19:11:56" itemprop="dateCreated datePublished" datetime="2019-11-12T19:11:56+08:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Bellman-Ford（贝尔曼-福特算法）"><a href="#Bellman-Ford（贝尔曼-福特算法）" class="headerlink" title="Bellman Ford（贝尔曼 福特算法）"></a>Bellman Ford（贝尔曼 福特算法）</h2><p>Dijkstra算法可以很好的解决无负权图的最短路问题，但是一旦遇到负权，这个负权就像在迷宫游戏中，走每一条路都会消耗体力，但是某些道路上有宝箱，宝箱里可以开出美利坚大香蕉食用可以恢复体力，dijkstra会使你只顾着眼前消耗体力最少的道路而忽视了之后的美利坚大香蕉（<a href="https://www.suvvm.work/2019/11/05/Dijkstra原理分析/">具体分析</a>），这时便需要设计另一个算法去代替它，如Bellman Ford。</p>
<p>如果一个有N个顶点的连通图中有最短路存在，那么这条最短路径上的顶点个数肯定不会超过N个，当源点被确定时，我们可以根据源点建立一条最短路径树，具体以下图为例，假设A为源点。</p>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf1-1.svg" alt="img"></p>
<p>最短路径树</p>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf1-2.svg" alt="img"></p>
<p>最短路径树的层数一定不会超过N。</p>
<p>Bellman Ford算法与dijkstra类似，也需要设置一个数组d用来存放源点到各个顶点的最短距离。</p>
<p>每次遍历图中所有边，根据边的权值进行松弛操作（对于每条边$u \rightarrow v $ 如果以u为中介点可以使v到源点的距离更短，就用u到源点的距离与当前边权去优化v到源点的距离）。</p>
<p>初始状态下源点已知且到其本身的距离为0，即最短路径树的第一层结点已被确定，由第二层开始之后每次执行上述的松弛操作都可以确定一层的结点，由于最短路径树的层数不会超过N，所以确定所有点到源点的最短路长度所需要进行松弛操作的次数不会超过N-1。</p>
<p>同dijkstra一样，初始将起点到所有点的最短路长度视为无穷大。</p>
<p>记录一下图中的所有边</p>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf2-1.svg" alt="img"></p>
<h3 id="确定源点"><a href="#确定源点" class="headerlink" title="确定源点"></a>确定源点</h3><p>这里以A为源点，源点到其本身的距离为0。</p>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf2-2.svg" alt="img"></p>
<p> 当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<p>一共6个点，之后进行6-1=5次松弛操作。</p>
<h3 id="第一次松弛"><a href="#第一次松弛" class="headerlink" title="第一次松弛"></a>第一次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(∞)	将B点到源点的最短距离由无穷大优化为0+2&#x3D;2</span><br><span class="line">边A(0)	3	C(∞)	将C点到源点的最短距离由无穷大优化为0+2&#x3D;3</span><br><span class="line">边B(2)	6	E(∞)	将E点到源点的最短距离由无穷大优化为2+6&#x3D;8</span><br><span class="line">边C(3)	-2	B(2)	将B点到源点的最短距离由2优化为3-2&#x3D;1</span><br><span class="line">边C(3)	5	E(8)	并不能进行优化</span><br><span class="line">边D(∞)	4	B(1)	并不能进行优化</span><br><span class="line">边E(8)	-5	D(∞)	将D点到源点的最短距离由无穷大优化为8-5&#x3D;3</span><br><span class="line">边E(8)	8	F(∞)	将F点到源点的最短距离由无穷大优化为8+8&#x3D;16</span><br><span class="line">边F(16)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf2-3.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">8</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第二次松弛"><a href="#第二次松弛" class="headerlink" title="第二次松弛"></a>第二次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(1)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(1)	6	E(8)	将E点到源点的最短距离由8优化为1+6&#x3D;7</span><br><span class="line">边C(3)	-2	B(1)	并不能进行优化</span><br><span class="line">边C(3)	5	E(7)	并不能进行优化</span><br><span class="line">边D(3)	4	B(1)	并不能进行优化</span><br><span class="line">边E(7)	-5	D(3)	将D点到源点的最短距离由3优化为7-5&#x3D;2</span><br><span class="line">边E(7)	8	F(16)	将F点到源点的最短距离由16优化为7+8&#x3D;15</span><br><span class="line">边F(15)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf2-4.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第三次松弛"><a href="#第三次松弛" class="headerlink" title="第三次松弛"></a>第三次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(1)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(1)	6	E(7)	并不能进行优化</span><br><span class="line">边C(3)	-2	B(1)	并不能进行优化</span><br><span class="line">边C(3)	5	E(7)	并不能进行优化</span><br><span class="line">边D(2)	4	B(1)	并不能进行优化</span><br><span class="line">边E(7)	-5	D(2)	并不能进行优化</span><br><span class="line">边E(7)	8	F(15)	并不能进行优化</span><br><span class="line">边F(15)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf2-4.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第四次松弛"><a href="#第四次松弛" class="headerlink" title="第四次松弛"></a>第四次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(1)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(1)	6	E(7)	并不能进行优化</span><br><span class="line">边C(3)	-2	B(1)	并不能进行优化</span><br><span class="line">边C(3)	5	E(7)	并不能进行优化</span><br><span class="line">边D(2)	4	B(1)	并不能进行优化</span><br><span class="line">边E(7)	-5	D(2)	并不能进行优化</span><br><span class="line">边E(7)	8	F(15)	并不能进行优化</span><br><span class="line">边F(15)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf2-4.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第五次松弛"><a href="#第五次松弛" class="headerlink" title="第五次松弛"></a>第五次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(1)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(1)	6	E(7)	并不能进行优化</span><br><span class="line">边C(3)	-2	B(1)	并不能进行优化</span><br><span class="line">边C(3)	5	E(7)	并不能进行优化</span><br><span class="line">边D(2)	4	B(1)	并不能进行优化</span><br><span class="line">边E(7)	-5	D(2)	并不能进行优化</span><br><span class="line">边E(7)	8	F(15)	并不能进行优化</span><br><span class="line">边F(15)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf2-4.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<p>到此为止五次松弛操作都已经结束，在对比一下我们之前肉眼观察出来的最短路径树。</p>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf1-2.svg" alt="img"></p>
<p>仿佛没有什么问题，我们成功的获得了最短路径，可喜可贺，Bellman Ford结束了，诸位洗洗睡把。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">0 1 2</span><br><span class="line">0 2 3</span><br><span class="line">1 4 6</span><br><span class="line">2 1 -2</span><br><span class="line">2 4 5</span><br><span class="line">3 1 4</span><br><span class="line">4 3 -5</span><br><span class="line">4 5 8</span><br><span class="line">5 2 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<h1 id="呸！！！"><a href="#呸！！！" class="headerlink" title="呸！！！"></a>呸！！！</h1><h3 id="负环"><a href="#负环" class="headerlink" title="负环"></a>负环</h3><p>负环这个东西很神奇，拿之前迷宫的例子来描述它，就是你可以发现有一条道路与之前的某个点形成了一个环，这个环上有一个或者多个大宝箱，里面有很多美利坚大香蕉，使得走完一次循环后吃美利坚大香蕉所恢复的体力比走路消耗的还多，这样就可以一直走这个环，刷更多的美利坚大香蕉恢复更多的体力。</p>
<p>我们修改一下上面的图，将D到B的边的边权改为-4，这样就形成了一个B到E到D回到B的一个权值为6-5-4=-3的负环。</p>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-1.svg" alt="img"></p>
<p>我们依照之前的算法再次推理一遍。</p>
<h3 id="确定源点-1"><a href="#确定源点-1" class="headerlink" title="确定源点"></a>确定源点</h3><p>以A为源点，源点到其本身的距离为0。</p>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-2.svg" alt="img"></p>
<p> 当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<p>一共6个点，之后进行6-1=5次松弛操作。</p>
<h3 id="第一次松弛-1"><a href="#第一次松弛-1" class="headerlink" title="第一次松弛"></a>第一次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(∞)	将B点到源点的最短距离由无穷大优化为0+2&#x3D;2</span><br><span class="line">边A(0)	3	C(∞)	将C点到源点的最短距离由无穷大优化为0+2&#x3D;3</span><br><span class="line">边B(2)	6	E(∞)	将E点到源点的最短距离由无穷大优化为2+6&#x3D;8</span><br><span class="line">边C(3)	-2	B(2)	将B点到源点的最短距离由2优化为3-2&#x3D;1</span><br><span class="line">边C(3)	5	E(8)	并不能进行优化</span><br><span class="line">边D(∞)	-4	B(1)	并不能进行优化</span><br><span class="line">边E(8)	-5	D(∞)	将D点到源点的最短距离由无穷大优化为8-5&#x3D;3</span><br><span class="line">边E(8)	8	F(∞)	将F点到源点的最短距离由无穷大优化为8+8&#x3D;16</span><br><span class="line">边F(16)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-3.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">8</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第二次松弛-1"><a href="#第二次松弛-1" class="headerlink" title="第二次松弛"></a>第二次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(1)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(1)	6	E(8)	将E点到源点的最短距离由8优化为1+6&#x3D;7</span><br><span class="line">边C(3)	-2	B(1)	并不能进行优化</span><br><span class="line">边C(3)	5	E(7)	并不能进行优化</span><br><span class="line">边D(3)	-4	B(1)	将B点到源点的最短距离由1优化为3-4&#x3D;-1</span><br><span class="line">边E(7)	-5	D(3)	将D点到源点的最短距离由3优化为7-5&#x3D;2</span><br><span class="line">边E(7)	8	F(16)	将F点到源点的最短距离由16优化为7+8&#x3D;15</span><br><span class="line">边F(15)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-4.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第三次松弛-1"><a href="#第三次松弛-1" class="headerlink" title="第三次松弛"></a>第三次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(-1)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(-1)	6	E(7)	将E点到源点的最短距离由7优化为-1+6&#x3D;5</span><br><span class="line">边C(3)	-2	B(-1)	并不能进行优化</span><br><span class="line">边C(3)	5	E(5)	并不能进行优化</span><br><span class="line">边D(2)	-4	B(-1)	将B点到源点的最短距离由-1优化为2-4&#x3D;-2</span><br><span class="line">边E(5)	-5	D(2)	将D点到源点的最短距离由2优化为-5+5&#x3D;0</span><br><span class="line">边E(5)	8	F(15)	将F点到源点的最短距离由15优化为5+8&#x3D;13</span><br><span class="line">边F(13)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-5.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">-2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">0</td>
<td style="text-align:left">5</td>
<td style="text-align:left">13</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第四次松弛-1"><a href="#第四次松弛-1" class="headerlink" title="第四次松弛"></a>第四次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(-2)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(-2)	6	E(5)	将E点到源点的最短距离由5优化为-2+6&#x3D;4</span><br><span class="line">边C(3)	-2	B(-2)	并不能进行优化</span><br><span class="line">边C(3)	5	E(4)	并不能进行优化</span><br><span class="line">边D(0)	-4	B(-2)	将B点到源点的最短距离由-2优化为0-4&#x3D;-4</span><br><span class="line">边E(4)	-5	D(0)	将D点到源点的最短距离由0优化为4-5&#x3D;-1</span><br><span class="line">边E(4)	8	F(13)	将F点到源点的最短距离由13优化为4+8&#x3D;12</span><br><span class="line">边F(12)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-6.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">-4</td>
<td style="text-align:left">3</td>
<td style="text-align:left">-1</td>
<td style="text-align:left">4</td>
<td style="text-align:left">12</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第五次松弛-1"><a href="#第五次松弛-1" class="headerlink" title="第五次松弛"></a>第五次松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(-4)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(-4)	6	E(4)	将E点到源点的最短距离由4优化为-4+6&#x3D;2</span><br><span class="line">边C(3)	-2	B(-4)	并不能进行优化</span><br><span class="line">边C(3)	5	E(2)	并不能进行优化</span><br><span class="line">边D(-4)	-4	B(1)	将B点到源点的最短距离由-4优化为-4-4&#x3D;-8</span><br><span class="line">边E(2)	-5	D(-1)	将D点到源点的最短距离由-1优化为2-5&#x3D;-3</span><br><span class="line">边E(2)	8	F(12)	将F点到源点的最短距离由12优化为2+8&#x3D;10</span><br><span class="line">边F(10)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-7.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">-5</td>
<td style="text-align:left">3</td>
<td style="text-align:left">-3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">10</td>
</tr>
</tbody>
</table>
</div>
<p>到此为止五次松弛操作都已经结束</p>
<p>还能不能继续松弛呢，这里再进行一次额外的松弛操作</p>
<h3 id="额外松弛"><a href="#额外松弛" class="headerlink" title="额外松弛"></a>额外松弛</h3><p>遍历所有边，根据其权值与两端点到源点的距离进行松弛操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(-5)	并不能进行优化</span><br><span class="line">边A(0)	3	C(3)	并不能进行优化</span><br><span class="line">边B(-5)	6	E(2)	将E点到源点的最短距离由2优化为-5+6&#x3D;1</span><br><span class="line">边C(3)	-2	B(-5)	并不能进行优化</span><br><span class="line">边C(3)	5	E(1)	并不能进行优化</span><br><span class="line">边D(-3)	-4	B(-5)	将B点到源点的最短距离由-5优化为-3-4&#x3D;-7</span><br><span class="line">边E(1)	-5	D(-3)	将D点到源点的最短距离由-3优化为1-5&#x3D;-4</span><br><span class="line">边E(1)	8	F(10)	将F点到源点的最短距离由10优化为1+8&#x3D;9</span><br><span class="line">边F(9)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/12/Bellman-Ford%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/bf3-8.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">-7</td>
<td style="text-align:left">3</td>
<td style="text-align:left">-4</td>
<td style="text-align:left">1</td>
<td style="text-align:left">9</td>
</tr>
</tbody>
</table>
</div>
<p>果然还可以优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">0 1 2</span><br><span class="line">0 2 3</span><br><span class="line">1 4 6</span><br><span class="line">2 1 -2</span><br><span class="line">2 4 5</span><br><span class="line">3 1 -4</span><br><span class="line">4 3 -5</span><br><span class="line">4 5 8</span><br><span class="line">5 2 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<h3 id="负环处理"><a href="#负环处理" class="headerlink" title="负环处理"></a>负环处理</h3><p>如何处理这种有负环的情况呢？当然是不去处理它，同上述步骤一样，我们多进行一次额外松弛，如果额外松弛时已经有优化发送，我们就认为这个图有负环，然后报告主函数即可。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; Adj[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BF</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d, d + MAXN, INF);<span class="comment">//初始化起点到所有点的最短路长度为无穷大</span></span><br><span class="line">    d[s] = <span class="number">0</span>;   <span class="comment">//起点至本身的距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)&#123;    <span class="comment">//遍历n - 1遍（一条最短路除去源点最多包含n-1个点，这里可以做优化）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u ++)&#123;    <span class="comment">//遍历所有顶点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : Adj[u])&#123;   <span class="comment">//找到所有与当前点连通的点</span></span><br><span class="line">                <span class="keyword">if</span>(d[j.v] &gt; d[u] + j.dis)&#123;</span><br><span class="line">                    d[j.v] = d[u] + j.dis;  <span class="comment">//松弛操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; " " &lt;&lt; i &lt;&lt; ":" &lt;&lt; d[i];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u ++)&#123;    <span class="comment">//检测负环 如果已经执行上述n-1遍理应成功获取起点至所有点的最短路 若还可以继续松弛则存在负环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : Adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j.v] &gt; d[u] + j.dis)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边 (端点1 端点2 权值):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, dis;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; dis;</span><br><span class="line">        Adj[u].push_back(node&#123;v, dis&#125;);</span><br><span class="line">        <span class="comment">//Adj[v].push_back(node&#123;u, dis&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入起点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入终点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    <span class="keyword">if</span>(BF(s))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路长度:"</span> &lt;&lt; d[e] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" : "</span> &lt;&lt; d[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/10/%E7%97%85%E6%AF%92%E7%B9%81%E6%AE%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/10/%E7%97%85%E6%AF%92%E7%B9%81%E6%AE%96/" class="post-title-link" itemprop="url">病毒繁殖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-10 19:02:02" itemprop="dateCreated datePublished" datetime="2019-11-10T19:02:02+08:00">2019-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【问题描述】  </p>
<p> 　A学校的实验室新研制出了一种十分厉害的病毒。由于这种病毒太难以人工制造了，所以专家们在一开始只做出了一个这样的病毒。 </p>
<p> 　这个病毒被植入了特殊的微型芯片，使其可以具有一些可编程的特殊性能。最重要的一个性能就是，专家们可以自行设定病毒的分裂能力 K，假如现在有x 个病毒，下一个分裂周期将会有 Kx个一模一样的病毒。你作为该实验室的数据分析员，需要统计出在分裂到第N个周期前，一共有多少个病毒单体进行了分裂。一开始时总是只有一个病毒，这个局面算作第一个周期。由于答案可能很大，专家们只需要你告诉他们对给定的P取模后的答案。</p>
<p> 【输入格式】  </p>
<p> 　一行三个整数，依次是K, N, P。</p>
<p> 【输出格式】  </p>
<p> 　一行一个整数，你的答案（对P取模） 。</p>
<p> 【输入样例】  </p>
<p> 【样例1】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 3 7</span><br></pre></td></tr></table></figure>
<p> 【样例2】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 6 23</span><br></pre></td></tr></table></figure>
<p> 【输出样例】  </p>
<p> 【样例1】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<p> 【样例2】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p> 【样例解释】  </p>
<p> 　样例一解释：第一个周期有 1 个病毒，产生了一次分裂。第二个周期有 $1 \times 5=5$ 个病毒， 这五个病毒都会分裂。 所以第三个周期前一共进行了1+5等于 6 次分裂。答案即为6 mod 7 = 6。</p>
<p> 【数据范围】  </p>
<script type="math/tex; mode=display">
 1 < N < 10^{18}\\
 1 < K , P < 2^{31}</script><p>本题就是求$ 1 + K + K^2 + …… + K^N $，对于这个问题可以将其拆分求出$<br> 1 + K + K^2 + …… + K^{ { \frac N2} - 1} $<br>再将其乘以$ K^{\frac N2} $即可得到$ K^{ \frac N2} + K^{ { \frac N2} + 1 } + …… + K^N $，之后将前面两式相加即可得到答案。递归解决即可，幂运算调用快速幂取模即可。<br>（关于快速幂取模可以去本人博客<a href="https://www.suvvm.work/tags/快速幂/">https://www.suvvm.work/tags/快速幂/</a>上去翻）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: power</span></span><br><span class="line"><span class="comment">* Description: 快速幂取模</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">*   @a  底数</span></span><br><span class="line"><span class="comment">*   @b  指数</span></span><br><span class="line"><span class="comment">*   @mod模数</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回幂运算取模后的结果</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">LL <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> mod)</span></span>&#123;    <span class="comment">//快速幂</span></span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;  <span class="comment">//从b的二进制末位开始判断</span></span><br><span class="line">            ans = ans * a % mod;  <span class="comment">//如果为1更新取模后的答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;    <span class="comment">//更新底数取模</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;    <span class="comment">//b右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: solve</span></span><br><span class="line"><span class="comment">* Description: 分治解决n个周期前分裂的的细胞单体个数</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">*   @k  分裂能力</span></span><br><span class="line"><span class="comment">*   @n  分裂周期次数</span></span><br><span class="line"><span class="comment">*   @p  模数</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回n个周期前分裂的的细胞单体个数取模后的结果</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)  <span class="comment">// 0次分裂只有一个初始病毒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>)   <span class="comment">// 奇数次分裂</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + power(k, n/<span class="number">2</span> + <span class="number">1</span>, p)) * solve(k, n/<span class="number">2</span>, p) % p;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 偶数次分裂</span></span><br><span class="line">        <span class="keyword">return</span> (power(k, n/<span class="number">2</span>, p) + (<span class="number">1</span> + power(k, n/<span class="number">2</span> +<span class="number">1</span>, p)) * solve(k, n/<span class="number">2</span> - <span class="number">1</span>, p)) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> k, n, p;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    n--; <span class="comment">// 以第0次分裂为起始</span></span><br><span class="line">    <span class="keyword">if</span>(!n)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 第n周期前，没有进行第n周期</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(k, --n, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/09/C-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/C-%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">C++大整数运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-09 21:07:58" itemprop="dateCreated datePublished" datetime="2019-11-09T21:07:58+08:00">2019-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>加法运算：以两个数中较大的数的长度为边界进行遍历，由最低位开始按位进行加法运算，将对应位相加并记录进位，在下一位进行相加运算时再加上进位即可。 </p>
<p> 减法运算：同样以两个数中较长的长度为边界进行遍历，按位进行减法运算，不够减则从前一位借位。最终不要忘记消去最高位的0  </p>
<p>倍增（数量级在int内）运算：选择一个数进行遍历，将其每位依次乘另一个数，将产生的结果的个位作为结果，除个位外其他位作为进位。 </p>
<p> 除法（大整数除以普通数）运算：从被除数最高位开始遍历，每一个位与上一位遗留的余数结合后进行除法运算。  比较：优先比较长度，长度相同则由高位向下比较。  </p>
<p>相乘：使用分治思想   假设现有大整数A与大整数B要做乘法运算，如果依照暴力过一切的思想去遍历相乘时间复杂度将变为O(n^2)所以这里使用分治思想。  将长度为n的大数a分为两部分  若n为偶数则可以将a分为长度为$\frac n2$的两段$a_0$与$a_1$  若n为奇数则a0的长度为$\frac {n+1}2$,$a_1$长度为$ \frac n2 $ $a = a_0 \times 10^{\frac n2} + a_1$  则$a \times b$同样可以分为 </p>
<script type="math/tex; mode=display">
a \times b = [a_0 \times 10^{\frac {n_1}2} + a_1] \times [b_0 \times 10^{\frac {n_2}2} + b_1]\\ =  a_0 \times b_0 \times 10^{\frac {n_1}2+\frac {n_2}2}+a_0 \times b_1 \times 10^{\frac {n_1}2} + a_1 \times b_0 \times 10^{\frac {n_2}2}+a_1 \times b_1</script><p>对于新出现的 $a_0 \times b_0 \ \ a_0 \times b_1 \ \ a_1 \times b_0 \ \ a_1\ \times b_1$用相同的方法递归解决即可以。</p>
<p>附上代码</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* @File: 大面值数据处理</span></span><br><span class="line"><span class="comment">* @Author: suvvm</span></span><br><span class="line"><span class="comment">* @blog: www.suvvm.work</span></span><br><span class="line"><span class="comment">* @github: https://github.com/suvvm</span></span><br><span class="line"><span class="comment">* @email: suvvm@foxmail.com</span></span><br><span class="line"><span class="comment">* @Version: 1.0.0</span></span><br><span class="line"><span class="comment">* @Date: 2019-11-07</span></span><br><span class="line"><span class="comment">* @Description: 2019第2学期算法设计与分析分治实验1第2项</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxz = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* ClassName:BigNum</span></span><br><span class="line"><span class="comment">* Description: 存储大数</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@num	大数具体值（为了方便运算采取低位在前的存储方式）</span></span><br><span class="line"><span class="comment">* 	@len	大数位数</span></span><br><span class="line"><span class="comment">* 	@BigNum	无参构造，将其初始化为0</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigNum</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num[maxn];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    BigNum()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName:change</span></span><br><span class="line"><span class="comment">* Description: 将C++ string转换为BigNum</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@temp	传入的字符串</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回转换后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">change</span><span class="params">(<span class="built_in">string</span> temp)</span></span>&#123;</span><br><span class="line">    BigNum a;</span><br><span class="line">    a.len = temp.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">        a.num[i] = temp[a.len - i - <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName:compare</span></span><br><span class="line"><span class="comment">* Description: 比较两个BigNum的大小</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	需要比较的参数1</span></span><br><span class="line"><span class="comment">*   @b  需要比较的参数2</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   参数1大于参数2返回(int)1</span></span><br><span class="line"><span class="comment">*   参数2大于参数1返回(int)-1</span></span><br><span class="line"><span class="comment">*   相等返回(int)0</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(BigNum a, BigNum b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.len &gt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.len &lt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.num[i] &gt; b.num[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.num[i] &lt; b.num[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName:add</span></span><br><span class="line"><span class="comment">* Description: 两个BigNum大数相加</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要进行加法运算的BigNum1</span></span><br><span class="line"><span class="comment">*   @b  要进行加法运算的BigNum2</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回相加后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">add</span><span class="params">(BigNum a, BigNum b)</span></span>&#123;</span><br><span class="line">    BigNum c;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)&#123;<span class="comment">//以较长的长度为界限</span></span><br><span class="line">        <span class="keyword">int</span> temp = a.num[i] + b.num[i] + carry;<span class="comment">//两个位置相加后加上进位</span></span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry != <span class="number">0</span>)</span><br><span class="line">        c.num[c.len++] = carry;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName:sub</span></span><br><span class="line"><span class="comment">* Description: 两个BigNum大数相减</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	被减数</span></span><br><span class="line"><span class="comment">*   @b  减数</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回相减后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">sub</span><span class="params">(BigNum a, BigNum b)</span></span>&#123;</span><br><span class="line">    BigNum c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++)&#123;<span class="comment">//较长为界</span></span><br><span class="line">        <span class="keyword">if</span>(a.num[i] &lt; b.num[i])&#123;<span class="comment">//如果不够减</span></span><br><span class="line">            a.num[i + <span class="number">1</span>]--;<span class="comment">//借位</span></span><br><span class="line">            a.num[i] += <span class="number">10</span>;<span class="comment">//加10</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.num[c.len++] = a.num[i] - b.num[i];<span class="comment">//相减结果为当前位结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;<span class="comment">//去除最高位的0</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: multi</span></span><br><span class="line"><span class="comment">* Description: 将BigNum扩大指定倍数（int）</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要扩大的BigNum</span></span><br><span class="line"><span class="comment">*   @b  扩大倍数</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回扩大后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">multi</span><span class="params">(BigNum a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    BigNum c;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)&#123;<span class="comment">//a每位依次乘b</span></span><br><span class="line">        <span class="keyword">int</span> temp = a.num[i] * b + carry;</span><br><span class="line">        c.num[c.len++] = temp % <span class="number">10</span>;<span class="comment">//temp个位作为该位结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;<span class="comment">//temp高位作为进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;<span class="comment">//乘法的进位可能不止一位</span></span><br><span class="line">        c.num[c.len++] = carry % <span class="number">10</span>;</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = mod;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: divide</span></span><br><span class="line"><span class="comment">* Description: 大数除int内数字</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	被除数</span></span><br><span class="line"><span class="comment">*   @b  除数</span></span><br><span class="line"><span class="comment">*   @r  余数</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回相除后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">divide</span><span class="params">(BigNum a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span>&#123;<span class="comment">//r为余数</span></span><br><span class="line">    BigNum c;</span><br><span class="line">    c.len = a.len;<span class="comment">//被除数和商的每一位是一一对应的，所以先令长度相等</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//从最高位开始</span></span><br><span class="line">        r = r * <span class="number">10</span> + a.num[i];<span class="comment">//每一位和上一位遗留的余数组合</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt; b)</span><br><span class="line">            c.num[i] = <span class="number">0</span>;<span class="comment">//若不够除该位为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//够除</span></span><br><span class="line">            c.num[i] = r / b;<span class="comment">//得到该位的商</span></span><br><span class="line">            r = r % b;<span class="comment">//新的余数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;<span class="comment">//去除最高位的0</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: rmZero</span></span><br><span class="line"><span class="comment">* Description: 在传入大数前方去除0</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要去除0的大数</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmZero</span><span class="params">(BigNum &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a.len - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; a.num[a.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        a.len--;<span class="comment">//去除最高位的0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: addAfterZero</span></span><br><span class="line"><span class="comment">* Description: 在传入大数后方添加0</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要添加0的大数</span></span><br><span class="line"><span class="comment">*   @l  要添加0的数量</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回添加0后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">addAfterZero</span><span class="params">(BigNum a, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[maxn];</span><br><span class="line">    BigNum res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num + l, a.num, <span class="keyword">sizeof</span>(a.num));</span><br><span class="line">    res.len = l + a.len;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: addBeforeZero</span></span><br><span class="line"><span class="comment">* Description: 在传入大数前方添加0</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要添加0的大数</span></span><br><span class="line"><span class="comment">*   @l  要添加0的数量</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回添加0后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">addBeforeZero</span><span class="params">(BigNum a, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[maxn];</span><br><span class="line">    BigNum res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num, a.num, <span class="keyword">sizeof</span>(a.num));</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num + a.len, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    res.len = l + a.len;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: subBigNum</span></span><br><span class="line"><span class="comment">* Description: 大数截取</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要被截取的大数</span></span><br><span class="line"><span class="comment">*   @bg 开始截取的位置</span></span><br><span class="line"><span class="comment">*   @l  截取的长度</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回截取后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">subBigNum</span><span class="params">(BigNum a, <span class="keyword">int</span> bg, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    BigNum res;</span><br><span class="line">    res.len = l;</span><br><span class="line">    <span class="keyword">int</span> tmp = l<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - bg; i &gt; a.len - bg - l; i--)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "i:" &lt;&lt; i &lt;&lt; " a.num[i]:" &lt;&lt; a.num[i] &lt;&lt; endl;</span></span><br><span class="line">        res.num[tmp--] = a.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* FunctionName: multi_2</span></span><br><span class="line"><span class="comment">* Description: 大数乘法（分治）</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	乘数1</span></span><br><span class="line"><span class="comment">*   @b  乘数2</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回相乘后的BigNum</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">multi_2</span><span class="params">(BigNum a, BigNum b)</span></span>&#123;</span><br><span class="line">    BigNum c;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;	<span class="comment">// 计算当前大数长度</span></span><br><span class="line">    <span class="keyword">if</span>(a.len &gt; <span class="number">2</span> || b.len &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        n = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &lt; a.len || n &lt; b.len)	<span class="comment">// n一直乘二直到n大于两数中较长者的长度</span></span><br><span class="line">            n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 在大数前方补零直至两者长度都为n</span></span><br><span class="line">        a = addBeforeZero(a, n - a.len);</span><br><span class="line">        b = addBeforeZero(b, n - b.len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为一则证明当前n依旧为2 将两数长度补至二</span></span><br><span class="line">    <span class="keyword">if</span>(a.len == <span class="number">1</span>)  a = addBeforeZero(a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(b.len == <span class="number">1</span>)  b = addBeforeZero(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;	<span class="comment">// 当前长度为2</span></span><br><span class="line">        <span class="keyword">int</span> inta = <span class="number">0</span>, intb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;	<span class="comment">// 用inta记录第一个数</span></span><br><span class="line">            inta += a.num[i];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                inta *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = b.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;	<span class="comment">// 用intb记录第二个数</span></span><br><span class="line">            intb += b.num[i];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                intb *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> inttmp = inta * intb;	<span class="comment">// 两数相乘</span></span><br><span class="line">        <span class="built_in">string</span> tmp;	<span class="comment">// 将整数转为字符串 当然如果环境支持c11以上也可以直接使用std::itos</span></span><br><span class="line">        <span class="built_in">stringstream</span> sst;</span><br><span class="line">        sst &lt;&lt; inttmp;</span><br><span class="line">        sst &gt;&gt; tmp;</span><br><span class="line">        c = change(tmp);	<span class="comment">// 将当前两数乘积转为大数c</span></span><br><span class="line">        <span class="keyword">return</span> c;	<span class="comment">// 返回大数c</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        BigNum a0, a1, b0, b1, c0, c1, c2;</span><br><span class="line">        a1 = subBigNum(a, <span class="number">1</span>, (n/<span class="number">2</span>));<span class="comment">// a1为大数a的后半部分（我上方大数类中为了方便运算逆序存储）</span></span><br><span class="line">        a0 = subBigNum(a, (n/<span class="number">2</span>+<span class="number">1</span>), a.len - (n/<span class="number">2</span>) );	<span class="comment">// a0为大数a的前半部分</span></span><br><span class="line">        <span class="comment">// b0 b1同理</span></span><br><span class="line">        b1 = subBigNum(b, <span class="number">1</span>, (n/<span class="number">2</span>));</span><br><span class="line">        b0 = subBigNum(b, (n/<span class="number">2</span>+<span class="number">1</span>), b.len - (n/<span class="number">2</span>));</span><br><span class="line">        c2 = multi_2(a1, b1);</span><br><span class="line">        c0 = multi_2(a0, b0);</span><br><span class="line">        c1 = sub(multi_2(add(a0,a1),add(b0,b1)),add(c2, c0));</span><br><span class="line">        c2 = addAfterZero(c2, n);</span><br><span class="line">        c1 = addAfterZero(c1, n / <span class="number">2</span>);</span><br><span class="line">        c = add(add(c2, c1), c0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    BigNum num1,num2,c,e;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    num1 = change(temp);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">    num2 = change(temp);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num1: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num1.len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num1.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"num2: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num2.len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num2.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"比较大小"</span>;</span><br><span class="line">    <span class="keyword">if</span>(compare(num1, num2) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(compare(num1, num2) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"乘积"</span>;</span><br><span class="line">    BigNum num3 = multi_2(num1, num2);</span><br><span class="line">    rmZero(num3);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num3.len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num3.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"加和"</span> ;</span><br><span class="line">    c = add(num1, num2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; c.num[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"相减"</span> ;</span><br><span class="line">    c = sub(num1, num2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; c.num[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入int值计算与int的乘积（默认使用num1）"</span>;</span><br><span class="line">    <span class="keyword">int</span> mul;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mul;</span><br><span class="line">    c = multi(num1, mul);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.num[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入int值计算与int的商与余数（默认使用num1）"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mul;</span><br><span class="line">    c = divide(num1, mul, r);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"商："</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c.num[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" 余数"</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/06/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98-DP-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/06/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98-DP-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">矩阵连乘问题(DP)原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-06 22:08:46" itemprop="dateCreated datePublished" datetime="2019-11-06T22:08:46+08:00">2019-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="矩阵连乘问题（DP）原理分析"><a href="#矩阵连乘问题（DP）原理分析" class="headerlink" title="矩阵连乘问题（DP）原理分析"></a>矩阵连乘问题（DP）原理分析</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定n个可乘的数字矩阵 $A<em>1, A_2,…, A_n $，矩阵 $A_i $ 的规模为 $p</em>{i-1}\times p_i $ 求给定矩阵连乘的最优计算次序，使得计算乘积 $A_1\times A_2 \times … \times A_n $ 所需执行的数乘次数最少.</p>
<h2 id="矩阵乘法规则"><a href="#矩阵乘法规则" class="headerlink" title="矩阵乘法规则"></a>矩阵乘法规则</h2><p>$C=A\times B$ ，如果A为p行r列的矩阵，B为r行q列的矩阵，则根据矩阵乘法规则，A与B相乘后得到的矩阵C将是p行q列的矩阵，对于结果矩阵C中任意元素 $C<em>{ij}: C</em>{ij}= \sum {r \atop k=1} a<em>{ik}b</em>{kj}$ 即：一个元素 $C_{ij}$ 需要做r次乘法，所以若想要获得C中所有元素则需要进行 $p \times q \times r$次乘法。</p>
<p>由于矩阵乘法满足乘法结合律，所以当n个数字矩阵连乘时可以任意更换计算次序，随着计算次序的改变，所需计算的总乘法次数也会跟着改变，具体情况看下图。</p>
<p><img src="/2019/11/06/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98-DP-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/计算次序1.png" alt="img"></p>
<p><img src="/2019/11/06/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98-DP-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/计算次序2.png" alt="img"></p>
<p>现在要做的便是设计一种算法，可以求得一种计算次序使得总乘法次数最小。</p>
<h2 id="解法分析"><a href="#解法分析" class="headerlink" title="解法分析"></a>解法分析</h2><p>假设 $A_1\times A_2 \times … \times A_n$ 的最优计算次序会在$A_k$时断开（只是打个比方，就像上方图计算 $A_1 \times A_2 \times A_3 \times A_4$ 时在 $A_1$ 处断开成为 $A_1与A_2 \times (A_3\times A_4)$ 一样）这时对最优计算次序的计算也会断开成为两个子问题 </p>
<script type="math/tex; mode=display">
\left\{ \begin{aligned} 子问题1 & = & 求A_1\times A_2 \times ... \times A_k 的最优计算次序\\ 子问题2 & = & 求A_{k+1}\times A_{k+2} \times ... \times A_n 的最优计算次序\end{aligned} \right.</script><p>因为原问题是两子问题相乘，所以原问题的答案便是俩个子问题的答案加上最后一次两子问题产生的矩阵相乘所需要的乘法次数。根据上方列出的矩阵乘法计算规则 </p>
<script type="math/tex; mode=display">
最后一次需要乘法次数= \\ 子问题1矩阵的行数 \\ \times 子问题2矩阵的列数 \\ \times 计算结果矩阵中一个元素所需的乘法次数</script><p>而</p>
<script type="math/tex; mode=display">
计算结果矩阵中一个元素所需的乘法次数=子问题1矩阵的列数=子问题2矩阵的行数</script><p>这里我们把 $m[i][j]$ 记为最优计算次序下计算 $A<em>i \times A</em>{i+1} \times … \times A_j$ 所需的乘法次数（最少乘法次数）</p>
<p>根据上述假设，我们依旧假设 $A<em>i \times A</em>{i+1} \times … \times A_j$ 的最优计算次序会在 $A_k$ 时断开，这时的两个子问题便是 </p>
<script type="math/tex; mode=display">\left\{ \begin{aligned} 子问题1 & = & 求A_i\times A_{i+1} \times ... \times A_k 的最优计算次序m[i][k]\\ 子问题2 & = & 求A_{k+1}\times A_{k+2} \times ... \times A_j 的最优计算次序m[k+1][j]\end{aligned} \right.</script><p>根据上次假设总结出的公式我们便可以得到 </p>
<script type="math/tex; mode=display">m[i][j]=m[i][k]+m[k+1][j]+最后一次需要乘法次数(子问题1矩阵\times 子问题2矩阵)</script><p>由于在矩阵连乘中，前一个矩阵的列数与后一个矩阵的行数相同，所以这里我们把所有矩阵的行与列属性记录在一个一维数组p中 $P<em>0$ 表示第一个矩阵的行数 $p_1$ 表示第一个矩阵的列数与第二个矩阵的行数，以此类推 $p</em>{n-1}$ 代表第n-1个矩阵的列数与第n个矩阵的行​数。</p>
<script type="math/tex; mode=display">
最后一次所需乘法= \\ 子问题1矩阵的行数（等于A_i的行数） \\ \times 子问题2矩阵的列数（等于A_j的列数） \\ \times 计算结果矩阵中一个元素所需的乘法次数（等于子问题2矩阵的行数等于A_k的列数）\\=p_{i-1} \times p_j \times p_k</script><p>这样便得到了动态规划算法最核心的动态转移方程</p>
<script type="math/tex; mode=display">
m[i][j]=\left\{ \begin{aligned} 0(i = j )\\ m[i][k]+m[k+1][j]+p_{i-1} \times p_j \times p_k(i < j)\end{aligned} \right.</script><p>有了它便可以去写代码了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Dijkstra原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-05 22:01:55" itemprop="dateCreated datePublished" datetime="2019-11-05T22:01:55+08:00">2019-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Dijkstra（迪杰斯特拉）"><a href="#Dijkstra（迪杰斯特拉）" class="headerlink" title="Dijkstra（迪杰斯特拉）"></a>Dijkstra（迪杰斯特拉）</h2><p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-1.svg" alt="img"></p>
<p>假设给定的源点是A，现在要求的便是源点A到其他所有点的最短路长度</p>
<p>我们初始将所有点看作不连通</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-2.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h3><p>我们所规定的源点为A，A点到其本身的距离为0。这样我们就找到了第一个距离源点A最近的点，就是A本身，将其标记为红色。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-3.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>0</code></strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h3><p>之后恢复以A为起点的所有边，更新所有可达点的最短路长度。如下图，可以发现以A为起点的两条边分别通向B与D，根据边权我们可以把B与D到A的最短路长度进行更新，可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A点到B点的最短路长度由无穷大优化为了2</span><br><span class="line">A点到D点的最短路长度由无穷大优化为了1</span><br></pre></td></tr></table></figure>
<p>这时观察所有的点，我们可以发现当前距离A点最近且还没有被标为红色的点便是我们刚刚更新的D。我们便可以确定，A点到D点的最短路径1，将D标记为红色。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-4.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>2</td>
<td>∞</td>
<td><strong><code>1</code></strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第三次优化"><a href="#第三次优化" class="headerlink" title="第三次优化"></a>第三次优化</h3><p>重复之前操作，恢复以D为起点的所有边，以D为跳板更新所有未被标红的可达点的最短路长度，更新后可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A点到C点的最短路长度由无穷大被优化为了3</span><br><span class="line">A点到E点的最短路长度由无穷大被优化为了3</span><br><span class="line">A点到F点的最短路长度由无穷大被优化为了9</span><br><span class="line">A点到G点的最短路长度由无穷大被优化为了5</span><br></pre></td></tr></table></figure>
<p>这时观察所有的点，我们可以发现当前距离A点最近且还没有被标为红色的点是最短路长度为2的点B。我们便可以确定，A点到B点的最短路径2，将B标记为红色。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-5.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong><code>2</code></strong></td>
<td>3</td>
<td><strong>1</strong></td>
<td>3</td>
<td>9</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第四次优化"><a href="#第四次优化" class="headerlink" title="第四次优化"></a>第四次优化</h3><p>重复之前操作，恢复以B为起点的所有边，以B为跳板更新所有未被标红的可达点的最短路长度，更新后可以发现没有点可以被更新。</p>
<p>这时观察所有的点，我们可以发现当前距离A点最近且还没有被标为红色的点有两个，分别为最短路长度为3的点C与最短路长度为3的点E。我们可以选任意一个将其标为红色（以已经固定长度的点去优化另一个点，被优化的点的长度一定不会小于优化它的点，所以在这里另一个点一定会在下次优化中被标红）这里我选择点C。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-6.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong><code>3</code></strong></td>
<td><strong>1</strong></td>
<td>3</td>
<td>9</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第五次优化"><a href="#第五次优化" class="headerlink" title="第五次优化"></a>第五次优化</h3><p>重复之前操作，恢复以C为起点的所有边，以C为跳板更新所有未被标红的可达点的最短路长度，更新后可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A点到F点的最短路长度由无穷大被优化为了8</span><br></pre></td></tr></table></figure>
<p>这时观察所有的点，我们可以发现当前距离A点最近且还没有被标为红色的是上一次没有选择的最短路长度为3的点E。我们便可以确定，A点到E点的最短路径3，将E标记为红色。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-7.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
<td><strong><code>3</code></strong></td>
<td>8</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="第六次优化"><a href="#第六次优化" class="headerlink" title="第六次优化"></a>第六次优化</h3><p>依旧是重复之前操作，恢复以E为起点的所有边，以E为跳板更新所有未被标红的可达点的最短路长度，更新后可以发现没有点可以被更新。</p>
<p>依旧是观察所有的点，我们可以发现当前距离A点最近且还没有被标为红色的是最短路长度为5的点G。我们便可以确定，A点到G点的最短路径5，将G标记为红色。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-8.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
<td>8</td>
<td><strong><code>5</code></strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="第七次优化"><a href="#第七次优化" class="headerlink" title="第七次优化"></a>第七次优化</h3><p>重复之前操作，恢复以G为起点的所有边，以G为跳板更新所有未被标红的可达点的最短路长度，更新后可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A点到F点的最短路长度由无穷大被优化为了6</span><br></pre></td></tr></table></figure>
<p>依旧是观察所有的点，我们可以发现当前距离A点最近且还没有被标为红色的是最短路长度为5的最后一个点F。我们便可以确定，A点到F点的最短路径6，将F标记为红色，至此所有的点都优化完毕。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra1-9.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
<td><strong><code>6</code></strong></td>
<td><strong>5</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="最短路长度表汇总"><a href="#最短路长度表汇总" class="headerlink" title="最短路长度表汇总"></a>最短路长度表汇总</h3><div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong><code>0</code></strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2</td>
<td>∞</td>
<td><strong><code>1</code></strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong><code>2</code></strong></td>
<td>3</td>
<td><strong>1</strong></td>
<td>3</td>
<td>9</td>
<td>5</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong><code>3</code></strong></td>
<td><strong>1</strong></td>
<td>3</td>
<td>9</td>
<td>5</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
<td><strong><code>3</code></strong></td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
<td>8</td>
<td><strong><code>5</code></strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td><strong>2</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
<td><strong><code>6</code></strong></td>
<td><strong>5</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="不适用情况"><a href="#不适用情况" class="headerlink" title="不适用情况"></a>不适用情况</h3><p>只要图中有任何负权边，dijkstra边不能正确得到预期答案，即使没有负环也不行。</p>
<p>至于为什么，可以从如下图的例子中看出</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra2-1.svg" alt="img"></p>
<p>按照之前的方法进行分析</p>
<p>我们初始将所有点看作不连通</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra2-2.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第一次优化-1"><a href="#第一次优化-1" class="headerlink" title="第一次优化"></a>第一次优化</h4><p>A点到其本身的距离为0。找到了第一个距离源点A最近的点，为A本身，将其标记为红色。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra2-3.svg" alt="img"></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>0</code></strong></td>
<td>∞</td>
<td>∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第二次优化-1"><a href="#第二次优化-1" class="headerlink" title="第二次优化"></a>第二次优化</h4><p>恢复以A为起点的所有边，更新所有可达点的最短路长度。</p>
<p>如下图</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra2-4.svg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A点到B点的最短路长度由无穷大优化为了3</span><br><span class="line">A点到C点的最短路长度由无穷大优化为了2</span><br></pre></td></tr></table></figure>
<p>当前距离A点最近且还没有被标为红色的点是C，A点到C点的最短路径2，将C标记为红色。</p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>3</td>
<td><strong><code>2</code></strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="第三次优化-1"><a href="#第三次优化-1" class="headerlink" title="第三次优化"></a>第三次优化</h4><p>恢复以C为起点的所有边，更新所有可达点的最短路长度。</p>
<p>如下图</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra2-5.svg" alt="img"></p>
<p>没有点可以被更新</p>
<p>当前距离A点最近且还没有被标为红色的点是B，A点到B点的最短路径3，将B标记为红色。</p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong><code>3</code></strong></td>
<td><strong>2</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="第四次优化-1"><a href="#第四次优化-1" class="headerlink" title="第四次优化"></a>第四次优化</h4><p>恢复以B为起点的所有边，更新所有可达点的最短路长度。</p>
<p>如下图</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra2-6.svg" alt="img"></p>
<p><strong>由于C已经被固定，所以没有点可以被更新！！</strong></p>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>3</strong></td>
<td><strong>2</strong></td>
</tr>
</tbody>
</table>
</div>
<p>所以上表便是dijkstra得出的最终结果，而并不是我们认为的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h4><p>以上方正确示例为例，为了方便处理，我们将A~G这七个字母在算法中以0~6七个点所代替。</p>
<p>我们可以得出下图的输入数据</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra3-1.svg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">7 12</span><br><span class="line">0 1 2</span><br><span class="line">0 3 1</span><br><span class="line">1 3 3</span><br><span class="line">1 4 10</span><br><span class="line">2 0 4</span><br><span class="line">2 5 5</span><br><span class="line">3 2 2</span><br><span class="line">3 4 2</span><br><span class="line">3 5 8</span><br><span class="line">3 6 4</span><br><span class="line">4 6 6</span><br><span class="line">6 5 1</span><br></pre></td></tr></table></figure>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e6</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">    Node(<span class="keyword">int</span> tv, <span class="keyword">int</span> tdis)&#123;</span><br><span class="line">        v = tv, dis = tdis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//n为顶点数量</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV]; <span class="comment">//存放起点到各点的最短路径长度</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]; <span class="comment">//标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d, d + MAXV, inf); <span class="comment">//初始化起点到所有点的最短路长度为无穷大</span></span><br><span class="line">    d[s] = <span class="number">0</span>;   <span class="comment">//起点至本身的距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, mind = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123; <span class="comment">//寻找距离顶点最近的点</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; d[j] &lt; mind)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                mind = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="comment">//若找不到u证明剩下的点与顶点不连通</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : Adj[u])&#123;   <span class="comment">//遍历所有与u连通的点</span></span><br><span class="line">            <span class="keyword">int</span> v = j.v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; d[u] + j.dis &lt; d[v])&#123; <span class="comment">//以u为中转优化起点到与u连通的点的最短距离</span></span><br><span class="line">                d[v] = d[u] + j.dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> s;  <span class="comment">//为起点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> r;<span class="comment">//路径数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入路径数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入路径（格式:端点1 端点2 权值）:"</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, dis;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; dis;</span><br><span class="line">        Adj[u].push_back(Node(v, dis));</span><br><span class="line">        <span class="comment">//Adj[v].push_back(Node(u, dis));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入起点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    dijkstra(s);</span><br><span class="line">    <span class="keyword">int</span> e;  <span class="comment">//终点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入终点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路长度"</span> &lt;&lt; d[e] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span> &lt;&lt; d[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆优化dijkstra"><a href="#堆优化dijkstra" class="headerlink" title="堆优化dijkstra"></a>堆优化dijkstra</h4><p>分析一下上方dijkstra的时间复杂度，设顶点个数n，外层循环为 $ O(n) $，内层循环有寻找距离起点最近的点需要 $ O(n) $，每次枚举被优化点v需要$O(Adj[u].size) $总共需要 $ O(\sum {n-1 \atop u=0} Adj[u].size)=E $，总时间复杂度 $ O(N\times N + E)=O(N^2+E) $</p>
<p>如何去优化它呢？压榨外层循环，根据dijkstra的原理显然是不太现实的，但是根据前的设计dijkstra在每次进行优化时都需要寻找距离起点最近的点，这需要每次都遍历所有的点，这里便可以使用堆优化来降低时间复杂度，可以直接使用STL里的优先队列priority_queue，使距离起点进的点优先出队，这样就可以将内层循环中寻找距离起点最近的点消耗的 $ O(N) $优化为维护优先队列的 $ O(logN) $，这样总时间复杂度就降为了 $ O(NlogN+E) $</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;tNode) <span class="keyword">const</span>&#123;  <span class="comment">//优先队列默认优先级高的先出队 这里就要通过重载运算符 &lt; 使距离越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> dis &gt; tNode.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; Adj[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d, d + MAXN, INF); <span class="comment">//初始化起点至所有点距离为无穷大</span></span><br><span class="line">    priority_queue&lt;node&gt; Q;</span><br><span class="line">    d[s] = <span class="number">0</span>;   <span class="comment">//起点至其本身距离为0</span></span><br><span class="line">    Q.push(node&#123;s, <span class="number">0</span>&#125;); <span class="comment">//这里node中v代表的是当前顶点，dis代表其与起点的距离</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        node f = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = f.v;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="comment">//如果u已经标记则继续出队</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;  <span class="comment">//将u标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[u])&#123;   <span class="comment">//遍历所有与u相邻的顶点</span></span><br><span class="line">            <span class="keyword">int</span> v = i.v;</span><br><span class="line">            <span class="keyword">int</span> dis = i.dis;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; d[u] + dis &lt; d[v])&#123;   <span class="comment">//如果可以以u为中转优化起点到对应点的距离</span></span><br><span class="line">                d[v] = d[u] + dis;      <span class="comment">//执行松弛操作</span></span><br><span class="line">                Q.push(node&#123;v, d[v]&#125;);   <span class="comment">//将松弛后的点与距离入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边 (端点1 端点2 权值):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, dis;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; dis;</span><br><span class="line">        Adj[u].push_back(node&#123;v, dis&#125;);</span><br><span class="line">        <span class="comment">//Adj[v].push_back(node&#123;u, dis&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入起点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入终点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    dijkstra(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路长度:"</span> &lt;&lt; d[e] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" : "</span> &lt;&lt; d[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dijkstra记录最短路路径"><a href="#Dijkstra记录最短路路径" class="headerlink" title="Dijkstra记录最短路路径"></a>Dijkstra记录最短路路径</h4><p>记录最短路径的方法非常简单，这里只需要开一个长度为n的数组pre，在每次进行优化的时候，记录每个被优化点的前驱点，最后由终点开始寻找前驱直到找到起点即可获得最短路径。</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tNode) <span class="keyword">const</span>&#123;  <span class="comment">// 优先队列默认优先级高的先出队 这里就要通过重载运算符 &lt; 使距离越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> dis &gt; tNode.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN], pre[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d, d +MAXN, INF);  <span class="comment">// 初始化起点至所有点距离为无穷大</span></span><br><span class="line">    d[s] = <span class="number">0</span>;    <span class="comment">// 起点至其本身距离为0</span></span><br><span class="line">    priority_queue&lt;Node&gt; Q; <span class="comment">// 这里node中v代表的是当前顶点，dis代表其与起点的距离</span></span><br><span class="line">    Q.push(Node&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        Node f = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = f.v;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])  <span class="comment">// 如果u已经标记则继续出队</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;  <span class="comment">// 将u标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[u])&#123;   <span class="comment">// 遍历所有与u相邻的顶点</span></span><br><span class="line">            <span class="keyword">if</span>(d[i.v] &gt; d[u] + i.dis)&#123;  <span class="comment">// 如果可以以u为中转优化起点到对应点的距离</span></span><br><span class="line">                d[i.v] = d[u] + i.dis;  <span class="comment">// 执行松弛操作</span></span><br><span class="line">                pre[i.v] = u;   <span class="comment">// 记录本次优化的前驱点</span></span><br><span class="line">                Q.push(Node&#123;i.v, d[i.v]&#125;);  <span class="comment">// 将松弛后的点与距离入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, dis;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边（顶点1 顶点2 权值）:"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt;  u &gt;&gt; v &gt;&gt; dis;</span><br><span class="line">        Adj[u].push_back(Node&#123;v, dis&#125;);</span><br><span class="line">        Adj[v].push_back(Node&#123;u,dis&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s, e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入起点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入终点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    dijkstra(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路长度:"</span> &lt;&lt; d[e] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = e;</span><br><span class="line">    <span class="keyword">while</span>(tmp != s)&#123;    <span class="comment">// 由重点开始寻找前驱便可以获得最短路径</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp &lt;&lt; <span class="string">" &lt;- "</span>;</span><br><span class="line">        tmp = pre[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dijkstra-DFS"><a href="#Dijkstra-DFS" class="headerlink" title="Dijkstra+DFS"></a>Dijkstra+DFS</h4><p>在考查dijkstra算法时又是可能会出现最短路不只存在一条的情况，这是通常就会给你一个其他的判断条件，比如要求找出点权和最大的最短路。</p>
<p><img src="/2019/11/05/Dijkstra%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/dijkstra3-2.svg" alt="img"></p>
<p>观察上图，以红色为起点，蓝色为终点，求一条途经点的点权和最高的最短路。</p>
<p>先不考虑点权，先来看对多条最短路的记录，之前在只记录一条最短路时采取了pre前驱数组的方式，单如果有多条最短路，便要使用其他方式。使用前驱数组时，每次只有在某个点被优化时才记录其前驱结点，对到起点距离相等的情况并没有进行处理，也就是说当存在多条最短路径时，即使某个点在被优化时产生了到起点距离相等的情况也要对其进行记录，每个点的前驱就可能不止一个。</p>
<p>这里便可以将int型数组pre更换为容器型（vector）数组，pre[i]中记录的是i点所有的前驱结点。</p>
<p>这样便成功记录了所有的最短路径。若想从这些最短路径中计算出一条点权和最大的来，就可以用dfs去搜索每一条最短路并记录点权和，最终选出点权和最大的最短路。</p>
<p>比如pat <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">PAT (Advanced Level) Practice  <strong>1003</strong> <strong>Emergency</strong> </a>就是一道典型的这种类型的题目。</p>
<p>送上代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">500000</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tNode) <span class="keyword">const</span>    <span class="comment">// 优先队列默认优先级高的先出队 这里就要通过重载运算符 &lt; 使距离越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> dis &gt; tNode.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, s, e;</span><br><span class="line"><span class="keyword">int</span> val[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXN];  <span class="comment">// 存储每个点的所有前驱点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d, d + MAXN, INF); <span class="comment">// 初始化起点至所有点距离为无穷大</span></span><br><span class="line">    d[s] = <span class="number">0</span>;   <span class="comment">// 起点至其本身距离为0</span></span><br><span class="line">    priority_queue&lt;Node&gt; Q;  <span class="comment">// 这里node中v代表的是当前顶点，dis代表其与起点的距离</span></span><br><span class="line">    Q.push(Node&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        Node f = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = f.v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[u])&#123;    <span class="comment">// 如果未经标记</span></span><br><span class="line">            vis[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[u])&#123;   <span class="comment">// 遍历所有与u相邻的顶点</span></span><br><span class="line">                <span class="keyword">if</span>(d[i.v] &gt; d[u] + i.dis)&#123;  <span class="comment">// 如果可以以u为中转优化起点到对应点的距离</span></span><br><span class="line">                    d[i.v] = d[u] + i.dis;  <span class="comment">// 执行松弛操作</span></span><br><span class="line">                    Q.push(Node&#123;i.v, d[i.v]&#125;);</span><br><span class="line">                    pre[i.v].clear();   <span class="comment">// 清除之前记录的前驱</span></span><br><span class="line">                    pre[i.v].push_back(u);  <span class="comment">// u记录为v的前驱</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[i.v] == d[u] + i.dis)&#123;</span><br><span class="line">                    pre[i.v].push_back(u);  <span class="comment">// u添加为v的前驱</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; road;   <span class="comment">// 记录最终点权和最大的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; troad;  <span class="comment">// 记录遍历中的每一条最短路</span></span><br><span class="line"><span class="keyword">int</span> minRoadCnt;</span><br><span class="line"><span class="keyword">int</span> saveCnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ed == s)&#123;</span><br><span class="line">        minRoadCnt++;</span><br><span class="line">        <span class="keyword">int</span> tempSaveCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : troad)&#123;</span><br><span class="line">            tempSaveCnt += val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(saveCnt &lt; tempSaveCnt)&#123;</span><br><span class="line">            road = troad;</span><br><span class="line">            saveCnt = tempSaveCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : pre[ed])&#123;</span><br><span class="line">            troad.push_back(i);</span><br><span class="line">            dfs(i);</span><br><span class="line">            troad.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, dis;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; dis;</span><br><span class="line">        Adj[u].push_back(Node&#123;v, dis&#125;);</span><br><span class="line">        Adj[v].push_back(Node&#123;u, dis&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(s);</span><br><span class="line">    troad.push_back(e);</span><br><span class="line">    dfs(e);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minRoadCnt &lt;&lt; <span class="string">" "</span> &lt;&lt; saveCnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 打印路径</span></span><br><span class="line">    <span class="comment">/*for(int i = road.size() - 1; i &gt;= 0; i--)&#123;</span></span><br><span class="line"><span class="comment">        if(i == road.size() - 1)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; road[i];</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; " " &lt;&lt; road[i];</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/02/PTA-Advanced-Level-1029-Median/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/02/PTA-Advanced-Level-1029-Median/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1029 Median</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-02 00:11:27" itemprop="dateCreated datePublished" datetime="2019-11-02T00:11:27+08:00">2019-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.</p>
<p>Given two increasing sequences of integers, you are asked to find their median.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (≤2×105) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of <strong>long int</strong>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the median of the two given sequences in a line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 11 12 13 14</span><br><span class="line">5 9 10 15 16 17</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题没有任何难度，为何会分到25分，这谁也不知道，题意就是给予两行两个long int序列，每个序列第一位为序列长度，求两个序列合并后的中位数。</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; seq;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;val);</span><br><span class="line">        seq.push_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;val);</span><br><span class="line">        seq.push_back(val);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(seq.begin(), seq.end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, seq[(seq.size() <span class="number">-1</span>) / <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/08/11/HBuilderX%E4%BD%BF%E7%94%A8Vant%E7%BB%84%E4%BB%B6%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/11/HBuilderX%E4%BD%BF%E7%94%A8Vant%E7%BB%84%E4%BB%B6%E5%BA%93/" class="post-title-link" itemprop="url">HBuilderX使用Vant组件库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-11 22:03:46" itemprop="dateCreated datePublished" datetime="2019-08-11T22:03:46+08:00">2019-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">简单教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>​    HBuilderX是一款由国人开发的开发工具，其官网称其为轻如编辑器、强如IDE的合体版本。但是官方的社区中关于Vant组件的安装大多都是针对微信小程序开发安装Vant Weapp，鄙人尝试了各种方法，经历各种错误后终于成功安装vant组件库，在这里分享一下使用HBuilderX进行vue.js开发时安装Vant组件库的经验，使用的版本为2019.08.10更新的2.2.0版本。</p>
<p>​    <strong>本篇所有操作建立在操作系统为windows且已经成功安装配置node.js的基础上。</strong></p>
<p>一、建立uni-app新项目</p>
<p>　　<img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214026033-1365235595.png" alt="img"></p>
<p>二、在终端打开项目目录</p>
<p>　　可以直接在HBuilderX中直接右击项目名称选择‘使用命令行窗口打开目录’，之后会提示插件【内置终端】未安装，选择确定来安装内置终端插件,之后便可以通过内置终端打开对应项目目录，当然也可以直接在windows终端中打开对应目录</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214118333-329131275.png" alt="img"><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214153594-1456728818.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214236996-650998932.png" alt="img"><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214253426-1237473327.png" alt="img"></p>
<p>　　之后我将使用内置终端进行操作.</p>
<p>三、初始化项目创建package.json</p>
<p>在终端中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>　　之后会让你填写一些如项目名称、版本号之类的项目介绍，如果不知道或者不想填就一路回车。　　</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214527678-541846092.png" alt="img"></p>
<p>四、安装Vant组件库</p>
<p>打开有赞vant的官方文档，快速上手中给出了通过npm安装vant的指令，在终端执行它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vant -S</span><br></pre></td></tr></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214624228-1496776260.png" alt="img"></p>
<p>不用管这几个警告</p>
<p>​    这时按照官方给的引入方式引入组件，我这里图方便直接引入所有组件，在main.js中添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vant <span class="keyword">from</span> <span class="string">'vant'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'vant/lib/index.css'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vant);</span><br></pre></td></tr></table></figure>
<p>　　这时我们在pages下index.vue中尝试使用vant组件，这里我用vant的自定义输入框做演示，在index.vue添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;van-cell-group&gt;</span><br><span class="line">  &lt;van-field</span><br><span class="line">    value&#x3D;&quot;&#123;&#123; username &#125;&#125;&quot;</span><br><span class="line">    required</span><br><span class="line">    clearable</span><br><span class="line">    label&#x3D;&quot;用户名&quot;</span><br><span class="line">    icon&#x3D;&quot;question-o&quot;</span><br><span class="line">    placeholder&#x3D;&quot;请输入用户名&quot;</span><br><span class="line">    bind:click-icon&#x3D;&quot;onClickIcon&quot;</span><br><span class="line">  &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;van-field</span><br><span class="line">    value&#x3D;&quot;&#123;&#123; password &#125;&#125;&quot;</span><br><span class="line">    type&#x3D;&quot;password&quot;</span><br><span class="line">    label&#x3D;&quot;密码&quot;</span><br><span class="line">    placeholder&#x3D;&quot;请输入密码&quot;</span><br><span class="line">    required</span><br><span class="line">    border&#x3D;&quot;&#123;&#123; false &#125;&#125;&quot;</span><br><span class="line">  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;van-cell-group&gt;</span><br></pre></td></tr></table></figure>
<p>　　编译并运行，可以使用其自带的内置浏览器插件，可在工具——插件安装中配置安装，如果安装失败就给管理员权限，之后点击预览就会开始编译项目。</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811214913216-2006673047.png" alt="img"></p>
<p>　　不出意料会出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">21:11:07.242 Module build failed (from .&#x2F;node_modules&#x2F;postcss-loader&#x2F;src&#x2F;index.js):</span><br><span class="line"></span><br><span class="line">21:11:07.242 SyntaxError</span><br><span class="line"></span><br><span class="line">21:11:07.247 (1:5894) Unclosed bracket</span><br><span class="line"></span><br><span class="line">21:11:07.248 &gt; 1 | @-webkit-keyframes van-slide-up-enter&#123;0%&#123;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)&#125;&#125;@keyframes van-slide-up-…………………省略巨量……………………… (left,#ff6034,#ee0a24);background:linear-gradient(to right,#ff6034,#ee0a24)&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是HBuilderX的bug已经过了很多个版本都没有修复，希望官方早日解决。出现这个是因为在main.js中引入vant的样式import ‘vant/lib/index.css’时出现了错误。</p>
<p>五、建立一个html的模板文件</p>
<p>　　删除main.js中错误代码 import ‘vant/lib/index.css’，以下方代码作为模板建立model.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vant@2.0/lib/index.css"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.documentElement.style.fontSize = <span class="built_in">document</span>.documentElement.clientWidth / <span class="number">20</span> + <span class="string">'px'</span></span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;static/index.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Please enable JavaScript to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　在manifest.json的h5配置中将其作为index.html模板导入</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201908/1447131-20190811215432221-2007786769.png" alt="img"></p>
<p>　　之后遍可以发现错误没了，在浏览器中查看会发现<strong>依然没有样式</strong>。</p>
<p>六、在对应页面引入vant样式</p>
<p>　　将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &#39;vant&#x2F;lib&#x2F;index.css&#39;;</span><br></pre></td></tr></table></figure>
<p>　　添加至使用vant组件的页面 style块中，这时编译并从浏览器中查看，vant组件样式已经出现（若样式依旧不准确请检查网络连接）。</p>
<p>七、若还是不行，就抛弃HbuilderX，安装使用Vue脚手架Vue Cli 3</p>
<p> dCloud开发者已经知晓此bug很长时间，经过很多个版本后一直没有修复的迹象，所以还是用Vue脚手架吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>
<p>若HbuilderX修复了bug欢迎提醒我修改文章。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SUVVM"
      src="/images/ortrait.jpg">
  <p class="site-author-name" itemprop="name">SUVVM</p>
  <div class="site-description" itemprop="description">SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">83</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suvvm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suvvm" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/suvvm@foxmail.com" title="E-Mail → suvvm@foxmail.com"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SUVVM</span>
	<a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">鲁ICP备19040043号-2</a>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
