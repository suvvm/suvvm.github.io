<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/ortrait.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.suvvm.work","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:type" content="website">
<meta property="og:title" content="SUVVM">
<meta property="og:url" content="https://www.suvvm.work/page/7/index.html">
<meta property="og:site_name" content="SUVVM">
<meta property="og:description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SUVVM">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.suvvm.work/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SUVVM</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e5190116d64be66cac29daef18c94ac0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SUVVM</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">呜嗷SUVVM</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2020/03/16/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/16/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Java单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-16 17:45:18" itemprop="dateCreated datePublished" datetime="2020-03-16T17:45:18+08:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java单例模式"><a href="#Java单例模式" class="headerlink" title="Java单例模式"></a>Java单例模式</h1><p>单例模式属于创建型模式，每个类只有一个实例，并为其他所有对象提供访问唯一该实例的的方式。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>只需要一个的对象，如硬件设备驱动对象（打印机or显卡驱动对象）、日志对象、创建需要消耗大量资源的对象（数据库连接）、代表耶稣的上帝对象等。</p>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>实现单例模式需要私有的构造函数，静态的实例对象与静态的访问方法。</p>
<h3 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h3><p>在静态域中初始化单例的实例对象，所以单例的实例对象会在JVM加载该类时被创建，线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在静态域中初始化单例的实例对象 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="comment">// private 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 访问该实例的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式（非线程安全）"><a href="#懒汉式（非线程安全）" class="headerlink" title="懒汉式（非线程安全）"></a>懒汉式（非线程安全）</h3><p>懒加载，在初次调用单例实例时初始化单例实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在静态域中声明单例的实例对象 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="comment">// private 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 加锁的访问该实例的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 仅在初次访问时初始化单例实例</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h3><p>懒加载，在初次调用单例实例时初始化单例实例，synchronized加锁保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在静态域中声明单例的实例对象 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="comment">// private 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 加锁的访问该实例的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 仅在初次访问时初始化单例实例</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式（双重校验锁DCL-线程安全）"><a href="#懒汉式（双重校验锁DCL-线程安全）" class="headerlink" title="懒汉式（双重校验锁DCL 线程安全）"></a>懒汉式（双重校验锁DCL 线程安全）</h3><p>懒加载，在调用单例实例时先检验单例实例是否创建，若未创建则初始化单例实例。<br>使用volatile关键词防止寄存器中读取的数据与内存中不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在静态域中声明单例的实例对象 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">	<span class="comment">// private 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 加锁的访问该实例的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 检验单例实例是否创建</span></span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">				<span class="comment">// 进入同步代码块后再次检验</span></span><br><span class="line">				<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式（IoDH延迟加载-线程安全）"><a href="#懒汉式（IoDH延迟加载-线程安全）" class="headerlink" title="懒汉式（IoDH延迟加载 线程安全）"></a>懒汉式（IoDH延迟加载 线程安全）</h3><p>利用内部编译后加载与主类无关的特性使用静态内部类延迟加载，在调用单例实例时显式加载静态内部类实现创建单例实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 在静态内部类中声明单例的实例对象 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// private 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 加锁的访问该实例的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举（线程安全）"><a href="#枚举（线程安全）" class="headerlink" title="枚举（线程安全）"></a>枚举（线程安全）</h3><p>通过枚举关键字enum定义Enum子类,利用枚举的特性保证线程安全与实例单一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">	INSTANCE</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Head First 设计模式</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2020/03/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Java多线程的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-15 19:39:32" itemprop="dateCreated datePublished" datetime="2020-03-15T19:39:32+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA线程"><a href="#JAVA线程" class="headerlink" title="JAVA线程"></a>JAVA线程</h1><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>众所周知，对于实现多了任务的操作系统，进程是资源的拥有者，也是处理机调度的基本单位。</p>
<p>线程继承了进程的一个基本属性，线程是处理机的调度单位。</p>
<p>所以线程是进程中的一个运行实体，是CPU的调度单位，有时将线程称为轻量级进程。</p>
<h2 id="Java-多线程的实现"><a href="#Java-多线程的实现" class="headerlink" title="Java 多线程的实现"></a>Java 多线程的实现</h2><ul>
<li>通过继承Thread类创建线程</li>
<li>通过实现Runnable接口创建线程</li>
</ul>
<h3 id="通过继承Thread类创建线程"><a href="#通过继承Thread类创建线程" class="headerlink" title="通过继承Thread类创建线程"></a>通过继承Thread类创建线程</h3><p>可以通过构造一个Thread类的子类，覆盖其run方法并调用start方法运行该线程，但此方法并不推荐，应该将要并行运行的任务与运行机制解耦合。</p>
<p>启动线程需要调用start方法而不是run方法，直接调用run方法会在当前线程执行run方法，start方法将创建一个执行run方法的新线程。</p>
<p>下方为通过继承Thread类创建线程实现两线程交替打印10次a与b</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.suvvm.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ExtendsTreadDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: SUVVM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/3/13 18:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object flag = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String outPutVal;</span><br><span class="line">    <span class="keyword">private</span> Integer printCnt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendsTreadDemo</span><span class="params">(String outPutVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outPutVal = outPutVal;</span><br><span class="line">        printCnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (flag) &#123;</span><br><span class="line">                flag.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    flag.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                printCnt++;</span><br><span class="line">                <span class="keyword">if</span>(printCnt == <span class="number">11</span>)</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.outPutVal);</span><br><span class="line">                flag.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtendsTreadDemo aThread = <span class="keyword">new</span> ExtendsTreadDemo(<span class="string">"a"</span>);   <span class="comment">// 创建线程a 线程a当前处于新建态</span></span><br><span class="line">        ExtendsTreadDemo bThread = <span class="keyword">new</span> ExtendsTreadDemo(<span class="string">"b"</span>);   <span class="comment">// 创建线程b 线程b当前处于新建态</span></span><br><span class="line">        aThread.start();    <span class="comment">// 线程a进入runnable态</span></span><br><span class="line">        bThread.start();    <span class="comment">// 线程b进入runnable态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过实现Runnable接口创建线程"><a href="#通过实现Runnable接口创建线程" class="headerlink" title="通过实现Runnable接口创建线程"></a>通过实现Runnable接口创建线程</h3><p>Runnable接口只提供了Run方法的虚函数声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.suvvm.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: RunnableDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: SUVVM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/3/13 15:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object flag = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String outPutVal;</span><br><span class="line">    <span class="keyword">private</span> Integer printCnt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableDemo</span><span class="params">(String outPutVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outPutVal = outPutVal;</span><br><span class="line">        printCnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (flag) &#123;</span><br><span class="line">                flag.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    flag.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                printCnt++;</span><br><span class="line">                <span class="keyword">if</span>(printCnt == <span class="number">11</span>)</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.outPutVal);</span><br><span class="line">                flag.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread aThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableDemo(<span class="string">"a"</span>));   <span class="comment">// 创建线程a 线程a当前处于新建态</span></span><br><span class="line">        Thread bThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableDemo(<span class="string">"b"</span>));   <span class="comment">// 创建线程b 线程b当前处于新建态</span></span><br><span class="line">        aThread.start();    <span class="comment">// 线程a进入runnable态</span></span><br><span class="line">        bThread.start();    <span class="comment">// 线程b进入runnable态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用线程并发库Condition"><a href="#使用线程并发库Condition" class="headerlink" title="使用线程并发库Condition"></a>使用线程并发库Condition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.suvvm.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ConditionDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: SUVVM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/3/13 19:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">//  public static final Object flag = new Object();</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String outPutVal;</span><br><span class="line">    <span class="keyword">private</span> Integer printCnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionDemo</span><span class="params">(String outPutVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.outPutVal = outPutVal;</span><br><span class="line">        printCnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                printCnt++;</span><br><span class="line">                <span class="keyword">if</span> (printCnt &gt;= <span class="number">11</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"end"</span> + <span class="string">" "</span> + Thread.currentThread().getName();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + outPutVal);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"a"</span>.equals(outPutVal))</span><br><span class="line">                    outPutVal = <span class="string">"b"</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    outPutVal = <span class="string">"a"</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        ConditionDemo conditionDemo = <span class="keyword">new</span> ConditionDemo(<span class="string">"a"</span>);</span><br><span class="line">        FutureTask aFutureTask = <span class="keyword">new</span> FutureTask(conditionDemo);</span><br><span class="line">        FutureTask bFutureTask = <span class="keyword">new</span> FutureTask(conditionDemo);</span><br><span class="line">        <span class="keyword">new</span> Thread(aFutureTask).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(bFutureTask).start();</span><br><span class="line">        System.out.println(aFutureTask.get());</span><br><span class="line">        System.out.println(bFutureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">软件工程导论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-05 18:33:59" itemprop="dateCreated datePublished" datetime="2020-01-05T18:33:59+08:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%BD%92%E7%BA%B3/" itemprop="url" rel="index"><span itemprop="name">理论归纳</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><h2 id="软件工程学概述"><a href="#软件工程学概述" class="headerlink" title="软件工程学概述"></a>软件工程学概述</h2><h3 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h3><p>计算机程序、数据以及各种文档的集合</p>
<h3 id="软件工程三要素"><a href="#软件工程三要素" class="headerlink" title="软件工程三要素"></a>软件工程三要素</h3><ul>
<li>方法</li>
<li>工具</li>
<li>过程</li>
</ul>
<h3 id="软件危机-选择"><a href="#软件危机-选择" class="headerlink" title="软件危机(选择)"></a>软件危机(选择)</h3><h4 id="软件危机介绍"><a href="#软件危机介绍" class="headerlink" title="软件危机介绍"></a>软件危机介绍</h4><p>在计算机的开发和维护过程中所遇到的一系列严重问题</p>
<h4 id="软件危机的表现"><a href="#软件危机的表现" class="headerlink" title="软件危机的表现"></a>软件危机的表现</h4><ul>
<li>对开发成本和进度估计常常很不准确</li>
<li>用户对“已完成的”软件系统不满意的现象经常发生</li>
<li>软件产品质量往往靠不住</li>
<li>软件常常不可维护</li>
<li>软件通常没有适当的文档资料</li>
<li>软件成本在计算机系统中所占比例逐年上升</li>
<li>软件开发生产率提高的速度远远跟不上计算机应用的啤机及深入的趋势</li>
</ul>
<h4 id="软件危机的产生原因"><a href="#软件危机的产生原因" class="headerlink" title="软件危机的产生原因"></a>软件危机的产生原因</h4><ul>
<li>与软件本身特点有关</li>
<li>与开发和维护不正确有关</li>
</ul>
<h4 id="消除软件危机的途径"><a href="#消除软件危机的途径" class="headerlink" title="消除软件危机的途径"></a>消除软件危机的途径</h4><ul>
<li>对计算机软件有正确的认识</li>
<li>充分认识协同配合的重要性</li>
<li>推广使用在实践中总结出来的开发软件的成功方法和技术，并探索研究更有效的方法和技术</li>
<li>使用更好的开发工具</li>
</ul>
<h3 id="工程化原理开发（软件生存周期）"><a href="#工程化原理开发（软件生存周期）" class="headerlink" title="工程化原理开发（软件生存周期）"></a>工程化原理开发（软件生存周期）</h3><h4 id="必要性（优点）"><a href="#必要性（优点）" class="headerlink" title="必要性（优点）"></a>必要性（优点）</h4><ul>
<li>有利于软件开发工程的组织和管理</li>
<li>降低了整个软件开发过程的困难程度</li>
<li>对每个阶段都可选用最优的管理方法</li>
<li>保证软件质量，提高生产效率</li>
</ul>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul>
<li><p>各阶段任务应尽可能相互独立</p>
</li>
<li><p>同一阶段任务性质尽可能相同</p>
</li>
</ul>
<h4 id="软件8个生存周期"><a href="#软件8个生存周期" class="headerlink" title="软件8个生存周期"></a>软件8个生存周期</h4><ul>
<li>软件定义<ul>
<li>问题定义</li>
<li>可行性研究</li>
<li>需求分析</li>
</ul>
</li>
<li>软件开发<ul>
<li>软件设计</li>
<li>程序编码</li>
<li>软件测试</li>
</ul>
</li>
<li>软件维护<ul>
<li>运行维护</li>
</ul>
</li>
</ul>
<h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><p>为了获得高质量软件所需完成的一系列任务的框架，规定了完成各项任务的工作步骤</p>
<p>为了开发出客户需要的软件，什么人who、在什么时候when、做什么what、怎样做how以实现某一个特定的具体目标</p>
<h4 id="瀑布模型（必考）"><a href="#瀑布模型（必考）" class="headerlink" title="瀑布模型（必考）"></a>瀑布模型（必考）</h4><p>瀑布模型（线性模型）一直是唯一被广泛采用的生命周期模型，现在它仍是软件工程中应用的最为广泛的过程模型</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/瀑布模型.JPG" alt="img"></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li><p>阶段间具有顺序性和依赖性</p>
<ul>
<li>必须等待前一阶段工作完成后才能开始后一阶段工作</li>
<li>前一阶段的输出文档就是后一阶段的输入文档，只有前一阶段的输出文档正确，后一阶段的工作才能获得正确结果</li>
</ul>
</li>
<li><p>推迟实现的观点</p>
<p>分析与设计阶段主要考虑目标系统的逻辑模型，不涉及物理实现</p>
</li>
<li><p>质量保证的观点</p>
<p>为了保证软件质量每个阶段都要坚持</p>
<ul>
<li>奥力给！！！（大雾）</li>
<li>每个阶段都必须完成规定的文档，没有交出合格文档就是没有完成任务</li>
<li>每个阶段结束前都要对完成的文档进行评审，以便尽早发生问题并改正</li>
</ul>
</li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>可强迫开发人员采用规范方法</li>
<li>严格规定了每个阶段必须提交的文档</li>
<li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细检验</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>几乎完全依赖于书面规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要（需求规格说明与用户需求之间有差异）</li>
<li>瀑布模型只适用于项目开始时需求已确定的情况</li>
</ul>
<h4 id="快速原型"><a href="#快速原型" class="headerlink" title="快速原型"></a>快速原型</h4><p>快速建立起来的可以在计算机上运行的程序，完成的功能往往是最终产品能完成的功能的一个子集（实现核心功能的工作机）</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/快速原型.JPG" alt="img"></p>
<ul>
<li>原型系统已经与用户交互而得到验证，据此产生的规格说明文档正确的描述了用户需求，因此，在开发过程后续阶段不会因为发现规格说明文档的错误而进行较大的返工</li>
<li>开发人员通过建立原型系统已经学到了许多东西，因此在设计和编码阶段发生错误的可能性也比较小，减少了后续阶段需要改正前面阶段所犯错误的可能性。</li>
</ul>
<h4 id="增量模型（渐增模型）"><a href="#增量模型（渐增模型）" class="headerlink" title="增量模型（渐增模型）"></a>增量模型（渐增模型）</h4><p>把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能，使用增量模型时，第一构件往往实现软件的基本需求，提供最核心的功能</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/增量模型.JPG" alt="img"></p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>能在较短时间内向用户提交可完成部分工作的产品</li>
<li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击</li>
</ul>
<h5 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h5><ul>
<li>在把每个新的增量构建集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品</li>
<li>必须把软件的体系结构设计的便于进行扩充，向现有产品加入新构件的过程必须简单方便，软件体系结构必须是开放的。</li>
</ul>
<h4 id="螺旋模型（唯一有风险分析）"><a href="#螺旋模型（唯一有风险分析）" class="headerlink" title="螺旋模型（唯一有风险分析）"></a>螺旋模型（唯一有风险分析）</h4><p>使用原型及其他方法来尽量降低风险。理解这种模型的一个简便方法，是把它看作在每个阶段之前都增加风险分析过程的快速原型。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/简单螺旋模型.JPG" alt="img"></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/完整的螺旋模型.JPG" alt="img"></p>
<h4 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h4><p>“喷泉”体现了面向对象软件开发过程迭代和无缝的特征，迭代是软件开发过程中普遍存在的一种内在属性，用面向对象方法开发软件时，工作重点应该放在生命周期中的分析阶段。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/喷泉模型.JPG" alt="img"></p>
<h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>确定要解决的问题是什么</p>
<p>通过 客户访问调查，写出问题性质工程目标工程规模 应得到客户确认。</p>
<h2 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>不是解决问题，而是确定问题是否值得解决</p>
<h3 id="4个方面"><a href="#4个方面" class="headerlink" title="4个方面"></a>4个方面</h3><ul>
<li>技术可行性</li>
<li>经济可行性</li>
<li>操作可行性</li>
<li>法律可行性</li>
</ul>
<h3 id="可行性分析研究过程"><a href="#可行性分析研究过程" class="headerlink" title="可行性分析研究过程"></a>可行性分析研究过程</h3><ul>
<li>复查系统规模和目标</li>
<li>研究目前正在使用的系统</li>
<li>导出新系统的高层逻辑模型</li>
<li>进一步定义问题</li>
<li>导出评价供选择的解法</li>
<li>推荐行动方针</li>
<li>草拟开发计划书</li>
<li>写文档提交审查</li>
</ul>
<h3 id="系统流程图（业务流程图）"><a href="#系统流程图（业务流程图）" class="headerlink" title="系统流程图（业务流程图）"></a>系统流程图（业务流程图）</h3><p>概括地描绘物理系统的传统工具</p>
<p>用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据库、人工过程）</p>
<p>是一种<strong>物理数据流图</strong>不是程序流程图</p>
<h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>利用符号可以把广义的输入输出操作具体化为读写存储在特殊设备上的文件（或数据库），把抽象处理具体化为特定的程序或手工操作</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/系统流程图.JPG" alt="img"></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/系统流程图2.JPG" alt="img"></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>装配厂有一座存放零件的仓库，仓库中现有的各种零件的数量以及每种零件的库存量临界值等数据记录在库存清单主文件中。仓库中零件数量变化时，应该及时修改库存清单主文件，如果那种零件的库存少于它的库存临界值，应该报告给采购部门，每天向采购部门送一次订货报告。</p>
<ul>
<li>使用一台小型计算机处理更新库存清单主文件和产生订货报告的任务</li>
<li>零件库存量的每一次变化称为一个事务，由放在仓库中的CRT终端输入到计算机中</li>
<li>系统中的库存清单程序对事务进行处理，更新存储在磁盘上的库存清单文件，并把必要的订货信息写在磁带上</li>
<li>每天由报告生成程序读一次磁带，并打印出订货报告</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/系统流程图3.JPG" alt="img"></p>
<h3 id="成本-效益分析"><a href="#成本-效益分析" class="headerlink" title="成本/效益分析"></a>成本/效益分析</h3><h4 id="四个方面"><a href="#四个方面" class="headerlink" title="四个方面"></a>四个方面</h4><ul>
<li><p>货币的时间价值</p>
</li>
<li><p>投资回收期</p>
<p>累计的经济效益等于最初投资所需要的时间，也就是达到估计开发总成本加上运行维护费用所需要的时间</p>
</li>
<li><p>纯收入</p>
<p>累计经济效益（折合成现在值）－ 投资额</p>
</li>
<li><p>投资回收率</p>
<p>年经营净现金流量或年均经营净现金流量 / 原始投资额</p>
</li>
</ul>
<p>通常用利率的形式表示货币的时间价值。假设年利率为i， 如果现在存入P元，则n年后可以得到的钱数为</p>
<p>$F = P(1+i)^n$</p>
<p>这也就是P元钱在n年后的价值</p>
<p>反过来，现在的价值</p>
<p>$P = \frac F{(1+i)^n}$</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么”这个问题。</p>
<h3 id="综合要求"><a href="#综合要求" class="headerlink" title="综合要求"></a>综合要求</h3><ul>
<li>功能需求</li>
<li>性能需求</li>
<li>可靠性和可用性需求</li>
<li>出错处理需求</li>
<li>接口需求</li>
<li>约束</li>
<li>逆向需求</li>
<li>将来可能提出的要求</li>
</ul>
<p>与用户沟通获取需求的方法：访谈</p>
<h3 id="结构化分析方法（SA）"><a href="#结构化分析方法（SA）" class="headerlink" title="结构化分析方法（SA）"></a>结构化分析方法（SA）</h3><p>面向数据流的需求分析方法</p>
<h4 id="数据流图DFD"><a href="#数据流图DFD" class="headerlink" title="数据流图DFD"></a>数据流图DFD</h4><p>是一种功能模型</p>
<p>数据流图是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换</p>
<h5 id="符号-1"><a href="#符号-1" class="headerlink" title="符号"></a>符号</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据流图.JPG" alt="img"></p>
<h5 id="多个数据流之间的关系"><a href="#多个数据流之间的关系" class="headerlink" title="多个数据流之间的关系"></a>多个数据流之间的关系</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据流图2.JPG" alt="img"></p>
<h5 id="数据流图的四个元素"><a href="#数据流图的四个元素" class="headerlink" title="数据流图的四个元素"></a>数据流图的四个元素</h5><ul>
<li><p>数据流</p>
<p>数据在系统内传播，由一组固定的数据项组成。除了与数据存储之间的数据流不用命名外，数据流应该用名词或名词短语命名</p>
</li>
<li><p>加工</p>
<p>也成为数据处理，它对数据流进行某些操作或变换。每个加工也要有名字，通常是动词短语，在分层的数据流图中加工还要有编号。</p>
</li>
<li><p>数据存储</p>
<p>暂时保存的数据，可以是数据库文件或以任何形式的数据组织，流向数据存储的数据流可理解为写入文件或查询文件，从数据存储流出的数据可理解为从文件读数据或得到的查询结果。</p>
</li>
<li><p>数据源点和终点</p>
<p>统称为外部实体，指系统外部环境中的实体（包括人员、组织、或其他系统）是数据的始发点和终止点，是系统与外部环境的接口</p>
</li>
</ul>
<h5 id="画图方法"><a href="#画图方法" class="headerlink" title="画图方法"></a>画图方法</h5><ul>
<li>确定外部实体及输入、输出数据流</li>
<li>确定分解顶层的加工</li>
<li>确定使用的文件</li>
<li>用数据流将各部分链接起来，形成数据封闭</li>
<li>如果需要，继续分解加工直至达到“基本加工”</li>
</ul>
<h5 id="环境图"><a href="#环境图" class="headerlink" title="环境图"></a>环境图</h5><p>也称顶层数据流图（0层数据流图），仅包括一个数据处理过程，也是要开发的目标系统。</p>
<p>环境图的作用是确定系统在其环境中的位置，通过确定系统输入和输出与外部实体的关系确定其边界。</p>
<h5 id="分解原则"><a href="#分解原则" class="headerlink" title="分解原则"></a>分解原则</h5><p>分解到不能再分</p>
<p>自然性：概念上合理清晰</p>
<p>均匀性：理想的分解是将一个问题分解成大小均匀的几个部分</p>
<p>分解度：每个加工分解一般不超过7 +- 2个子加工，分解到基本加工为止（不能再分）</p>
<h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。</p>
<p>数据字典可以把不同的需求文档和分析模型紧密结合在一起，如果所有的开发人员在数据字典上取得一致意见，那么就可以缓和集成性问题。为了避免冗余和不一致性，应该在项目中创建一个独立的数据字典，而不是在每个需求出现的地方定义每一个数据项</p>
<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><ul>
<li>作为分析阶段的工具</li>
<li>包含每个元素的控制信息</li>
<li>是开发数据库的第一步</li>
</ul>
<h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据字典.JPG" alt="img"></p>
<p>对数据流图中包含的所有元素的定义的集合构成了数据词典。 数据词典和数据流图共同构成系统的逻辑模型</p>
<ul>
<li><p>数据项也称数据元素，是数据的最小单位。</p>
<p>数据项名称及其编号、别名、取值范围和取值含义、备注。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据字典数据项.JPG" alt="img"></p>
</li>
<li><p>数据结构</p>
<p>一个数据结构由若干个数据项或者由若干个数据结构组成——它把关 系“密切”的数据组合在一起。</p>
<p>名称及其编号，数据结构的组成。 若是一个简单的数据结构，只列出数据项； 若嵌套了数据结构，只列出数据结构的名称</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据字典数据结构.JPG" alt="img"></p>
</li>
<li><p>数据流</p>
<p>在数据流图中，数据以数据流为单位进行传输</p>
<p>数据流名称及其编号、别名 数据流的来源（或是外部实体或是加工或是数据存储） 数据流的去向（或是外部实体或是加工或是数据存储） 数据流的组成（可以包含若干个数据结构，若只有一个数据结构， 就不需要专门定义）。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据字典数据流.JPG" alt="img"></p>
</li>
<li><p>数据存储</p>
<p>保留或保存数据的地方</p>
<p>数据存储名称及其编号、数据存储的组成（包含的数据项或数据结 构）、组织方式</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据字典数据存储.JPG" alt="img"></p>
</li>
<li><p>加工逻辑</p>
<p>名称及其编号、加工逻辑的输入和输出、加工逻辑的说明（对加 工逻辑的功能做明确的描述。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据字典加工逻辑.JPG" alt="img"></p>
</li>
<li><p>外部实体</p>
<p>人机界面</p>
<p>外部实体的名称、编号及外部实体的简述，与外部实体有关的数据流</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/数据字典外部实体.JPG" alt="img"></p>
</li>
</ul>
<h4 id="判定树（决策树）"><a href="#判定树（决策树）" class="headerlink" title="判定树（决策树）"></a>判定树（决策树）</h4><p>用于描述分类过程的二叉树</p>
<p>一图书销售系统，其中一加工为“优惠处理” ，条件是：顾客的 营业额大于1000元，同时必须信誉好；或者虽然信誉不好，但是20年以上 的老主顾。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/判定树.JPG" alt="img"></p>
<p>例题</p>
<p>某数据流图中有一个“确定保险类别”的加工，指的 是申请汽车驾驶保险时，要根据申请者的情况确定不同的 保险类别。加工逻辑为：如果申请者的年龄在21岁以下， 要额外收费；如果申请者是21岁以上并是26岁以下的女性 ，适用于A类保险；如果申请者是26岁以下的已婚男性， 或者是26岁以上的男性，适用于B类保险；如果申请者是 21岁以下的女性或是26岁以下的单身男性，适用于C类保 险。除此之外的其他申请者都适用于A类保险。 画出相应的判定树。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/判定树例题.JPG" alt="img"></p>
<h4 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h4><p>判定表是一种二维的表格，常用于较复杂的组合条件（与结构化语 言比较），通常由四部分组成：条件、行动方案、状态、选择规则</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/判定表1.JPG" alt="img"></p>
<p>优化后</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/判定表2.JPG" alt="img"></p>
<p>判定表的简化</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/判定表的简化.JPG" alt="img"></p>
<h3 id="状态图-状态转换图"><a href="#状态图-状态转换图" class="headerlink" title="状态图(状态转换图)"></a>状态图(状态转换图)</h3><p>状态转换图通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。指明了作为特定事件的结果系统将做那些动作。</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态图指明了作为特定事件的结果系统将做那些动作。</p>
<p>在状态图中定义的状态主要有：</p>
<ul>
<li>初态（初始状态）</li>
<li>终态（最终状态）</li>
<li>中间态</li>
</ul>
<p>只能有一个初态，终态可以有0至多个。</p>
<h4 id="符号-2"><a href="#符号-2" class="headerlink" title="符号"></a>符号</h4><p>初态用实心圆表示，终态用牛眼图形表示，中间态用圆角矩形表示</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/状态图符号.JPG" alt="img"></p>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul>
<li><p>两个状态之间带箭头的连线称为状态转换</p>
</li>
<li><p>状态变迁通常由事件触发，应在表示状态转换的箭头线上标出触发转换的事件表达式。</p>
<p>事件表达式：事件说明[守卫条件]/动作表达式</p>
</li>
<li><p>如果箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换</p>
</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/状态图.JPG" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>电话系统状态图</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/电话状态图.png" alt="img"></p>
<p>存款过程状态图</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/存款过程状态图.png" alt="img"></p>
<h3 id="软件需求规格说明书"><a href="#软件需求规格说明书" class="headerlink" title="软件需求规格说明书"></a>软件需求规格说明书</h3><p>软件需求规模说明是需求分析阶段得出的最主要的文档。</p>
<p>通常用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="总体设计（概要设计）"><a href="#总体设计（概要设计）" class="headerlink" title="总体设计（概要设计）"></a>总体设计（概要设计）</h3><p>最关键步骤：确定软件体系结构</p>
<h4 id="总体设计的九大任务"><a href="#总体设计的九大任务" class="headerlink" title="总体设计的九大任务"></a>总体设计的九大任务</h4><ul>
<li>设想供选择的方案</li>
<li>选取合理的方案</li>
<li>推荐最佳方案</li>
<li>功能分解</li>
<li>设计软件结构</li>
<li>设计数据库</li>
<li>制定测试计划</li>
<li>书写文档</li>
<li>审查和复审</li>
</ul>
<h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><p>把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成构成一个整体，可以完成指定的功能满足用户的需求。</p>
<h5 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h5><p>精确表达模块结构的图形表示工具</p>
<ul>
<li>调用关系和接口：在结构图中两个模块之间用单向箭头连接</li>
<li>模块之间的信息传递：当一个模块调用另一个模块时，调用模块把数据或控制信息传送给被调用的模块，以使被调用模块能够运行</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/结构图.JPG" alt="img"></p>
<ul>
<li>有条件调用在箭头尾部加菱形</li>
<li>反复调用加弧形</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/结构图2.JPG" alt="img"></p>
<ul>
<li>深度：表示从顶层模块到底层模块的层数</li>
<li>宽度：同一层次上的模块总数</li>
<li>扇出数：一个模块直接控制的下属模块数</li>
<li>扇入数：一个模块直接上属模块个数</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/结构图3.JPG" alt="img"></p>
<ul>
<li>选择调用：根据判断决定是否调用（空心菱形）</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/结构图4.JPG" alt="img"></p>
<h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><p>耦合性指软件结构中模块连接的紧密程度，是模块间相互连接性的度量。耦合强度的大小是由模块间<strong>接口的复杂程度</strong>决定的。</p>
<h5 id="耦合的类型"><a href="#耦合的类型" class="headerlink" title="耦合的类型"></a>耦合的类型</h5><ul>
<li><p>内容耦合 高耦合</p>
<ul>
<li>一个模块直接访问另一模块的内部数据</li>
<li>一个模块不通过正常入口转到另一模块内部</li>
<li>一个模块由多个入口</li>
<li>两个模块由部分代码重迭</li>
</ul>
<p>高级语言中不允许出现，但汇编语言中可能出现</p>
</li>
<li><p>公共耦合</p>
<p>若干模块访问一个公共的数据环境（全局数据结构、共享的通信区、内存的公共覆盖区）耦合的复杂度随耦合模块的数量增加而增加</p>
<ul>
<li><p>松散公共耦合</p>
<p>模块同时只对公共数据环境进行读或写一种操作（目前使用较多的低耦合方式）</p>
</li>
<li><p>紧密公共耦合</p>
<p>若干模块对公共数据环境同时读和写</p>
<p>使公共数据区的变化影响所有公共耦合模块，严重影响模块可靠性和可适应性，降低软件可读写（强耦合）</p>
</li>
</ul>
<p>问题</p>
<ul>
<li>无法控制各个模块对公共数据的存取，严重影响软件模块的可靠性和适应性</li>
<li>使软件可维护性变差</li>
<li>降低软件的可理解性</li>
</ul>
<p>只有共享数据过多，传参不方便时使用公共耦合</p>
</li>
<li><p>外部耦合 </p>
<p>一组模块都通过访问同一全局<strong>简单变量</strong>，而不是通过传参传递该信息。</p>
</li>
<li><p>控制耦合 中耦合</p>
<p>一个模块传递给另一个模块的信息是用于控制该模块内部的控制信号，对被控制模块的任何修改都会影响到控制模块</p>
</li>
<li><p>标记耦合 </p>
<p>一个模块传给另一个模块的参数是一个复合的数据结构（如高级语言的数组名、记录名，其实传递的是地址）会使某些本来无关的模块产生相互依赖性</p>
</li>
<li><p>数据耦合 低耦合</p>
<p>一个模块传给另一个模块的参数是单个的数据项或单个数据项组成的数组，模块间传递的是简单数据值，相当于高级语言中的值传递</p>
</li>
<li><p>非直接耦合 低耦合</p>
<p>两个模块间没有直接的关系，它们分别从属于不同模块的控制与调用，之间不传递任何信息，这种耦合程度最弱，模块独立性最高</p>
</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/耦合性.png" alt="img"></p>
<p>尽量使用数据耦合，少用控制耦合和特征耦合（把整个数据结构作为参数传递而被调用的模块只需要 使用其中一部分数据元素），限制公 共环境耦合的范围，完全不用内容耦合</p>
<h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><p>内聚性表示一个模块内部各个元素（数据、处理）之间联系的紧密程度。它是信息隐蔽和局部化概念的自然扩展，是从功能的角度来度量模块间的联系。块内联系愈紧，即内聚性愈高，模块独立性愈好。</p>
<h5 id="内聚的类型"><a href="#内聚的类型" class="headerlink" title="内聚的类型"></a>内聚的类型</h5><ul>
<li><p>偶然内聚（巧合） 低内聚</p>
<p>为了节约空间，将毫无关系或联系不多的各元素放在一个模块中。模块元素关系松散，不易理解，不易修改</p>
</li>
<li><p>逻辑内聚 低内聚</p>
<p>将几个逻辑上相似的功能放在一个模块中，使用时由调用模块传递的参数确定执行的功能。由于由传递控制参数，影响了模块的内聚性</p>
</li>
<li><p>时间内聚（经典内聚） 低内聚</p>
<p>把需要同时执行的成分放在一个模块中。如初始化、终止操作这一类内部结构比较简单的模块。由于判定较少，所以比逻辑内聚高，但由于内含多个功能，修改和维护困难</p>
</li>
<li><p>过程内聚 中内聚</p>
<p>一个模块内的除了元素是相关的，而且必须以特定的次序执行。一个模块内有多个功能成分。</p>
</li>
<li><p>通信内聚 中内聚</p>
<p>模块中的成分引用共同的输入数据，或者产生相同的输出数据，则称为通信内聚。</p>
</li>
<li><p>顺序内聚 高内聚</p>
<p>一个模块内的处理元素都密切相关于同一功能，模块中的某个成分的输出是另一成分的输入。由于这类模块是按数据执行顺序，模块的一部分依赖于另一部分，因此具有较好的内聚性。</p>
</li>
<li><p>功能内聚 高内聚</p>
<p>一个模块仅包括完成某一具体功能所必须的所有部分。模块的所有成分都是为完成该功能而协同工作、紧密联系、不可分割的。</p>
<p>如 求平方根、判断素数、求解一元二次方程、计算利息等。</p>
</li>
</ul>
<h4 id="启发设计规则"><a href="#启发设计规则" class="headerlink" title="启发设计规则"></a>启发设计规则</h4><h5 id="改进软件结构提高模块独立性"><a href="#改进软件结构提高模块独立性" class="headerlink" title="改进软件结构提高模块独立性"></a>改进软件结构提高模块独立性</h5><p>设计出初步结构后应审查分析，通过模块分解或合并，力求降低耦合提高内聚</p>
<h5 id="模块规模应该适中"><a href="#模块规模应该适中" class="headerlink" title="模块规模应该适中"></a>模块规模应该适中</h5><p>模块规模不应过大（60行）</p>
<h5 id="深度、宽度、扇出、扇入都应适当"><a href="#深度、宽度、扇出、扇入都应适当" class="headerlink" title="深度、宽度、扇出、扇入都应适当"></a>深度、宽度、扇出、扇入都应适当</h5><h5 id="模块的作用域应该在控制域内"><a href="#模块的作用域应该在控制域内" class="headerlink" title="模块的作用域应该在控制域内"></a>模块的作用域应该在控制域内</h5><p>作用域：受该模块内一个判定影响的所有模块的集合</p>
<p>控制域：模块本身以及所有直接或间接从属于它的模块的集合</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/作用范围与控制范围.JPG" alt="img"></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/作用范围与控制范围2.JPG" alt="img"></p>
<p>菱形代表判定所在模块，蓝色代表判定影响模块</p>
<p>d的设计最合理</p>
<h5 id="力争降低接口的复杂度"><a href="#力争降低接口的复杂度" class="headerlink" title="力争降低接口的复杂度"></a>力争降低接口的复杂度</h5><p>接口复杂是软件发生错误的主要原因之一，应使信息传递简单且和模块功能一致</p>
<h5 id="设计单入口单出口的模块"><a href="#设计单入口单出口的模块" class="headerlink" title="设计单入口单出口的模块"></a>设计单入口单出口的模块</h5><p>这条启发式规则警告不要出现内容耦合</p>
<h5 id="模块功能应该可以预测"><a href="#模块功能应该可以预测" class="headerlink" title="模块功能应该可以预测"></a>模块功能应该可以预测</h5><p>模块功能应该可以预测，但也要防止模块功能过于局限</p>
<h4 id="面向数据流的设计方法（注意判断结构图类型）"><a href="#面向数据流的设计方法（注意判断结构图类型）" class="headerlink" title="面向数据流的设计方法（注意判断结构图类型）"></a>面向数据流的设计方法（注意判断结构图类型）</h4><p>把信息流映射成软件结构，信息流的类型决定了映射的方法</p>
<h5 id="信息流的两种类型"><a href="#信息流的两种类型" class="headerlink" title="信息流的两种类型"></a>信息流的两种类型</h5><ul>
<li><p>变换流</p>
<p>信息沿输入通路进入系统，由外部形式变换为内部形式，进入系统的信息经过变换中心，经加工处理后再沿输出通路变换为外部形式离开软件系统</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/变换流.JPG" alt="img"></p>
<p>通过<strong>变换分析</strong>技术将中心变换型的数据流图（DFD）变为结构图（SC），得到的的SC图称为变换型系统结构图，相应于取得的数据、变换数据、给出数据，系统的结构体由<strong>输入、中心变换和输出</strong>三部分组成。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/变换型系统结构图.JPG" alt="img"></p>
<p><strong>变换分析技术</strong></p>
<ul>
<li>确定主加工及逻辑输入输出</li>
<li>进行一级分解，设计上层模块</li>
<li>进行二级分解设计中下层模块</li>
<li>进一步细化</li>
</ul>
</li>
<li><p>事务流</p>
<p>数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/事务流.JPG" alt="img"></p>
<p>处理T称为数据中心</p>
<ul>
<li>接收输入数据</li>
<li>分析每个事务以确定它的类型</li>
<li>根据事务类型选择活动通路</li>
</ul>
<p>通过<strong>事务分析</strong>技术将中心变换型的数据流图（DFD）变为结构图（SC），得到的的SC图称为事务型系统结构图，事务中心模块按所接受的事务类型选择某一个事务处理模块执行，各个事务处理模块是并列的，依赖于一定的选择条件，分别完成不同的事务处理工作。</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/事务型系统结构图.JPG" alt="img"></p>
<p><strong>事务分析技术</strong></p>
<ul>
<li>确定流界</li>
<li>进行一级分析，设计上层模块</li>
<li>进行二级分解，设计中下层模块</li>
</ul>
</li>
</ul>
<h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><h4 id="根本目标"><a href="#根本目标" class="headerlink" title="根本目标"></a>根本目标</h4><p>确定应该怎样具体地实现所要求的系统，任务不是具体地编写程序，而是要设计出程序的“蓝图”</p>
<p>详细设计的结果基本决定了最终程序代码的质量</p>
<h4 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h4><ul>
<li>结构程序设计</li>
<li>人机界面设计</li>
<li>过程设计的工具</li>
<li>面向数据结构的设计方法</li>
<li>程序复杂程度的定量度量</li>
</ul>
<h4 id="结构程序设计"><a href="#结构程序设计" class="headerlink" title="结构程序设计"></a>结构程序设计</h4><ul>
<li>少用goto</li>
<li>代码块单入单出</li>
<li>使用顺序选择循环</li>
<li>自顶向下逐步求精</li>
</ul>
<p>顺序、选择和循环</p>
<p>结构程序设计经典定义：一个程序的代码块仅由顺序选择和循环三种基本控制连接，且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</p>
<p>扩展的结构程序设计：在以上基础上允许 DO-CASE和DO-UNTIL</p>
<p>修正的结构程序设计：在以上基础上允许使用LEAVE（或BREAK）结构  </p>
<h4 id="人机界面设计"><a href="#人机界面设计" class="headerlink" title="人机界面设计"></a>人机界面设计</h4><ul>
<li>系统响应时间</li>
<li>用户帮助设施</li>
<li>出错信息处理</li>
<li>命令交互</li>
</ul>
<h4 id="过程设计工具（三种图）"><a href="#过程设计工具（三种图）" class="headerlink" title="过程设计工具（三种图）"></a>过程设计工具（三种图）</h4><h5 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/程序流程图.png" alt="img"></p>
<p><strong>缺点</strong></p>
<ul>
<li>本质上不是逐步求精的好工具，诱使程序员过早的考虑程序的控制流程，而不去考虑全局结构</li>
<li>程序流程图中用箭头代表控制流，程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制</li>
<li>程序流程图不易表示数据结构</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/程序流程图实例.JPG" alt="img"></p>
<h5 id="盒图（N-S图）"><a href="#盒图（N-S图）" class="headerlink" title="盒图（N-S图）"></a>盒图（N-S图）</h5><p>不允许违背结构程序设计精神的图形工具</p>
<p><strong>特点</strong></p>
<ul>
<li>功能域（特定控制结构的作用域）明确</li>
<li>不可能任意转移控制</li>
<li>很容易确定局部和全程数据的作用域</li>
<li>很容易表现嵌套关系，也可以表示模块的层次结构![]</li>
</ul>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/盒图.png" alt="img"></p>
<p><strong>实例</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/盒图实例1.JPG" alt="img"></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/盒图实例2.JPG" alt="img"></p>
<h5 id="PAD图（问题分析图）"><a href="#PAD图（问题分析图）" class="headerlink" title="PAD图（问题分析图）"></a>PAD图（问题分析图）</h5><p>用二维树形结构的图来表示程序的控制流</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/PAD图.png" alt="img"></p>
<p><strong>优点</strong></p>
<ul>
<li>使用表示结构化控制的PAD符号设计出的程序必然是结构化程序</li>
<li>PAD图所描绘的程序结构十分清晰</li>
<li>PAD图表现程序逻辑，易读、易懂、易记</li>
<li>容易将PAD图转换为高级语言</li>
<li>既可用于表示程序逻辑，也可以用于描绘数据</li>
<li>PAD图符号支持自顶向下、逐步求精方法的使用</li>
</ul>
<h5 id="判定表-1"><a href="#判定表-1" class="headerlink" title="判定表"></a>判定表</h5><p>总体设计中有提到，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/判定表详细设计.JPG" alt="img"></p>
<h5 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h5><p>判定树是判定表的变种，它也能清晰的表示复杂的条件组合与应做的动作之间的对应关系</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/判定树详细设计.JPG" alt="img"></p>
<h5 id="过程设计语言（PDL）"><a href="#过程设计语言（PDL）" class="headerlink" title="过程设计语言（PDL）"></a>过程设计语言（PDL）</h5><p>PDL也称为伪码，是用正文形式表示数据处理和处理过程的设计工具</p>
<p><strong>特点</strong></p>
<ul>
<li>关键字固定语法，提供了结构化控制结构、数据说明和模块化的特点</li>
<li>自然语言自由语法，描述处理特点</li>
<li>数据说明的手段，包括简单的数据结构，也包含复杂的数据结构</li>
<li>模块定义和调用的技术，应提供各种接口描述模式。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>可作为注释之间插在源程序中间</li>
<li>可使用普通的正文编辑程序或文字处理系统完成书写工作</li>
<li>可自动由PDL生成代码</li>
</ul>
<h4 id="面向数据结构的设计方法"><a href="#面向数据结构的设计方法" class="headerlink" title="面向数据结构的设计方法"></a>面向数据结构的设计方法</h4><h5 id="Jacksion图"><a href="#Jacksion图" class="headerlink" title="Jacksion图"></a>Jacksion图</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/Jacksion顺序.JPG" alt="img"></p>
<p>A由B、C、D三个元素顺序组成，每个元素只出现一次，顺序为B$\rightarrow$C$\rightarrow$D</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/Jacksion选择.JPG" alt="img"></p>
<p>根据条件A决定是B、C或D中的某一个</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/Jacksion重复.JPG" alt="img"></p>
<p>A由B出现N次组成</p>
<p><strong>Jackson法</strong></p>
<ul>
<li><p>分析并确定输入输出属性和输出数据的逻辑结构，用Jackson图描绘这些数据结构</p>
</li>
<li><p>找出输入数据结构和输出数据结构中有对应关系的数据单元</p>
</li>
<li><p>用下述3条规则从描绘数据结构的Jackson图导出描绘程序 结构的Jackson图</p>
<ul>
<li>为每对有对应关系的数据单元，按照它们在数据结构图中的 层次在程序结构图的相应层次画一个处理框</li>
<li>根据输入数据结构中剩余的每个数据单元所处的层次，在程 序结构图的相应层次分别为它们画上对应的处理框</li>
<li>根据输出数据结构中剩余的每个数据单元所处的层次，在程 序结构图的相应层次分别为它们画上对应的处理框</li>
</ul>
</li>
<li><p>列出所有操作和条件，并把它们分配到程序结构图的适当位置</p>
</li>
<li><p>用伪码表示程序</p>
<ul>
<li><p>```c<br>// 顺序结构<br>A seq</p>
<pre><code>B
C
D
</code></pre><p>A end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c</span><br><span class="line">  &#x2F;&#x2F; 选择结构</span><br><span class="line">  A select cond1</span><br><span class="line">      B</span><br><span class="line">  A or cond2</span><br><span class="line">      C</span><br><span class="line">  A or cond3</span><br><span class="line">      D</span><br><span class="line">  A end</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="lang-c">// 重复结构
A iter until(while) cond
    B
A end
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="程序复杂度定理度量"><a href="#程序复杂度定理度量" class="headerlink" title="程序复杂度定理度量"></a>程序复杂度定理度量</h4><p>把程序的复杂程度乘以适当常数即可估算出软件中错误的数量以及软件开发需要用的工作量</p>
<p>定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣</p>
<p>程序的定量的复杂程度可以作为模块规模的精确限度</p>
<h5 id="计算环形复杂度的方法"><a href="#计算环形复杂度的方法" class="headerlink" title="计算环形复杂度的方法"></a>计算环形复杂度的方法</h5><ul>
<li>流图中线性无关的区域数等于环形复杂度</li>
<li>流图G的环形复杂度V(G) = E - N + 2，E为边数，N为结点数</li>
<li>G的环形复杂度V(G) = P + 1，P为流图中判定结点的数量</li>
</ul>
<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>软件生命周期的每个阶段不可避免地会产生错误，测试是对软件分析、设计、编码进行查错纠错的活动。软件测试是有<strong>破坏性</strong>的</p>
<h3 id="测试目标"><a href="#测试目标" class="headerlink" title="测试目标"></a>测试目标</h3><p><strong>根本目标</strong>：尽可能多地发现并排除软件中潜藏的错误，最终把一个高质量的软件系统交给用户</p>
<p><strong>具体目标</strong></p>
<ul>
<li>测试是为了发现程序中的错误而执行的过程</li>
<li>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案</li>
<li>成功的测试是发现了至今为止尚未发现的错误的测试</li>
</ul>
<h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><ul>
<li>单元测试：用设计的测试用例，测试模块是否正确实现了功能</li>
<li>集成测试：把通过单元测试的模块组装在一起，看能不能实现功能</li>
<li>系统测试：把经过确认的软件纳入实际运行环境与相应环境组合在一起进行测试，以检查软件是否能正确稳定地运行</li>
<li>验收测试：检查已经组装完成的软件是否能实现需求说明规定功能以及功能是否完整正确</li>
</ul>
<h4 id="测试词汇"><a href="#测试词汇" class="headerlink" title="测试词汇"></a>测试词汇</h4><p><strong>测试工具</strong>：测试用例 + 测试数据 + 预期结果 + 测试环境</p>
<p><strong>测试结束</strong>：数据 + 期望结果 + 实际结果</p>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><ul>
<li><p>静态分析</p>
<p>人工的、非形式化的方法对程序进行分析测试</p>
</li>
<li><p>动态测试</p>
<p>选择适当的测试用例，执行程序</p>
<ul>
<li>黑盒测试</li>
<li>白盒测试</li>
</ul>
</li>
</ul>
<h4 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h4><p>不考虑程序内部结构与特性，只根据程序功能或程序的外部特性设计测试用例</p>
<h5 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h5><p>把被测对象的输入域分为有限个等价区段——“等价类”，以有针对性的等价类少量测试，代替漫无边际的、数量大的“穷尽”测试或随机测试。</p>
<p><strong>等价类划分</strong></p>
<ul>
<li><p>有效等价类</p>
<p>对于程序的规格说明是合理的、有意义的输入数据的集合。</p>
</li>
<li><p>无效等价类</p>
<p>对于程序的规格说明是不合理、没有意义的输入数据集合。</p>
</li>
</ul>
<p><strong>选择测试用例</strong></p>
<p>测试用例要尽量多覆盖有效等价类，每个无效等价类要有对应测试用例</p>
<p><strong>边界值分析法</strong></p>
<p>边界类型：下标、数据结构、循环、选择等的边界附近</p>
<p>使程序运行在边界附近的测试方案更容易暴露程序错误</p>
<p>一般选取刚好等于、稍小于和稍大于等价类边界值的数据作为测试数据</p>
<p><strong>错误推测法</strong></p>
<p>列举出程 序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案</p>
<h4 id="白盒测试（结构测试）"><a href="#白盒测试（结构测试）" class="headerlink" title="白盒测试（结构测试）"></a>白盒测试（结构测试）</h4><p>分析程序的内部逻辑结构，根据适当的覆盖标准设计测试用例，对主要路径进行尽可能多的测试</p>
<h5 id="六个标准（弱到强）"><a href="#六个标准（弱到强）" class="headerlink" title="六个标准（弱到强）"></a>六个标准（弱到强）</h5><ul>
<li>语句覆盖：每条语句至少执行一次</li>
<li>判定覆盖：每个判定的每个分支至少执行一次</li>
<li>条件覆盖：每个判定的每个条件应取到各种可能的值</li>
<li>判断条件覆盖：同时满足判定覆盖和条件覆盖</li>
<li>条件组合覆盖：每个判定中各条件的每一种组合至少出现一次</li>
<li>路径覆盖：使程序中每一条可能的路径至少执行一次</li>
</ul>
<p>一般以条件组合覆盖为主测试用例，然后补充部分用例以达到路径覆盖测试标准。</p>
<h5 id="基本路径测试"><a href="#基本路径测试" class="headerlink" title="基本路径测试"></a>基本路径测试</h5><p>在程序控制流图的基础上通过分析构造的环路复杂性，导出基本可执行路径的集合。</p>
<p>设计出的测试用例保证在测试中程序的每一给可执行语句至少执行一次</p>
<ul>
<li><p>先画控制流图</p>
</li>
<li><p>计算复杂度</p>
<p>从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界</p>
<p>计算区域时应包括图外部的范围。</p>
</li>
<li><p>写出基本路径</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/白盒基本路径.JPG" alt="img"></p>
</li>
<li><p>设计测试用例</p>
</li>
</ul>
<p>注意如果判断语句由多条语句复合而成，需要将其单独分开成为多个条件</p>
<h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><p>在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程</p>
<h3 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>程序在给定时间间隔内，按照规格说明书的规定成功运行的概率</p>
<h4 id="软件可用性"><a href="#软件可用性" class="headerlink" title="软件可用性"></a>软件可用性</h4><p>程序在给定时间点，按照规格说明书的规定，成功运行的概率</p>
<h4 id="平均无故障时间MTTF"><a href="#平均无故障时间MTTF" class="headerlink" title="平均无故障时间MTTF"></a>平均无故障时间MTTF</h4><h5 id="符号-3"><a href="#符号-3" class="headerlink" title="符号"></a>符号</h5><p>$E_T$——测试之前程序中的错误总数</p>
<p>$I_T$——程序长度（机器指令总数）</p>
<p>$\tau$——测试（包括调试）时间</p>
<p>$E_d(\tau)$——在0至$\tau$期间发现的错误数</p>
<p>$E_c(\tau)$——在0至$\tau$期间改正的错误数</p>
<p>$MTTF=\frac{1}{K(\frac{E_T}{I_t}-\frac{E_c(\tau)}{I_T})}$</p>
<p>K的典型值是200</p>
<h3 id="维护的四种类型"><a href="#维护的四种类型" class="headerlink" title="维护的四种类型"></a>维护的四种类型</h3><ul>
<li>改正性维护</li>
<li>适应性维护</li>
<li>完善性维护</li>
<li>预防性维护</li>
</ul>
<h3 id="维护的过程"><a href="#维护的过程" class="headerlink" title="维护的过程"></a>维护的过程</h3><h4 id="维护过程的本质"><a href="#维护过程的本质" class="headerlink" title="维护过程的本质"></a>维护过程的本质</h4><p>修改和压缩了的软件定义和开发过程</p>
<ul>
<li><p>维护组织</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/维护组织.JPG" alt="img"></p>
</li>
<li><p>维护报告</p>
<p>用标准化格式表达所有软件维护要求</p>
</li>
<li><p>维护的事件流</p>
<p>不管维护类型如何都包括</p>
<p>修改软件设计、复查、必要的代码修改、单元测试和集成测试(包括使用以前的测试方案的回归测试)、验收测试和复审</p>
</li>
<li><p>保护维护记录</p>
</li>
<li><p>评价维护活动</p>
</li>
</ul>
<h3 id="维护的副作用"><a href="#维护的副作用" class="headerlink" title="维护的副作用"></a>维护的副作用</h3><ul>
<li><p>修改代码的副作用</p>
<p>可能引入新的错误</p>
</li>
<li><p>修改数据的副作用</p>
<p>原有软件设计可能对这些数据不在适应从而产生错误</p>
</li>
<li><p>修改文档的副作用</p>
<p>如果源代码的修改没有反映在设计文档或用户手册中，就会产生文档的副作用</p>
</li>
</ul>
<h3 id="软件的可维护性"><a href="#软件的可维护性" class="headerlink" title="软件的可维护性"></a>软件的可维护性</h3><ul>
<li>可理解性</li>
<li>可测试性</li>
<li>可修改性</li>
<li>可移植性</li>
<li>可重用性</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul>
<li>封装：隐藏对象的属性和实现细节，仅对外公开接口</li>
<li>继承：子类继承父类的特征和行为</li>
<li>多态：是指一个类实例（对象）的相同方法在不同情形有不同表现形式</li>
</ul>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="UML9种图"><a href="#UML9种图" class="headerlink" title="UML9种图"></a>UML9种图</h3><ul>
<li>动态<ul>
<li>顺序图</li>
<li>活动图</li>
<li>协作图</li>
<li>状态图</li>
</ul>
</li>
<li>静态<ul>
<li>用例图</li>
<li>类图</li>
<li>对象图</li>
<li>构件图</li>
<li>部署图</li>
</ul>
</li>
</ul>
<h4 id="用例图（静态）"><a href="#用例图（静态）" class="headerlink" title="用例图（静态）"></a>用例图（静态）</h4><p>用于描述用例模型，包括参与者用例之间的关系</p>
<h5 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h5><p><strong>关联</strong> </p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/关联.png" alt="img"></p>
<p>实线，参与者与用例之间的交互，表示通信（若带箭头可以表明发起者）</p>
<p><strong>包含</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/包含.png" alt="img"></p>
<p>带箭头虚线，指向被包含用例，包含用例是必须的</p>
<p><strong>扩展</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/扩展.png" alt="img"></p>
<p>带箭头虚线，指向被扩展用例，扩展用例是可选的</p>
<p><strong>泛化</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/泛化.png" alt="img"></p>
<p>空心三角实线，特殊方（子类）指向一般方（父类），就是继承的逆过程</p>
<p>用例和参与者：关联 </p>
<p>用例：包含（include）扩展（extend）  泛化</p>
<p>参与者： 继承（泛化的逆过程）</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/用例图.JPG" alt="img"></p>
<h4 id="类图（静态）"><a href="#类图（静态）" class="headerlink" title="类图（静态）"></a>类图（静态）</h4><p>描述了类与类之间的静态关系。</p>
<h5 id="关系-1"><a href="#关系-1" class="headerlink" title="关系"></a>关系</h5><p><strong>泛化</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/泛化.png" alt="img"></p>
<p>空心三角实线，子类指向父类</p>
<p><strong>关联</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/关联类图.png" alt="img"></p>
<p>实线，两端写有对应关联方式，双向关联无箭头，单项关联有一个箭头</p>
<p><strong>实现</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/类图实现.png" alt="img"></p>
<p>空心三角+虚线，是整体与部分的关系，且部分可以离开整体而单独存在</p>
<p><strong>聚合</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/类图聚合.png" alt="img"></p>
<p>实线+空心菱形</p>
<p><strong>组合</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/类图组合.png" alt="img"></p>
<p>实心菱形+实线，是整体与部分的关系，但部分不能离开整体而单独存在</p>
<p><strong>依赖</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/类图依赖.png" alt="img"></p>
<p>带箭头虚线，指向被依赖的对象，一个类的实现需要另一个类的协助</p>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/类图.JPG" alt="img"></p>
<h4 id="顺序图-交互图-动态"><a href="#顺序图-交互图-动态" class="headerlink" title="顺序图(交互图 动态)"></a>顺序图(交互图 动态)</h4><ul>
<li><p>表示用例中的行为顺序</p>
</li>
<li><p>展示对象之间的交互</p>
</li>
<li><p>顺序图重点在消息队列上</p>
</li>
<li>浏览顺序图的方法：从上到下查看对象间交互信息</li>
</ul>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p><strong>参与者</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/顺序图参与者.png" alt="img"></p>
<p>与系统，子系统或类发生交互的外部用户</p>
<p><strong>对象</strong></p>
<p>顺序图横轴是有关对象，矩形框+对象名+下划线</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/顺序图对象.png" alt="img"></p>
<p><strong>生命线</strong></p>
<p>坐标轴纵向虚线表示对象在序列终点执行情况</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/顺序图生命线.png" alt="img"></p>
<p><strong>消息符号</strong></p>
<p>消息用从一个对象的上面写到另一个对象生命线的箭头表示</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/顺序图消息.png" alt="img"></p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/顺序图.JPG" alt="img"></p>
<h4 id="协作图（交互图-动态）"><a href="#协作图（交互图-动态）" class="headerlink" title="协作图（交互图 动态）"></a>协作图（交互图 动态）</h4><p>顺序图的变化形式，描述相互协作的对象之间的交互关系和连接关系</p>
<p>与顺序图的区别：顺序图侧重时间，但没有明确表示对象之间的关系</p>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/协作图.JPG" alt="img"></p>
<h4 id="状态图-动态"><a href="#状态图-动态" class="headerlink" title="状态图(动态)"></a>状态图(动态)</h4><p>描述一个特定对象的所有可能的状态以及引起状态转换的事件</p>
<h5 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h5><ul>
<li><p>初态</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/初态.png" alt="img"></p>
</li>
<li><p>终态</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/终态.png" alt="img"></p>
</li>
<li><p>中间状态</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/中间态.png" alt="img"></p>
</li>
<li><p>复合状态</p>
</li>
<li><p>消息</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/状态图消息.png" alt="img"></p>
</li>
</ul>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/支票状态图.JPG" alt="img"></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/存款过程状态图.png" alt="img"></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/电梯状态图.JPG" alt="img"></p>
<h4 id="活动图（动态）"><a href="#活动图（动态）" class="headerlink" title="活动图（动态）"></a>活动图（动态）</h4><p>用来捕捉用例的活动，使用框图的方式显示动作及其结果</p>
<p>活动图是一种流图，描述了从活动到活动的流</p>
<p>是另一种描述交互的方式，描述采取何种动作，动作的结果是什么（动作改变状态），何时发生（动作序列），在何处发生（泳道）</p>
<h5 id="事务-2"><a href="#事务-2" class="headerlink" title="事务"></a>事务</h5><p><strong>起点</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/初态.png" alt="img"></p>
<p><strong>终点</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/终态.png" alt="img"></p>
<p><strong>活动</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图活动.png" alt="img"></p>
<p>动作的执行</p>
<p><strong>对象流</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图对象流.png" alt="img"></p>
<p>活动之间交换的信息</p>
<p><strong>发送信号</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/发送信号.png" alt="img"></p>
<p>活动过程中发送的事件，触发另一伙的流程</p>
<p><strong>接收信号</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图接收信号.png" alt="img"></p>
<p>活动过程中接收的事件，接收到信号的活动流程序开始执行</p>
<p><strong>泳道</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图泳道.png" alt="img"></p>
<p>活动的负责者</p>
<h5 id="关系-2"><a href="#关系-2" class="headerlink" title="关系"></a>关系</h5><p><strong>迁移</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图迁移.png" alt="img"></p>
<p>活动的完成与新活动的开始</p>
<p><strong>分支</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图分支.png" alt="img"></p>
<p>根据条件，控制执行方向</p>
<p><strong>分叉</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图分叉.png" alt="img"></p>
<p>以下的活动可并发执行</p>
<p><strong>结合</strong></p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图结合.png" alt="img"></p>
<p>以上的并发活动在此结合</p>
<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/活动图取款.JPG" alt="img"></p>
<h4 id="构件图（静态）"><a href="#构件图（静态）" class="headerlink" title="构件图（静态）"></a>构件图（静态）</h4><p>描述构建之间的依赖关系，是面向对象思想的核体现</p>
<p>构建是逻辑交给中定义的概念和功能（如类、对象与关系），在物理架构中的实现</p>
<p>构件图中包含三种元素，构件、接口和关系，描述了系统各个构件终点依赖关系，构件接口以及调用关系，可以使用包来组织，使用注解与约束来解释和限定</p>
<h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/构件图.JPG" alt="img"></p>
<h4 id="部署图（配置图-静态）"><a href="#部署图（配置图-静态）" class="headerlink" title="部署图（配置图 静态）"></a>部署图（配置图 静态）</h4><p>描述处理器、设备和连接，显示系统硬件的物理拓扑结构及在此结构上执行的软件，每个系统只有一个部署图</p>
<p>部署图可以显示计算节点的拓扑结构和通信路径、节点上运行的软件以及软件包含的逻辑单元。</p>
<h5 id="部署图与对象图"><a href="#部署图与对象图" class="headerlink" title="部署图与对象图"></a>部署图与对象图</h5><p>部署图编写构件实例</p>
<p>构件图表现构件类型的定义</p>
<p>部署图偏向于描述构件在结点中运行时的状态，描述了构件运行的环境</p>
<p>构件图偏向于描述构件之间相互依赖支持的基本关系</p>
<h5 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h5><p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/部署图.JPG" alt="img"></p>
<h4 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h4><p>类图变化而来，显示一组对象和他们之间的关系</p>
<p><img src="/2020/01/05/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/对象图.JPG" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">算法设计与分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 22:32:07" itemprop="dateCreated datePublished" datetime="2019-12-25T22:32:07+08:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%BD%92%E7%BA%B3/" itemprop="url" rel="index"><span itemprop="name">理论归纳</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h3><h4 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h4><p>算法是一些列解决问题的清晰指令，即对符合一定规范的输入，能够在有限时间内获得所要求的输出</p>
<p><strong>算法的性质</strong></p>
<ul>
<li>输入：有0个或多个输入</li>
<li>输出：至少一个输出</li>
<li>确定性：每条指令清晰无歧义</li>
<li>有限性： 每条指令执行次数有限</li>
</ul>
<h4 id="和程序的区别"><a href="#和程序的区别" class="headerlink" title="和程序的区别"></a>和程序的区别</h4><p>程序是算法用某种程序设计语言的具体实现，可以不满足有限性（操作系统）</p>
<h4 id="算法分析的两个方面"><a href="#算法分析的两个方面" class="headerlink" title="算法分析的两个方面"></a>算法分析的两个方面</h4><ul>
<li>时间复杂性分析</li>
<li>空间复杂性分析</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="算法复杂性分析"><a href="#算法复杂性分析" class="headerlink" title="算法复杂性分析"></a>算法复杂性分析</h4><h5 id="代码段的时间复杂性"><a href="#代码段的时间复杂性" class="headerlink" title="代码段的时间复杂性"></a>代码段的时间复杂性</h5><ul>
<li>输入规模度量</li>
<li>运行时间度量<ul>
<li>使用秒、毫秒作为运行时间度量单位<ul>
<li>特定计算机困难</li>
<li>计时困难</li>
</ul>
</li>
<li>计算每一步操作的执行次数<ul>
<li>记录困难</li>
<li>没有必要</li>
</ul>
</li>
<li>基本操作执行次数</li>
</ul>
</li>
</ul>
<h5 id="时间效率的排序"><a href="#时间效率的排序" class="headerlink" title="时间效率的排序"></a>时间效率的排序</h5><script type="math/tex; mode=display">
1 < n <\ nlog_2n<\ n^2<\ n^3<\ 2^n<\ n!</script><p>算法的三种效率</p>
<ul>
<li>最优效率</li>
<li>最差效率</li>
<li>平均效率</li>
</ul>
<h4 id="三种渐进符号的定义及应用"><a href="#三种渐进符号的定义及应用" class="headerlink" title="三种渐进符号的定义及应用"></a>三种渐进符号的定义及应用</h4><ul>
<li><p>O： 渐进上界</p>
<p>①  O(f)+O(g)=O(max(f,g))</p>
<p>②  O(f)+O(g)=O(f+g)</p>
<p>③  O(f)O(g)=O(fg)</p>
<p>④  如果g(N)=O(f(N))，则O(f)+O(g)=O(f)</p>
<p>⑤  O(Cf(N))=O(f(N))，其中C是一个正的常数</p>
<p>⑥  f=O(f)</p>
</li>
<li><p>$\Omega$：渐进下界</p>
</li>
<li><p>$\Theta$：在范围内</p>
</li>
</ul>
<h4 id="利用极限比较增长次数"><a href="#利用极限比较增长次数" class="headerlink" title="利用极限比较增长次数"></a>利用极限比较增长次数</h4><p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/极限比较增长次数.JPG" alt="img"></p>
<h4 id="非递归算法的复杂性分析（输入规模、基本操作）"><a href="#非递归算法的复杂性分析（输入规模、基本操作）" class="headerlink" title="非递归算法的复杂性分析（输入规模、基本操作）"></a>非递归算法的复杂性分析（输入规模、基本操作）</h4><ul>
<li>决定输入规模</li>
<li>找出基本操作</li>
<li>检测基本操作执行次数</li>
<li>建立执行次数的求和表达式</li>
<li>利用求和运算标准公式和法则求解 至少确定增长次数</li>
</ul>
<h4 id="递归算法的复杂性分析"><a href="#递归算法的复杂性分析" class="headerlink" title="递归算法的复杂性分析"></a>递归算法的复杂性分析</h4><h5 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h5><p>设序列a0,a1,a2,…,an,…，简记为{an},若有一个等式将an与某些个ai(i&lt;n)联系起来，那么就称该等式为关于序列{an}的递推式。</p>
<h5 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h5><p>递归式是递推式的一种</p>
<p>如自然数 $a_n=n$</p>
<p>递推式$a_{n+1}=a_n+1$</p>
<p>递归式$a<em>{n+2} = 2a</em>{n+1}-a_n$</p>
<h5 id="常用解题方法（反向替换法）"><a href="#常用解题方法（反向替换法）" class="headerlink" title="常用解题方法（反向替换法）"></a>常用解题方法（反向替换法）</h5><ol>
<li><p>将递推式中的X(n)表示为X(n-i)的函数；</p>
</li>
<li><p>选择 i 的值，使n-i落入初始条件的定义域；</p>
</li>
<li><p>用闭合公式表示</p>
</li>
</ol>
<p>由的第一项开始向后推理</p>
<p>我们求得递推式：</p>
<p>X(n) = X(n-i)+((n-i+1)+…+n)</p>
<p>因为X(0) = 0, 所以 n-i = 0, i = n</p>
<p>故递推式的闭合公式：<br>     X(n) = X(n-n) + (1+…+n)=X(0)+n(n+1)/2<br>X(n) = n(n+1)/2 </p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/反向替换法.JPG" alt="img"></p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h3 id="分治法的基本思想"><a href="#分治法的基本思想" class="headerlink" title="分治法的基本思想"></a>分治法的基本思想</h3><p>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>特征</p>
<ul>
<li>可以分为若干相同问题</li>
<li>子问题容易解决</li>
<li>子问题的解可以合并为原问题的解</li>
<li>子问题相互独立（不独立用dp）</li>
</ul>
<h3 id="分治算法设计模型"><a href="#分治算法设计模型" class="headerlink" title="分治算法设计模型"></a>分治算法设计模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">问题结果 solve(P)&#123;	<span class="comment">// 分治函数</span></span><br><span class="line">    <span class="keyword">if</span>(达到可以运算的条件)</span><br><span class="line">        运算;</span><br><span class="line">    将现在的问题划分为K个子问题;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">     	子问题结果 = solve(第i个子问题); 	<span class="comment">// 递归求解子问题</span></span><br><span class="line">    	将子问题结果合并为当前问题结果</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> 当前问题结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么引入平衡子问题"><a href="#为什么引入平衡子问题" class="headerlink" title="为什么引入平衡子问题"></a>为什么引入平衡子问题</h3><p>平衡子问题：将一个问题分为<strong>大小相等</strong>的K个子问题</p>
<p>引入的原因是因为经验得出它总是比子问题规模不等的做法好</p>
<h3 id="分治法的算法复杂性分析"><a href="#分治法的算法复杂性分析" class="headerlink" title="分治法的算法复杂性分析"></a>分治法的算法复杂性分析</h3><h4 id="递归式各项的含义"><a href="#递归式各项的含义" class="headerlink" title="递归式各项的含义"></a>递归式各项的含义</h4><p>阶乘递归式</p>
<script type="math/tex; mode=display">
n!= \left\{ \begin{aligned} 1  \ \ \ \ n=0 \\  n(n-1)\ \ \ \ n > 0\end{aligned} \right.\\</script><h4 id="Master定理"><a href="#Master定理" class="headerlink" title="Master定理"></a>Master定理</h4><script type="math/tex; mode=display">
T(n)= \left\{ \begin{aligned} O(1)  \ \ \ \ n=1 \\ kT(\frac nm)+f(n)\ \ \ \ \ n > 1\end{aligned} \right.\\
通过迭代方程求得方程的解：
\\
T(n)= n^{log_mk}+\sum {log_mn-1 \atop j=0} k^jf(\frac{n}{m^j})</script><p>求解$T(n)=aT(\frac nb)+f(n)$使用$f(n)与n^{log_ba}比较$</p>
<ul>
<li>若$n^{log_ba}大，则T(n)=\theta(n^{log_ba})$</li>
<li>若f(n)大，则$T(n)=\theta(f(n))$</li>
<li>若同阶，则$T(n)=\theta(n^{log_ba}logn)=\theta(f(n)logn)$</li>
</ul>
<p>无法应用情况（非多项式大于或小于）</p>
<p>求解$T(n)=2T(n/2)+nlogn$的渐进式</p>
<script type="math/tex; mode=display">
a = 2, b = 2\\
n^{log_ba} = n^{log_22} = n\\
f(n)=nlogn\\
n^{log_ba}非多项式小于f(n)，不能使用master定理\\
推导法:\\
T(n) = 2T(\frac n2)+nlogn\\
= 2^{2}T(\frac n {2^2}) + nlog(\frac n2) + nlogn\\
= 2^{logn}T(1) + nlog1+...+nlog(\frac n2) + nlogn\\
= n + nlog1 + ... + nlog(\frac n2) + nlogn\\
= O(nlognlogn)</script><h3 id="应用题目"><a href="#应用题目" class="headerlink" title="应用题目"></a>应用题目</h3><h4 id="大整数乘法、矩阵相乘的时间复杂度分析"><a href="#大整数乘法、矩阵相乘的时间复杂度分析" class="headerlink" title="大整数乘法、矩阵相乘的时间复杂度分析"></a>大整数乘法、矩阵相乘的时间复杂度分析</h4><ul>
<li><p>大数乘法 $X\times Y$</p>
<p>将每个大数等分为两份</p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/大数乘法_1.JPG" alt="img"></p>
<p>$X\times Y = (A\times10^{\frac n2} + B)(C\times10^{\frac n2} + D)$</p>
<p>$ = A\times C \times 10^n + (AD + BC)\times 10^{\frac n2} + B \times D$</p>
<p>产生四个子问题 $A\times C、A \times D、B\times C、B\times D$</p>
<p>继续化简</p>
<p>$= A\times C\times 10^n + ((A+B)(A+C) - A\times C - B\times D)10^{\frac n2}+B\times D$</p>
<p>只产生三个子问题</p>
<p>递归式：</p>
<p>$T(n)= \left { \begin{aligned}\theta(1) \ \ \ \ n = 1\3T(\frac n2)+n\ \ \ \ n &gt; 1 \end{aligned}  \right.$</p>
<p>master定理求解</p>
<p>a = 3 b = 2</p>
<p>$n^{log3} &gt; n$</p>
<p>$O(n^{log_3})$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* ClassName:BigNum</span></span><br><span class="line"><span class="comment">* Description: 存储大数</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@num	大数具体值（为了方便运算采取低位在前的存储方式）</span></span><br><span class="line"><span class="comment">* 	@len	大数位数</span></span><br><span class="line"><span class="comment">* 	@BigNum	无参构造，将其初始化为0</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigNum</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num[maxn];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    BigNum()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* FunctionName: rmZero</span></span><br><span class="line"><span class="comment">* Description: 在传入大数前方去除0</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要去除0的大数</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rmZero</span><span class="params">(BigNum &amp;a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a.len - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; a.num[a.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        a.len--;<span class="comment">//去除最高位的0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* FunctionName: addAfterZero</span></span><br><span class="line"><span class="comment">* Description: 在传入大数后方添加0</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要添加0的大数</span></span><br><span class="line"><span class="comment">*   @l  要添加0的数量</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回添加0后的BigNum</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">addAfterZero</span><span class="params">(BigNum a, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[maxn];</span><br><span class="line">    BigNum res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num + l, a.num, <span class="keyword">sizeof</span>(a.num));</span><br><span class="line">    res.len = l + a.len;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* FunctionName: addBeforeZero</span></span><br><span class="line"><span class="comment">* Description: 在传入大数前方添加0</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要添加0的大数</span></span><br><span class="line"><span class="comment">*   @l  要添加0的数量</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回添加0后的BigNum</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">addBeforeZero</span><span class="params">(BigNum a, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[maxn];</span><br><span class="line">    BigNum res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        tmp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num, a.num, <span class="keyword">sizeof</span>(a.num));</span><br><span class="line">    <span class="built_in">memcpy</span>(res.num + a.len, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    res.len = l + a.len;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* FunctionName: subBigNum</span></span><br><span class="line"><span class="comment">* Description: 大数截取</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	要被截取的大数</span></span><br><span class="line"><span class="comment">*   @bg 开始截取的位置</span></span><br><span class="line"><span class="comment">*   @l  截取的长度</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回截取后的BigNum</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">subBigNum</span><span class="params">(BigNum a, <span class="keyword">int</span> bg, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    BigNum res;</span><br><span class="line">    res.len = l;</span><br><span class="line">    <span class="keyword">int</span> tmp = l<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - bg; i &gt; a.len - bg - l; i--)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "i:" &lt;&lt; i &lt;&lt; " a.num[i]:" &lt;&lt; a.num[i] &lt;&lt; endl;</span></span><br><span class="line">        res.num[tmp--] = a.num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* FunctionName: multi_2</span></span><br><span class="line"><span class="comment">* Description: 大数乘法（分治）</span></span><br><span class="line"><span class="comment">* Parameter:</span></span><br><span class="line"><span class="comment">* 	@a	乘数1</span></span><br><span class="line"><span class="comment">*   @b  乘数2</span></span><br><span class="line"><span class="comment">* Return:</span></span><br><span class="line"><span class="comment">*   返回相乘后的BigNum</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="function">BigNum <span class="title">multi_2</span><span class="params">(BigNum a, BigNum b)</span></span>&#123;</span><br><span class="line">    BigNum c;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>; <span class="comment">// 计算当前大数长度</span></span><br><span class="line">    <span class="keyword">if</span>(a.len &gt; <span class="number">2</span> || b.len &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        n = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &lt; a.len || n &lt; b.len)	<span class="comment">// n一直乘二直到n大于两数中较长者的长度</span></span><br><span class="line">            n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 在大数前方补零直至两者长度都为n</span></span><br><span class="line">        a = addBeforeZero(a, n - a.len);	</span><br><span class="line">        b = addBeforeZero(b, n - b.len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为一则证明当前n依旧为2 将两数长度补至二</span></span><br><span class="line">    <span class="keyword">if</span>(a.len == <span class="number">1</span>)  a = addBeforeZero(a, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(b.len == <span class="number">1</span>)  b = addBeforeZero(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;	<span class="comment">// 当前长度为2</span></span><br><span class="line">        <span class="keyword">int</span> inta = <span class="number">0</span>, intb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 用inta记录第一个数</span></span><br><span class="line">            inta += a.num[i];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                inta *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = b.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 用intb记录第二个数</span></span><br><span class="line">            intb += b.num[i];</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                intb *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> inttmp = inta * intb;	<span class="comment">// 两数相乘</span></span><br><span class="line">        <span class="built_in">string</span> tmp;	<span class="comment">// 将整数转为字符串 当然如果环境支持c11以上也可以直接使用std::itos</span></span><br><span class="line">        <span class="built_in">stringstream</span> sst;</span><br><span class="line">        sst &lt;&lt; inttmp;</span><br><span class="line">        sst &gt;&gt; tmp;</span><br><span class="line">        c = change(tmp); <span class="comment">// 将当前两数乘积转为大数c</span></span><br><span class="line">        <span class="keyword">return</span> c;	<span class="comment">// 返回大数c</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 长度大于二</span></span><br><span class="line">        BigNum a0, a1, b0, b1, c0, c1, c2;</span><br><span class="line">        a1 = subBigNum(a, <span class="number">1</span>, (n/<span class="number">2</span>)); <span class="comment">// a1为大数a的后半部分（我上方大数类中为了方便运算逆序存储）</span></span><br><span class="line">        a0 = subBigNum(a, (n/<span class="number">2</span>+<span class="number">1</span>), a.len - (n/<span class="number">2</span>) );<span class="comment">// a0为大数a的前半部分</span></span><br><span class="line">        <span class="comment">// b0 b1同理</span></span><br><span class="line">        b1 = subBigNum(b, <span class="number">1</span>, (n/<span class="number">2</span>));</span><br><span class="line">        b0 = subBigNum(b, (n/<span class="number">2</span>+<span class="number">1</span>), b.len - (n/<span class="number">2</span>));</span><br><span class="line">        c2 = multi_2(a1, b1); </span><br><span class="line">        c0 = multi_2(a0, b0);</span><br><span class="line">        c1 = sub(multi_2(add(a0,a1),add(b0,b1)),add(c2, c0));</span><br><span class="line">        c2 = addAfterZero(c2, n);</span><br><span class="line">        c1 = addAfterZero(c1, n / <span class="number">2</span>);</span><br><span class="line">        c = add(add(c2, c1), c0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵乘法</p>
<p>n$\times$n的矩阵A和B的乘积矩阵C中的元素C[i][j]</p>
<p>$C[i][j]=\sum{n \atop k=1}A[i][k]B[k][j]$</p>
<p>将A B C三个矩阵都分为上下左右四块</p>
<script type="math/tex; mode=display">
[ \begin{aligned}C_{11} \ C_{12}\\C_{21}\ C_{22}  \end{aligned}] = [ \begin{aligned}A_{11} \ B_{12}\\A_{21}\ A_{22}  \end{aligned}][ \begin{aligned}B_{11} \ B_{12}\\B_{21}\ B_{22}  \end{aligned}]\\
C_{11}=A_{11}B_{11} + A_{12}B_{12}\\
C_{12}=A_{11}B_{12} + A_{12}B_{22}\\
C_{11}=A_{21}B_{11} + A_{22}B_{21}\\
C_{11}=A_{21}B_{12} + A_{22}B_{22}</script><p>分治法最终可以将问题转换为7个矩阵连乘小问题</p>
<script type="math/tex; mode=display">
M_1 = A_{11}(B_{12}-B_{22})\\
M_2 = (A_{11} + A_{12})B_{22}\\
M_3 = (A_{21} + A_{22})B_{11}\\
M_4 = A_{22}(B_{21} - B_{11})\\
M_5 = (A_{11}+A_{22})(B_{11} + B_{22})\\
M_6 = (A_{12}+A_{22})(B_{21} + B_{22})\\
M_7 = (A_{11}+A_{21})(B_{11} + B_{12})</script><p>时间复杂度分析</p>
<script type="math/tex; mode=display">
T(n) = \left \{ \begin{aligned} O(1)\ \ \ \ n = 2\\7T(\frac n2) + O(n^2)\ \ \ \ n > 2\end{aligned} \right.</script><p>由master定理计算</p>
<p>a = 7 b = 2</p>
<p>$n^{log7} &gt; n^2$</p>
<p>所以复杂度为$n^{log7}$</p>
</li>
</ul>
<h4 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h4><h5 id="快速排序思想"><a href="#快速排序思想" class="headerlink" title="快速排序思想"></a>快速排序思想</h5><h5 id="快排的一趟实现过程"><a href="#快排的一趟实现过程" class="headerlink" title="快排的一趟实现过程"></a>快排的一趟实现过程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[选取哨兵点temp] --&gt; B[左侧指针left与右侧指针right由两端开始向中间遍历到两者相遇为止]</span><br><span class="line">B --&gt; C[视排序方式而定遍历过程中每出现一个right &lt; left 或 left &lt; right 就将两者对应值交换]</span><br><span class="line">C --&gt; D[交换哨兵与left right相遇点的值]</span><br><span class="line">D --&gt; E[以相遇点为界递归解决相遇点左侧与右侧的排序子问题]</span><br></pre></td></tr></table></figure>
<h5 id="快排的时间复杂度分析（最好、最坏）"><a href="#快排的时间复杂度分析（最好、最坏）" class="headerlink" title="快排的时间复杂度分析（最好、最坏）"></a>快排的时间复杂度分析（最好、最坏）</h5><ul>
<li><p>最坏情况</p>
<p>对应排序数组以基本有序（所有分裂点都为极端情况），若不考虑随机主元的情况，每次只能走进一个子问题中，哨兵以每次递归一个单位的速度移动</p>
<p>时间复杂度</p>
<p>$T(n)=\left { \begin{aligned} O(1) \ \ \ \ n &lt;= 1 \ T(n-1) + n \ \ \ \ n&gt;1\end{aligned} \right.$</p>
<p>$O(n^2)$</p>
</li>
<li><p>最好情况 </p>
<p>所有分裂点都位于相应子数组的中点</p>
<p>$T(n) = \left { \begin{aligned} O(1) \ \ \ \ n &lt;= 1 \ 2T(\frac n2) + n \ \ \ \ n &gt; 1 \end{aligned} \right.$</p>
<p>$a = 2 \ b = 2 \ f(n) = n$</p>
<p>$n^{log2} = n = f(n)$</p>
<p>$O(nlogn)$</p>
</li>
</ul>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* @File: 快速排序</span></span><br><span class="line"><span class="comment">* @Author: suvvm</span></span><br><span class="line"><span class="comment">* @blog: www.suvvm.work</span></span><br><span class="line"><span class="comment">* @github: https://github.com/suvvm</span></span><br><span class="line"><span class="comment">* @email: suvvm@foxmail.com</span></span><br><span class="line"><span class="comment">* @Version: 1.0.2</span></span><br><span class="line"><span class="comment">* @Date: 2019-11-15</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void quicksort(int left,int right) // 非随机主元</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	int i,j,t,temp;</span></span><br><span class="line"><span class="comment">	if(left&gt;right)</span></span><br><span class="line"><span class="comment">	return;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	temp=a[left];</span></span><br><span class="line"><span class="comment">	i=left;</span></span><br><span class="line"><span class="comment">	j=right;</span></span><br><span class="line"><span class="comment">	while(i!=j)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		while(a[j]&gt;=temp&amp;&amp;i&lt;j)</span></span><br><span class="line"><span class="comment">		j--;</span></span><br><span class="line"><span class="comment">		while(a[i]&lt;=temp&amp;&amp;i&lt;j)</span></span><br><span class="line"><span class="comment">		i++;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		if(i&lt;j)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			t=a[i];</span></span><br><span class="line"><span class="comment">			a[i]=a[j];</span></span><br><span class="line"><span class="comment">			a[j]=t;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	a[left]=a[i];</span></span><br><span class="line"><span class="comment">	a[i]=temp;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	quicksort(left,i-1);</span></span><br><span class="line"><span class="comment">	quicksort(i+1,right);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time( <span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//产生随机数组下标</span></span><br><span class="line">        <span class="keyword">int</span> k = left + rand()%(right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//仍然将随机的枢轴交换到最后</span></span><br><span class="line">        exchange(a[right],a[k]);</span><br><span class="line">        temp=a[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= left; j &lt;= right - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;=temp)</span><br><span class="line">            &#123;</span><br><span class="line">                i = i+<span class="number">1</span>;</span><br><span class="line">                exchange(a[i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后主元交换</span></span><br><span class="line">        exchange(a[i + <span class="number">1</span>],a[right]);</span><br><span class="line">        <span class="keyword">int</span> r = i + <span class="number">1</span>;</span><br><span class="line">        quicksort(left, r - <span class="number">1</span>);</span><br><span class="line">        quicksort(r+<span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	quicksort(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线性选择问题"><a href="#线性选择问题" class="headerlink" title="线性选择问题"></a>线性选择问题</h4><h5 id="什么是选择（线性选择）问题"><a href="#什么是选择（线性选择）问题" class="headerlink" title="什么是选择（线性选择）问题"></a>什么是选择（线性选择）问题</h5><p>给定线性序集中n个元素要求选择给定条件的某个元素。</p>
<h5 id="线性选择问题的步骤"><a href="#线性选择问题的步骤" class="headerlink" title="线性选择问题的步骤"></a>线性选择问题的步骤</h5><ol>
<li>列出约束条件确定可行域</li>
<li>排序</li>
<li>求解</li>
</ol>
<h5 id="中位数的中位数作用？"><a href="#中位数的中位数作用？" class="headerlink" title="中位数的中位数作用？"></a>中位数的中位数作用？</h5><p>中位数是一个非常重要的统计量，可以避免最大值最小值的干扰。例如：海量数据中统计中间工资、中间年龄等 </p>
<h5 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h5><p>与所选排序算法有关</p>
<p>线性时间选择最坏O(n)</p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/线性时间选择.JPG" alt="img"></p>
<h4 id="最接近点对问题"><a href="#最接近点对问题" class="headerlink" title="最接近点对问题"></a>最接近点对问题</h4><h5 id="什么是最接近点对问题"><a href="#什么是最接近点对问题" class="headerlink" title="什么是最接近点对问题"></a>什么是最接近点对问题</h5><p>给定平面上n个点（xi，yi）（1≤i≤n），要求找出其中的一对点，使得在 n 个点组成的所有点对中，该点对间的距离d最小</p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/欧氏距离.JPG" alt="img"></p>
<h5 id="利用分治法解题的过程"><a href="#利用分治法解题的过程" class="headerlink" title="利用分治法解题的过程"></a>利用分治法解题的过程</h5><ul>
<li>将点集分成大致相等的两部分$S_1 S_2$</li>
<li>递归分别求解$S_1 S_2$中的最近对的值$d_1 d_2$</li>
<li>求出一点在$S<em>1$中另一点在$S_2$中的最近点对$d</em>{pq}$</li>
<li>原问题的解$d=min{d<em>1, d_2, d</em>{pq}}$</li>
</ul>
<h6 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h6><p>所有点按x坐标排序，找到第$\frac n2$个点作垂直直线l，把n个点分为$S<em>1 \ S_2$两个子集之后递归便可求得一个临时最短距离$d = min{d_1,d_2}$ 再考虑$d</em>{pq}$ 若在$S_1$中选取p 将会出现以下情况</p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/最接近点对.JPG" alt="img"></p>
<p>之后将所有点按x由小到大 y由小到大进行预处理</p>
<p>对于在l左边$S_1$中d范围内的每个点检测对于右侧$S_2$中检测d范围内的点求出最小值。</p>
<h5 id="鸽笼定理的作用体现在哪儿"><a href="#鸽笼定理的作用体现在哪儿" class="headerlink" title="鸽笼定理的作用体现在哪儿"></a>鸽笼定理的作用体现在哪儿</h5><p>根据鸽笼定理可以确定上述d$\times$2d的矩形中最多只能有6个对应候选点</p>
<p>因为将d$\times$2d的矩形长三等分宽二等分 可以得出6个$\frac d2 \times \frac {2\times d}3$的矩形</p>
<p>若超过6个候选点，必定有一个矩形中会有2个以上的候选点 在同一矩形内的候选点之间距离必定小于d，与我们之前所求产生了冲突，所以最多只有6个候选点。</p>
<h5 id="算法效率-1"><a href="#算法效率-1" class="headerlink" title="算法效率"></a>算法效率</h5><p>时间复杂度分析</p>
<p>$T(n) = \left { \begin{aligned} O(1) \ \ \ \ n<4 \\ 2t(\frac n2)+o(n) \ n>=4 \end{aligned} \right.$</4></p>
<p>$a = 2 \ b = 2$</p>
<p>$n^{log_22} = n = n$</p>
<p>时间复杂度$ O(nlogn)$</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="动态规划的基本思想"><a href="#动态规划的基本思想" class="headerlink" title="动态规划的基本思想"></a>动态规划的基本思想</h3><p>将待求子问题分解成若干子问题，先求解子问题再结合这些子问题的解得到原问题的解。</p>
<p>备忘录思想 当dp[i]的值被计算后，保存它的值，当再次计算dp[i]时只需要从表中取出即可。</p>
<h4 id="与分治法的相同点与不同点"><a href="#与分治法的相同点与不同点" class="headerlink" title="与分治法的相同点与不同点"></a>与分治法的相同点与不同点</h4><h5 id="DP与分治的相同点"><a href="#DP与分治的相同点" class="headerlink" title="DP与分治的相同点"></a>DP与分治的相同点</h5><ul>
<li><p>都把原问题分为子问题来求解</p>
</li>
<li><p>都存在递推关系</p>
</li>
</ul>
<h5 id="DP与分治的不同点"><a href="#DP与分治的不同点" class="headerlink" title="DP与分治的不同点"></a>DP与分治的不同点</h5><ul>
<li>子问题不独立时如果用分治法求解相同问题，子问题数目太多，且计算量大——指数级</li>
<li>在DP中通常用表记录子问题的解，以便保存方便以后的计算，DP由最简单的问题开始填起自底向上填表，最终得到原问题答案，保证了在求解一个子问题时，所有与子问题的子问题都已经得到计算并可以在表中查到。</li>
</ul>
<h4 id="两个重要性质-基本要素"><a href="#两个重要性质-基本要素" class="headerlink" title="两个重要性质/基本要素"></a>两个重要性质/基本要素</h4><ul>
<li><p>最优子结构</p>
<p>一个问题的最优解包含在子问题的最优解</p>
<ul>
<li>最优子结构保证了DP的正确性</li>
<li>最优子结构帮助缩小了子问题规模，只需最优问题中包含的子问题，避免了无用子问题的计算</li>
<li>最优子结构使得我们能自底向上地完成求解过程，下面计算的结果上面一定能用到</li>
</ul>
</li>
<li><p>重叠子问题</p>
<p>在问题求解过程中，很多子问题的解将被多次使用，DP能加速问题的求解效果</p>
</li>
</ul>
<h4 id="解题的步骤"><a href="#解题的步骤" class="headerlink" title="解题的步骤"></a>解题的步骤</h4><ul>
<li>刻画最优子结构(确定是否能用DP做 最优子结构 + 重叠子问题)</li>
<li>递归定义最优解的值</li>
<li>自底向上计算原问题最优解</li>
<li>根据计算最优值时得到的信息构造最优解</li>
</ul>
<h3 id="应用题目-1"><a href="#应用题目-1" class="headerlink" title="应用题目"></a>应用题目</h3><h4 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h4><p>给定n个可乘的数字矩阵 $A<em>1, A_2,…, A_n $，矩阵 $A_i $ 的规模为 $p</em>{i-1}\times p_i $ 求给定矩阵连乘的最优计算次序，使得计算乘积 $A_1\times A_2 \times … \times A_n $ 所需执行的数乘次数最少.</p>
<h5 id="解题过程-填表过程"><a href="#解题过程-填表过程" class="headerlink" title="解题过程/填表过程"></a>解题过程/填表过程</h5><p>假设 $A_1\times A_2 \times … \times A_n$ 的最优计算次序会在$A_k$时断开（只是打个比方，就像上方图计算 $A_1 \times A_2 \times A_3 \times A_4$ 时在 $A_1$ 处断开成为 $A_1与A_2 \times (A_3\times A_4)$ 一样）这时对最优计算次序的计算也会断开成为两个子问题 </p>
<script type="math/tex; mode=display">
\left\{ \begin{aligned} 子问题1 & = & 求A_1\times A_2 \times ... \times A_k 的最优计算次序\\ 子问题2 & = & 求A_{k+1}\times A_{k+2} \times ... \times A_n 的最优计算次序\end{aligned} \right.</script><p>而子问题解决后会得到两个矩阵，若想得到原问题最优解则需要加上两子问题矩阵相乘所需的乘法次数。</p>
<p><strong>最优子结构性质</strong></p>
<p>假设n个矩阵 $ A<em>1\times A_2 \times … \times A_n $ 连乘的最优加括号方案为(solve(1~k))(solve(k+1~n))则solve(1~k)肯定为子问题 $A_1 \times A_2 \times A_k $ 的最优解，solve(k+1~n)肯定为子问题 $ A_k \times A</em>{k+1} \times A_n $ 的最优解</p>
<p>P数组：矩阵维度 由于矩阵乘法中前一矩阵的列数等于后一矩阵的行数所以如果P[i]代表第i矩阵的行数，它还可以代表第i + 1矩阵的列数。</p>
<p>子问题矩阵相乘所需的乘法次数 = 子问题1矩阵的行数（A1的行数） $\times$ 子问题2矩阵的列数（An的列数） $\times$ 计算结果矩阵一个元素所需的乘法次数（Ak+1的行数 或Ak的列数）</p>
<p>状态转移方程</p>
<script type="math/tex; mode=display">
dp[i][j]=\left\{ \begin{aligned} 0(i = j )\\ dp[i][k]+dp[k+1][j]+p_{i-1} \times p_j \times p_k(i < j)\end{aligned} \right.</script><p><strong>自低向上的计算方式</strong></p>
<ul>
<li><p>dp初始状态：一个矩阵相乘dp[i][i]=0</p>
</li>
<li><p>计算所有两矩阵 $A<em>i \times A</em>{i+1}$ 相乘的最优值dp[i][i+1]</p>
</li>
<li><p>按矩阵链长增长，依次计算：</p>
<p>3个矩阵相乘</p>
<p>4个矩阵相乘</p>
<p>…</p>
<p>n个矩阵相乘</p>
</li>
</ul>
<p>填表方式</p>
<p>$(x,y) = min<em>{x &lt;= k &lt; y}((x,k) + (k+1,y)+P</em>{x-1}P_kP_y)$</p>
<p>填表习题</p>
<p>计算矩阵连乘乘积最少乘法次数 $A_1 \times A_2 \times A_3 \times A_4 \times A_5 \times A_6$ </p>
<p>维度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A1</th>
<th>A2</th>
<th>A3</th>
<th>A4</th>
<th>A5</th>
<th>A6</th>
</tr>
</thead>
<tbody>
<tr>
<td>30$\times$35</td>
<td>35$\times$15</td>
<td>15$\times$5</td>
<td>5$\times$10</td>
<td>10$\times$20</td>
<td>20$\times$25</td>
</tr>
</tbody>
</table>
</div>
<p>P数组 = [30, 35, 15, 5, 10, 20, 25]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>15750‬</td>
<td>7875(1 23)</td>
<td>9375(123 4)‬</td>
<td>11875‬(123 45)</td>
<td>15125(123 456)‬</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td></td>
<td>0</td>
<td>2625</td>
<td>4375(23 4)</td>
<td>7125(23 45)</td>
<td>10500(23 456)</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td></td>
<td></td>
<td>0</td>
<td>750</td>
<td>2500(3 45)</td>
<td>5375(3 456)</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>1000</td>
<td>3500(45 6)</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>5000</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h5 id="如何还原最优解-加括号过程的最终方案"><a href="#如何还原最优解-加括号过程的最终方案" class="headerlink" title="如何还原最优解/加括号过程的最终方案"></a>如何还原最优解/加括号过程的最终方案</h5><p>使用s[i][j]记录矩阵i到j连乘最优断开点</p>
<p>假设s[i][j] = k 表明i到j连乘在k处分开，分为 i到k 与 k+1到j</p>
<p>之后去查询s[i][k]与s[k+1][j] 以此递推，自顶向下构造完全加括号方式</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* @File: 矩阵连乘问题</span></span><br><span class="line"><span class="comment">* @Author: suvvm</span></span><br><span class="line"><span class="comment">* @blog: www.suvvm.work</span></span><br><span class="line"><span class="comment">* @github: https://github.com/suvvm</span></span><br><span class="line"><span class="comment">* @email: suvvm@foxmail.com</span></span><br><span class="line"><span class="comment">* @Version: 1.0.1</span></span><br><span class="line"><span class="comment">* @Date: 2019-11-27</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">// m[i][j]保存i到j的最小乘法次数 s[i][j]保存i到j的断点</span></span><br><span class="line"><span class="keyword">int</span> p[MAXN];</span><br><span class="line"><span class="keyword">int</span> minN[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> s[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;   <span class="comment">// 遍历连乘长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - len + <span class="number">1</span>; i++) &#123;	<span class="comment">// 遍历起点</span></span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 直接计算所需次数</span></span><br><span class="line">            minN[i][j] = minN[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123; <span class="comment">// 遍历断点k</span></span><br><span class="line">                <span class="keyword">int</span> tCnt = minN[i][k] + minN[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[k] * p[j]; <span class="comment">// 状态转移方程</span></span><br><span class="line">                <span class="keyword">if</span>(tCnt &lt; minN[i][j]) &#123;    <span class="comment">// 乘法次数可被优化</span></span><br><span class="line">                    minN[i][j] = tCnt;</span><br><span class="line">                    s[i][j] = k;	<span class="comment">// 更新i到j的断点记录</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;<span class="string">"A"</span> &lt;&lt; i;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">	print(i , s[i][j]);</span><br><span class="line">	print(s[i][j] + <span class="number">1</span>, j);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入m:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入n:"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入矩阵对应行数与最后矩阵的列数:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"最小次数:"</span> &lt;&lt; minN[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        print(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h4><h5 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h5><ul>
<li><p>证明最优子结构</p>
</li>
<li><p>构造递归方程</p>
</li>
<li><p>计算最优值</p>
<p>边界条件没有物品或背包容量为空价值为0</p>
<p>由只考虑装或不装第一个物品开始自底向上依次计算</p>
</li>
</ul>
<h5 id="理解递归式的定义、填表过程"><a href="#理解递归式的定义、填表过程" class="headerlink" title="理解递归式的定义、填表过程"></a>理解递归式的定义、填表过程</h5><p>考虑是否能装进去，装不进去不装，装的进去可以装也可以不装，取最大价值。</p>
<p>设i为当前物品 j为当前背包剩余可用容量</p>
<p>$dp[i][p] = \left { \begin{aligned} dp[i-1][j]\ \ \ \ 0 &lt;= j <volume[i] \\ max\{dp[i-1][j],d[i-1][j-volume[i-1]] + value[i]\}\ \ j>=volume[i] \end{aligned} \right.$</volume[i]></p>
<p>因为自底向上运算，每次只需要用到上次运算的结果，所以可用使用滚筒数组来优化空间复杂度</p>
<p>$dp[i][p] = \left { \begin{aligned} dp[j]\ \ \ \ 0 &lt;= j <volume[i] \\ max\{dp[j],d[j-volume[i-1]] + value[i]\}\ \ j>=volume[i] \end{aligned} \right.$</volume[i]></p>
<p>填表过程以二维数组为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>物品</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>体积</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>价值</td>
<td>12</td>
<td>10</td>
<td>20</td>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<p>背包容积为5</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>物品\背包容量</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>10</td>
<td>12</td>
<td>22</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>10</td>
<td>12</td>
<td>22</td>
<td>30</td>
<td>32</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>10</td>
<td>15</td>
<td>25</td>
<td>30</td>
<td>37</td>
</tr>
</tbody>
</table>
</div>
<h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> value[maxn], volume[maxn];</span><br><span class="line"><span class="comment">//value记录物品价值volume记录物品体积</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;  <span class="comment">//测试数量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, v;   <span class="comment">//n为物品数量 v背包容量</span></span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;v);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;value[i]); <span class="comment">//输入物品价值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;volume[i]);    <span class="comment">//输入物品体积</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));  <span class="comment">//初始化边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;    <span class="comment">//枚举物品</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = v; j &gt;= volume[i]; j--)&#123;  <span class="comment">//逆序枚举体积</span></span><br><span class="line">                    dp[j] = max(dp[j], dp[j - volume[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v; i++)&#123;    <span class="comment">//找到最大值</span></span><br><span class="line">                ans = max(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);    <span class="comment">//输出答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>n种物品，背包体积v</p>
<p>O(nv)</p>
<h4 id="最长公共子序列问题LCS"><a href="#最长公共子序列问题LCS" class="headerlink" title="最长公共子序列问题LCS"></a>最长公共子序列问题LCS</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>Z=CGCA是X=ACGCTAC 和 Y=CTGACA 最长公共的子序列</p>
<h5 id="三种情况的分析"><a href="#三种情况的分析" class="headerlink" title="三种情况的分析"></a>三种情况的分析</h5><p><strong>最优子结构证明</strong></p>
<p>假设$Z<em>k = <z_1,z_2,z_3..,z_k>$是$X_m=&lt;x</z_1,z_2,z_3..,z_k></em>!,x<em>2,…,x_m&gt;$和$Y_n=<y_1,y_2,...y_n>$的任意$LCS</y_1,y_2,...y_n></em>{xy}$（最优解），那么如下结论成立</p>
<ul>
<li><p>假如$x<em>m = y_n$，那么$z_k = x_m = y_n$ ，并且$Z</em>{k-1}$是$X<em>{m-1}$与$Y</em>{n-1}$的$LCS<em>{x</em>{m-1}Y_{n-1}}$（最优解）</p>
<p>$LCS<em>{XY} = LCS</em>{X<em>{m-1}Y</em>{n-1}} + x_m或y_n$</p>
</li>
<li><p>假如$x<em>m \neq y_n$，并且$z_k \neq x_m$，则有$Z_k$是$X</em>{m-1}$与$Y<em>n$的$LCS</em>{X<em>{m-1}Y_n} = LCS</em>{XY}$</p>
</li>
<li><p>假如$x<em>m \neq y_n$，并且$z_k \neq y_n$，则有$Z_k$是$X_m$与$Y</em>{n-1}$的$LCS<em>{XY</em>{n-1}} = LCS_{XY}$</p>
</li>
</ul>
<p>所以最长公共子序列问题具有最优子结构</p>
<p>根据上述分析可以列出状态转移方程</p>
<p>$dp[i][j] = \left { \begin{aligned}0 \ \ \ \ if\ i=0,or \ j = 0 \ dp[i-1][j-1] + 1 \ \ \ \ if \ i,j&gt;0\ and\ x_i = y_i \ max{dp[i-1][j],d[i][j-1]}\ \ \ \ if\ i,j&gt;0\ and \ x_i \neq y_j \end{aligned} \right.$</p>
<h5 id="DP实现方法"><a href="#DP实现方法" class="headerlink" title="DP实现方法"></a>DP实现方法</h5><p>任何i与j组合都会产生一个子问题。自底向上求解子问题的公共子序列长度，将其保存到$dp[i][j]$中</p>
<ul>
<li>初始化i为0或j为0的情况最长公共子序列长度为0($dp[i][0] = 0\ \ dp[0][j] = 0$)</li>
<li>求解i = 1时与所有$Y_j$的最长公共子序列长度$dp[1][j]$</li>
<li>求解i = 2时与所有$Y_j$的最长公共子序列长度$dp[2][j]$</li>
<li>…</li>
<li>求解i = m时与所有$Y_j$的最长公共子序列长度$dp[m][j]$</li>
</ul>
<p>记录公共子序列信息</p>
<p>使用pre数组记录前驱即可。</p>
<h5 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> tstr1, tstr2, str1, str2;</span><br><span class="line"><span class="comment">//我们需要的字符串下标从1开始，所以先用tstr1 与 tstr2记录用户输入</span></span><br><span class="line"><span class="comment">//str1 str2为需要参与运算的字符串</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; tstr1)&#123;</span><br><span class="line">        str1 = str2 = <span class="string">""</span>;   <span class="comment">//每次计算开始前使str1 str2为空</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tstr2;</span><br><span class="line">        str1 += <span class="string">"*"</span>;    <span class="comment">//为了方便运算str1首位随便加一个字符</span></span><br><span class="line">        str1 += tstr1;  <span class="comment">//将先前记录的tstr1加入str1末尾</span></span><br><span class="line">        str2 += <span class="string">"0"</span>;    <span class="comment">//str2与str1操作相同</span></span><br><span class="line">        str2 += tstr2;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.size() - <span class="number">1</span>; <span class="comment">//获取str1有效位长度（第一位没用）</span></span><br><span class="line">        <span class="keyword">int</span> len2 = str2.size() - <span class="number">1</span>; <span class="comment">//获取str2有效位长度（第一位没用）</span></span><br><span class="line">        <span class="comment">//初始化dp数组的边界值</span></span><br><span class="line">        <span class="comment">//这里不能用memset，如果使用的话会超内存</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, pre[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str1[i] != str2[j])&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>])</span><br><span class="line">                        pre[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        pre[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[len1][len2]);</span><br><span class="line">        <span class="built_in">string</span> lcs = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = len1, j = len2;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                lcs += str1[i];</span><br><span class="line">                i--, j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(lcs.begin(), lcs.end());</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lcs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>计算最优时间 i j层循环，i 循环m步，j循环n步共需O(mn)</p>
<h4 id="数字三角形问题"><a href="#数字三角形问题" class="headerlink" title="数字三角形问题"></a>数字三角形问题</h4><p> $val[i][j]$代表第i行第j个数</p>
<p>这道题有自顶向下和自底向上两种算法，其各有优点</p>
<p>先说自顶向下，$dp[i][j]$表示从顶点走到当前点的最大权值和，将dp初始化为0，可以发现每行第一个点只能由其上一行第一个点抵达，每行最后点只能由其上层最后点抵达，根据这两条设置dp的初始状态，自顶向下计算最大值    状态转移方程：  $dp[i][j] = std::max(dp[i - 1][j - 1],dp[i - 1][j]) + val[i][j];$    </p>
<p>再说自底向上原理，dp代表当前点到底的最大权值和，从$val[i][j]$出发，下一步只能走$val[i+1][j]$或者$val[i+1][j+1]$,如果走$val[i+1][j]$则$dp[i][j] = dp[i+1][j] + val[i][j]$,如果走$val[i+1][j+1]$ 则 $dp[i][j] = dp[i+1][j+1]+val[i][j]$  状态转移方程$dp[i][j] = max(dp[i + 1][j],  dp[i + 1][j + 1]) + val[i][j]$  </p>
<h5 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// 拒绝命名空间污染，养成不用std命名空间的好习惯</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> val[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dpInit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = val[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">// 初始化到每层第一个位置最大值</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + val[i][<span class="number">0</span>];    <span class="comment">// 每层第一个位置只能由上一次第一个位置到达</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">// 初始化到每层最后位置的最大值</span></span><br><span class="line">        dp[i][i] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + val[i][i];    <span class="comment">// 每层最后位置只能由上一层最后位置抵达</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt; n; <span class="comment">// 层数n</span></span><br><span class="line">    <span class="comment">// 输入数字金字塔并初始化dp</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dpInit(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自顶向下计算最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j]) + val[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        maxNum = <span class="built_in">std</span>::max(dp[n<span class="number">-1</span>][j], maxNum);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; maxNum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// 拒绝命名空间污染，养成不用std命名空间的好习惯</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> val[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][j] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    <span class="keyword">if</span>(i == n)</span><br><span class="line">        dp[i][j] = val[i][j];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[i][j] = <span class="built_in">std</span>::max(solve(i + <span class="number">1</span>, j, n), solve(i + <span class="number">1</span>, j + <span class="number">1</span>, n)) + val[i][j];</span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt; n; <span class="comment">// 层数n</span></span><br><span class="line">    <span class="comment">// 输入数字金字塔并初始化dp</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="comment">// 自底向上dp数组的意义就是当前点的最大和</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>$O(n^2)$</p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>做出在当前看来最好的选择，不从全局最优考虑，做出的选择是局部最优</p>
<h3 id="贪心算法的基本思想"><a href="#贪心算法的基本思想" class="headerlink" title="贪心算法的基本思想"></a>贪心算法的基本思想</h3><p>最终目标是解决优化问题，算法的每个步骤都面临一组选择，要做出<strong>贪心选择</strong>——当前状态下的局部最优选择</p>
<p>贪心算法能否产生最优解需要严格证明</p>
<h4 id="两个重要性质-要素"><a href="#两个重要性质-要素" class="headerlink" title="两个重要性质 要素"></a>两个重要性质 要素</h4><ul>
<li><p>贪心选择性</p>
<p>贪心选择性是贪心算法可行的第一基本要素，也是贪心算法与动态规划的主要区别</p>
<ul>
<li>动态规划通过自底向上解决子问题，贪心算法自顶向下做出贪心选择</li>
<li>对于每一个具体问题都要确定它是否具有贪心选择性</li>
</ul>
</li>
<li><p>最优子结构</p>
<p>最优解包含子问题的最优解，于DP有同（概念相同）有异（构造方法有异）</p>
</li>
</ul>
<h4 id="贪心选择性最常用证明"><a href="#贪心选择性最常用证明" class="headerlink" title="贪心选择性最常用证明"></a>贪心选择性最常用证明</h4><ul>
<li><p>数学归纳法</p>
<p>根据前几步推理，对于任何正整数k，贪心算法的前k步都导致最优解</p>
</li>
<li><p>交换论证法</p>
<p>给定任意一个最优解，根据贪心准则进行改造（用第一步贪心选择的对象替换最优解中的特定元素），证明替换后的新解也是最优解</p>
<p>之后证明上述交换过程可以循环进行</p>
</li>
</ul>
<h4 id="具体问题的贪心策略"><a href="#具体问题的贪心策略" class="headerlink" title="具体问题的贪心策略"></a>具体问题的贪心策略</h4><ul>
<li>哈夫曼编码：次数最大优先</li>
<li>最优装载：重量最小优先</li>
<li>如小数背包：单位价值率最大优先</li>
<li>Dijkstra：距离最短优先</li>
<li>克鲁斯卡尔（Kruskal）：边权最短优先</li>
<li>Prim：距离点集最近优先</li>
</ul>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="回溯算法的基本思想"><a href="#回溯算法的基本思想" class="headerlink" title="回溯算法的基本思想"></a>回溯算法的基本思想</h3><h4 id="搜索的机制-剪枝函数与作用"><a href="#搜索的机制-剪枝函数与作用" class="headerlink" title="搜索的机制 剪枝函数与作用"></a>搜索的机制 剪枝函数与作用</h4><p><strong>搜索的机制</strong>：深度优先搜索</p>
<p><strong>剪枝函数</strong>：约束函数、限界函数用于减去无效分枝加速达到目标 </p>
<h4 id="解空间树的两种形式、叶子结点个数"><a href="#解空间树的两种形式、叶子结点个数" class="headerlink" title="解空间树的两种形式、叶子结点个数"></a>解空间树的两种形式、叶子结点个数</h4><h5 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h5><p>所给问题时从n个元素的集合S中找出某种性质的子集</p>
<p>叶子节点个数：$k^n$（每一步都有k种选择，一共走n步）个</p>
<p>算法模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;	<span class="comment">// t为当前递归深度</span></span><br><span class="line">    <span class="keyword">if</span>(t &gt; n)	<span class="comment">// 递归深度大于元素个数</span></span><br><span class="line">        output(x);	<span class="comment">// 显示当前答案</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            x[t] = h[i];</span><br><span class="line">            <span class="keyword">if</span>(C(t) &amp;&amp; B(t))&#123;	<span class="comment">// 符合剪枝条件</span></span><br><span class="line">                solve(t+<span class="number">1</span>);	<span class="comment">// 递归解决下个深度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h5><p>所给问题是确定n个元素满足某种性质的排列</p>
<p>叶子节点个数：n!（第一步n种选择第二步n-1种选择……走后一步只有1种选择）</p>
<p>算法模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; n)	<span class="comment">// 递归深度大于元素个数</span></span><br><span class="line">        output(x);	<span class="comment">// 显示当前答案</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(C(t) &amp;&amp; B(t))&#123;	<span class="comment">// 符合剪枝条件</span></span><br><span class="line">                swap(x[t],h(i));</span><br><span class="line">                solve(t+<span class="number">1</span>);	<span class="comment">// 递归解决下个深度</span></span><br><span class="line">                swap(x[t],h(i));	<span class="comment">// 回溯还原</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回溯算法的特点"><a href="#回溯算法的特点" class="headerlink" title="回溯算法的特点"></a>回溯算法的特点</h4><ul>
<li>系统性：在包含所有解的解空间中按深度优先的策略从根结点出发搜索解空间树</li>
<li>跳跃性：算法搜索值解空间树的任意一点时，先判断该以结点根的子树是否包含问题的解<ul>
<li>如果肯定不包含，则跳过对该结点子树的搜索，逐层向祖先回溯</li>
<li>否则进入子树继续深搜</li>
</ul>
</li>
</ul>
<h3 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h3><h4 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h4><h5 id="解空间树形式"><a href="#解空间树形式" class="headerlink" title="解空间树形式"></a>解空间树形式</h5><p>排列树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> Q[maxn];</span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateQ</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>)&#123; <span class="comment">// 处理完前n行到达第n+1证明找到一种解决方法</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 遍历每行n个位置</span></span><br><span class="line">        <span class="keyword">if</span>(hashTable[i] == <span class="literal">false</span>)&#123;	<span class="comment">// 若之前没在该位置放过皇后则进行运算</span></span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; index; j++) </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(index - j) == <span class="built_in">abs</span>(i - Q[j]))&#123;<span class="comment">// 判断是否与之前某一皇后在同一斜线上（横坐标之差与纵坐标之差的绝对值）</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;	<span class="comment">// 若该位置可放</span></span><br><span class="line">                Q[index] = i;	<span class="comment">// 记录当前皇后放置的位置</span></span><br><span class="line">                hashTable[i] = <span class="literal">true</span>;	<span class="comment">// 记录当前行已被放置</span></span><br><span class="line">                generateQ(index + <span class="number">1</span>);	<span class="comment">// 递归处理下一行</span></span><br><span class="line">                hashTable[i] = <span class="literal">false</span>;	<span class="comment">// 回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    generateQ(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图的m着色问题"><a href="#图的m着色问题" class="headerlink" title="图的m着色问题"></a>图的m着色问题</h4><h5 id="解空间树形式-1"><a href="#解空间树形式-1" class="headerlink" title="解空间树形式"></a>解空间树形式</h5><p>子集树：每个点都可以选择任意一种颜色</p>
<h5 id="叶子结点个数"><a href="#叶子结点个数" class="headerlink" title="叶子结点个数"></a>叶子结点个数</h5><p>$m^n$</p>
<h5 id="完整着色过程（解空间树）"><a href="#完整着色过程（解空间树）" class="headerlink" title="完整着色过程（解空间树）"></a>完整着色过程（解空间树）</h5><p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/图的m着色.JPG" alt="img"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> mp[MAXN][MAXN]; <span class="comment">//记录图</span></span><br><span class="line"><span class="keyword">int</span> n, e, m, cnt;    <span class="comment">// 点数 边数 色数 答案数</span></span><br><span class="line"><span class="keyword">int</span> x[MAXN];    <span class="comment">//记录涂色状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((mp[i][j] == <span class="number">1</span>) &amp;&amp; (x[i] == x[j]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; n)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        x[t] = i;</span><br><span class="line">        <span class="keyword">if</span>(judge(t))</span><br><span class="line">            solve(t + <span class="number">1</span>);</span><br><span class="line">        x[t] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e ; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边"</span>&lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        mp[u][v] = mp[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入颜色数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    solve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代码中注意"><a href="#代码中注意" class="headerlink" title="代码中注意"></a>代码中注意</h5><p>注意回溯</p>
<h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>$O(nm^n)$</p>
<h4 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h4><h5 id="解空间树形式-2"><a href="#解空间树形式-2" class="headerlink" title="解空间树形式"></a>解空间树形式</h5><p>排列树</p>
<h5 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;   <span class="comment">// 点数 边数</span></span><br><span class="line"><span class="keyword">int</span> mp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> tempx[MAXN]; <span class="comment">// 记录路径</span></span><br><span class="line"><span class="keyword">int</span> ansx[MAXN]; <span class="comment">// 最优路径</span></span><br><span class="line"><span class="keyword">int</span> minValue = INT_MAX; <span class="comment">// 最短路径长度</span></span><br><span class="line"><span class="keyword">int</span> nowValue = <span class="number">0</span>;   <span class="comment">// 当前路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[tempx[n]][<span class="number">1</span>] &amp;&amp; (mp[tempx[n]][<span class="number">1</span>] + nowValue &lt; minValue))&#123;</span><br><span class="line">            minValue = mp[tempx[n]][<span class="number">1</span>] + nowValue;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                ansx[i] = tempx[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[tempx[t<span class="number">-1</span>]][tempx[i]] &amp;&amp; (mp[tempx[t<span class="number">-1</span>]][tempx[i]] + nowValue &lt; minValue))&#123;</span><br><span class="line">            swap(tempx[t], tempx[i]);</span><br><span class="line">            nowValue += mp[tempx[t - <span class="number">1</span>]][tempx[t]];</span><br><span class="line">            solve(t + <span class="number">1</span>);</span><br><span class="line">            nowValue -= mp[tempx[t - <span class="number">1</span>]][tempx[t]];</span><br><span class="line">            swap(tempx[t], tempx[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        tempx[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边"</span>&lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, val;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; val;</span><br><span class="line">        mp[u][v] = mp[v][u] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最小边权："</span> &lt;&lt; minValue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"途径路径："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ansx[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>与DP相同，先构造递归方程</p>
<p>设i为当前物品 j为当前背包剩余可用容量</p>
<p>$dp[i][p] = \left { \begin{aligned} dp[i-1][j]\ \ \ \ 0 &lt;= j <volume[i] \\ max\{dp[i-1][j],d[i-1][j-volume[i-1]] + value[i]\}\ \ j>=volume[i] \end{aligned} \right.$</volume[i]></p>
<p>因为自底向上运算，每次只需要用到上次运算的结果，所以可用使用滚筒数组来优化空间复杂度</p>
<p>$dp[i][p] = \left { \begin{aligned} dp[j]\ \ \ \ 0 &lt;= j <volume[i] \\ max\{dp[j],d[j-volume[i-1]] + value[i]\}\ \ j>=volume[i] \end{aligned} \right.$</volume[i]></p>
<h5 id="解空间树形式-3"><a href="#解空间树形式-3" class="headerlink" title="解空间树形式"></a>解空间树形式</h5><p>由于每种物品都有拿与不拿两种形式，所以01背包的解空间树为有$2^n$个叶子结点的子集树</p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/01背包回溯解空间树.JPG" alt="img"></p>
<h5 id="约束函数"><a href="#约束函数" class="headerlink" title="约束函数"></a>约束函数</h5><p>judge(i)代表当前选择第i个物品后的总体积，若judge(i) &gt; 背包容量则停止搜索i后面的物品。</p>
<h5 id="限界函数"><a href="#限界函数" class="headerlink" title="限界函数"></a>限界函数</h5><p>nextBest(i)表示再选择第i个物品后剩余的物品能装包的最大价值</p>
<p>若nextBest(i) &lt; 当前最优装包方式的价值，就停止搜索</p>
<h5 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h5><p>将物品按价值率递减的顺序排序。</p>
<h5 id="解空间状态"><a href="#解空间状态" class="headerlink" title="解空间状态"></a>解空间状态</h5><p>以4个物品value = {9, 10, 7, 4} volume={3, 5, 2, 1}</p>
<p>按价值率排序v value{4, 7, 9, 10} volume={1, 2, 3, 5}</p>
<p>背包容量 7</p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/01b背包回溯解空间状态1.JPG" alt="img"></p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/kit\hexo\source\_posts\算法设计与分析\01背包回溯解空间状态2.JPG" alt="img"></p>
<h5 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, c;<span class="comment">// 物品数量 背包容量</span></span><br><span class="line"><span class="keyword">double</span> nowVolume, nowValue, bestValue; <span class="comment">// 当前背包内的物品体积 当前背包内的物品价值 当前最优价值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; &gt; things;    <span class="comment">// first 为价值value second 为体积volume</span></span><br><span class="line"><span class="keyword">int</span> put[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; a, pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; b)</span></span>&#123;   <span class="comment">// 价值率比较函数</span></span><br><span class="line">    <span class="keyword">return</span> (a.first / a.second) &gt; (b.first / b.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">nextBest</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> best = nowValue;</span><br><span class="line">    <span class="keyword">int</span> tempVolume = nowVolume;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        tempVolume += things[i].second;</span><br><span class="line">        <span class="keyword">if</span>(tempVolume &lt;= c)</span><br><span class="line">           best +=  things[i].first;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> best + (<span class="keyword">double</span>)(c - nowVolume)*(things[i].first / things[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n)&#123;</span><br><span class="line">        bestValue = nowValue;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nowVolume + things[i].second &lt;= c)&#123;</span><br><span class="line">        nowVolume += things[i].second;</span><br><span class="line">        nowValue +=  things[i].first;</span><br><span class="line">        put[i] = <span class="number">1</span>;</span><br><span class="line">        solve(i + <span class="number">1</span>);</span><br><span class="line">        nowVolume -= things[i].second;</span><br><span class="line">        nowValue -=  things[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nextBest(i+<span class="number">1</span>) &gt; bestValue)</span><br><span class="line">        solve(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入物品数量"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入背包容量"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"个物品的价值与体积"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">double</span> value, volume;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value &gt;&gt; volume;</span><br><span class="line">        things.push_back(make_pair(value, volume));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(things.begin(), things.end(), cmp);</span><br><span class="line">    solve(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最优价值："</span> &lt;&lt; bestValue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(put[i])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; things[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; things[i].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h2><h3 id="分支限界算法的基本思想"><a href="#分支限界算法的基本思想" class="headerlink" title="分支限界算法的基本思想"></a>分支限界算法的基本思想</h3><h4 id="搜索的机制-剪枝函数与作用-1"><a href="#搜索的机制-剪枝函数与作用-1" class="headerlink" title="搜索的机制 剪枝函数与作用"></a>搜索的机制 剪枝函数与作用</h4><h5 id="搜索的机制"><a href="#搜索的机制" class="headerlink" title="搜索的机制"></a>搜索的机制</h5><p>广度优先搜索 </p>
<h5 id="剪枝函数"><a href="#剪枝函数" class="headerlink" title="剪枝函数"></a>剪枝函数</h5><p>约束函数：剪去不包含可行解的分支</p>
<p>限界函数：减去不包含最优解的分支</p>
<h4 id="分类与依据"><a href="#分类与依据" class="headerlink" title="分类与依据"></a>分类与依据</h4><h5 id="先进先出FIFO"><a href="#先进先出FIFO" class="headerlink" title="先进先出FIFO"></a>先进先出FIFO</h5><p>按从活结点表中取出与加入节点的顺序相同</p>
<h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>每个结点都有一个对应的消耗或收益（优先级）</p>
<p>维护小顶堆或者大顶堆做到权值最小或最大的优先取出</p>
<h4 id="分支限界算法的特点"><a href="#分支限界算法的特点" class="headerlink" title="分支限界算法的特点"></a>分支限界算法的特点</h4><p>也是一种搜索解空间树的算法</p>
<h5 id="与回溯的不同"><a href="#与回溯的不同" class="headerlink" title="与回溯的不同"></a>与回溯的不同</h5><ul>
<li>回溯法找出满足约束条件的所有解</li>
<li>分支限界找出满足约束条件的一个解</li>
<li>回溯法为深搜分支限界为广搜</li>
</ul>
<h3 id="具体问题-1"><a href="#具体问题-1" class="headerlink" title="具体问题"></a>具体问题</h3><h4 id="任务分配问题"><a href="#任务分配问题" class="headerlink" title="任务分配问题"></a>任务分配问题</h4><h5 id="成本下界的计算"><a href="#成本下界的计算" class="headerlink" title="成本下界的计算"></a>成本下界的计算</h5><p>将成本矩阵每行中的最小值相加得出的和就是最佳成本下界</p>
<p>根据当前已经选择的任务的成本与还未选择的任务的最小成本相加为当前成本下届</p>
<h5 id="利用成本下届的搜索过程"><a href="#利用成本下届的搜索过程" class="headerlink" title="利用成本下届的搜索过程"></a>利用成本下届的搜索过程</h5><p>每次将所有计算出结点与其成本下届，加入优先队列，优先将成本下界低的结点出队。</p>
<h5 id="结点成本值的计算、筛选"><a href="#结点成本值的计算、筛选" class="headerlink" title="结点成本值的计算、筛选"></a>结点成本值的计算、筛选</h5><p>每个结点的成本下届为当前已选择任务的成本加未选择任务的最小成本，每次出队选择成本下届最低的结点出队，直至找到可行解即为最优解。</p>
<h4 id="01背包问题-1"><a href="#01背包问题-1" class="headerlink" title="01背包问题"></a>01背包问题</h4><p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/01背包分支限界.JPG" alt="img"></p>
<h4 id="旅行商问题-1"><a href="#旅行商问题-1" class="headerlink" title="旅行商问题"></a>旅行商问题</h4><p>旅行过程中必须离开每个顶点一次，最优下届为邻接矩阵每行的最小值之和</p>
<p>解空间树为排列树</p>
<p>假设由n个顶点，由第一个点出发，可以抵达其他n-1个顶点，将这n-1个结点入队并计算其成本下届，循环选择成本下届最低的点出队，若其成本下届大于当前最低成本就丢弃该结点，若小于当前最低成本就计算其可达点的成本下届并将其入队</p>
<h2 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>伪随机数：按照某种确定规则，通过迭代递推运算产生的一系列近似随机分布的数列</li>
<li>随机数：在自然过程或人工过程中由多种未知因素共同作用下产生的一些没有规则的数值</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>算法执行需要一些随机数</p>
</li>
<li><p>对相同的输入，不同运行过程可能得到不同结果</p>
</li>
<li>对相同的输入，不同运行过程可能执行时间也不同</li>
</ul>
<p>对所求解问题的同一实例使用同一个概率算法求解两次可能得到完全不同的结果</p>
<h4 id="分类与每一类算法的特点"><a href="#分类与每一类算法的特点" class="headerlink" title="分类与每一类算法的特点"></a>分类与每一类算法的特点</h4><h5 id="数值随机化算法"><a href="#数值随机化算法" class="headerlink" title="数值随机化算法"></a>数值随机化算法</h5><p>得到近似解，近似解的精度随时间增加而提高</p>
<p>圆周率 定积分</p>
<h5 id="舍伍德算法"><a href="#舍伍德算法" class="headerlink" title="舍伍德算法"></a>舍伍德算法</h5><p>总能求得问题的一个解，且求得的解总是正确的</p>
<p>随机化快排 随机化线性时间选择</p>
<h5 id="蒙特卡罗方法"><a href="#蒙特卡罗方法" class="headerlink" title="蒙特卡罗方法"></a>蒙特卡罗方法</h5><p>用于求准确解，算法所用时间越多，得到正确解的概率就越高</p>
<p>主元素问题</p>
<h5 id="拉斯维加斯算法"><a href="#拉斯维加斯算法" class="headerlink" title="拉斯维加斯算法"></a>拉斯维加斯算法</h5><p>不会得到不正确的解，有时找不到解，得到正确解的概率随计算时间而增加</p>
<p>N后问题</p>
<h2 id="NPC问题"><a href="#NPC问题" class="headerlink" title="NPC问题"></a>NPC问题</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h4><p>可以用多项式时间的确定算法进行判断和求解</p>
<h4 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h4><p>可以用多项式时间的确定性算法来验证它的解</p>
<h4 id="NPC类问题（NP完全）"><a href="#NPC类问题（NP完全）" class="headerlink" title="NPC类问题（NP完全）"></a>NPC类问题（NP完全）</h4><p>对于一个判定问题D满足</p>
<ol>
<li>属于NP问题</li>
<li>NP问题中的任何问题都能够在多项式时间内归约为D</li>
</ol>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>$P \subseteq  NP$</p>
<p>$NPC \subseteq NP$</p>
<p><img src="/2019/12/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/PNPNPC.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/" class="post-title-link" itemprop="url">计算机网络基础梳理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-23 20:10:41" itemprop="dateCreated datePublished" datetime="2019-12-23T20:10:41+08:00">2019-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%BD%92%E7%BA%B3/" itemprop="url" rel="index"><span itemprop="name">理论归纳</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="互联网发展历史"><a href="#互联网发展历史" class="headerlink" title="互联网发展历史"></a>互联网发展历史</h3><ul>
<li>1969年第一个网络ARPANET</li>
<li>1983年Internet因特网诞生（TCP/IP成为ARPANET标准协议）</li>
<li>1994年，我国接入互联网</li>
</ul>
<h4 id="互联网基础结构发展的三个阶段"><a href="#互联网基础结构发展的三个阶段" class="headerlink" title="互联网基础结构发展的三个阶段"></a>互联网基础结构发展的三个阶段</h4><ul>
<li>第一阶段：ARPANET向互联网发展</li>
<li>第二阶段：三级结构互联网</li>
<li>第三阶段：多层次ISP结构的互联网</li>
</ul>
<h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul>
<li>核心部分：大量网络与链接这些网络的路由器，为边缘部分提供服务</li>
<li>边缘部分：所有链接在互联网上的主机，由用户直接组成</li>
</ul>
<h4 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h4><ul>
<li><p>核心技术：</p>
<p>分组交换：使用存储转发技术，把一个报文划分为几个分组后再进行发送</p>
</li>
<li><p>核心设备：路由器</p>
</li>
</ul>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li><p>速率（数据率/比特率）</p>
<p>数据传输的速率 比特每秒(bit/s)</p>
</li>
<li><p>带宽</p>
<p>单位时间内网络中某信道能通过的最高数据率 比特每秒(bit/s)</p>
</li>
<li><p>吞吐量</p>
<p>单位时间内通过某个网络的实际数据量 比特每秒(bit/s)</p>
</li>
<li><p><strong>时延</strong></p>
<p>数据从网络的一段传到另一端所需的时间</p>
<ul>
<li><p><strong>发送时延</strong>（传输时延）</p>
<p>主机或路由器发送数据帧所需要的时间</p>
<script type="math/tex; mode=display">
发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}</script></li>
<li><p><strong>传播时延</strong></p>
<p>电磁波在信道中传播一定距离需要花费的时间</p>
<script type="math/tex; mode=display">
传播时延 = \frac{信道长度(m)}{电磁波再信道上的传播速率(m/s)光纤:2.0\times10^5km/s}</script></li>
<li><p>处理时延</p>
<p>主机或路由器收到分组后的处理时间</p>
</li>
<li><p>排队时延</p>
<p>进入路由器后再输入队列中排队的时延</p>
</li>
</ul>
</li>
<li><p>时延带宽积</p>
<p>线路上的最大bit数</p>
<script type="math/tex; mode=display">
时延带宽积 = 传播时延 \times 带宽</script></li>
<li><p>往返时间RTT</p>
<script type="math/tex; mode=display">
有效数据率 =\frac{数据长度}{发送时延+RTT}</script></li>
<li><p>利用率</p>
<p>某信道有百分之几的时间是被利用的$D（当前时延）=\frac{D_0（网络空闲时延）}{1-U（利用率）}$</p>
</li>
</ul>
<h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ul>
<li><p>OSI体系结构</p>
<ol>
<li><p>应用层</p>
</li>
<li><p>表示层</p>
</li>
<li><p>会话层</p>
</li>
<li><p>运输层</p>
</li>
<li><p>网络层</p>
</li>
<li><p>数据链路层</p>
</li>
<li><p>物理层</p>
</li>
</ol>
</li>
<li><p>TCP/IP体系结构</p>
<ul>
<li>应用层（应用层协议）</li>
<li>运输层</li>
<li>网际层IP</li>
<li>网络接口层</li>
</ul>
</li>
<li><p>五层协议体系结构</p>
<ol>
<li><p>应用层</p>
</li>
<li><p>运输层</p>
</li>
<li><p>网络层</p>
</li>
<li><p>数据链路层</p>
</li>
<li><p>物理层</p>
</li>
</ol>
</li>
</ul>
<p>对等层次之间传送的数据单位称为，OSI协议数据单元PDU</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>通过应用进程间交互完成特定网络应用</p>
<p>应用层协议：应用进层间的通信和交互规则如DNS HTTP</p>
<p> 电子邮件SMTP </p>
<p>应用层交互数据单元 <strong>报文</strong></p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>向两台主机中的进程直接的通信提供数据传输服务</p>
<p>运输层协议</p>
<ul>
<li>传输控制协议TCP 数据传输单位 <strong>报文段</strong></li>
<li>用户数据报协议UDP 数据传输单位 <strong>用户数据报</strong></li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>为分组交换网上不同主机提供通信服务，将运输层报文段或用户数据报封装为分组（<strong>IP数据报</strong>）或包进行传送</p>
<p>网络层协议</p>
<p>IP协议 </p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>使用专门的链路层协议在链路上传输数据 将网络层交下来的IP数据报<strong>封装成帧</strong>。</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>物理层要考虑代表0 1的电压 接收方如何识别发送方的比特 确定链接电缆的插头的引脚数。</p>
<p>物理层数据传输单位是<strong>比特</strong></p>
<h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><h3 id="信号调制"><a href="#信号调制" class="headerlink" title="信号调制"></a>信号调制</h3><p>调制可分为两大类</p>
<ul>
<li><p>基带调制</p>
<p>仅对基带信号（来自信源的信号）的波形进行变化，变换后仍为基带信号的。</p>
</li>
<li><p>带通调制</p>
<p>使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，变换后的信号被称为带通信号</p>
</li>
</ul>
<p>  基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行带通调制</p>
<p>  基本带通调制方法</p>
<ul>
<li><p>调幅（AM）</p>
<p>载波振幅随基带数字信号而变化 0 1分别代表无载波输出与有载波输出</p>
</li>
<li><p>调频（FM）</p>
<p>载波频率随基带数字信号而变化 0 1分别对应频率f1与f2</p>
</li>
<li><p>调相（PM）</p>
<p>载波初始相位随基带数字信号而变化 0 1分别对应相位0度与相位180度</p>
<p>正交振幅调制 （调幅+调相）</p>
</li>
</ul>
<p>常用编码方式</p>
<ul>
<li>不归零制</li>
<li>归零制</li>
<li>曼彻斯特编码</li>
<li>差分曼彻斯特编码</li>
</ul>
<p>而曼彻斯特编码和差分曼彻斯特编码具有自同步能力</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/常用编码方式.png" alt="img"></p>
<h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<p>在数字通信中常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，这个间隔被称为码元长度</p>
<p>比如在一个二进制码元中，由两个电平信号承载比特数据，也就是一个电平信号表示1，一个表示0。在一个四进制码元中，由四个电平信号承载比特数据，也就是一个电平信号表示两位11,10,01,00</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/码元.JPG" alt="img"></p>
<p>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</p>
<p><strong>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高</strong></p>
<p>香农公式$C=Wlog_2(1+\frac SN)$</p>
<p><strong>W</strong> 为信道的带宽（以Hz为单位）；</p>
<p> <strong>S</strong> 为信道内所传信号的平均功率；</p>
<p> <strong>N</strong> 为信道内部的高斯噪声功率。</p>
<p><strong>码元离散值</strong></p>
<p>码元离散值为N，该码元为N进制码元，可以携带$log_2N$bit数据</p>
<h3 id="信道复用的技术"><a href="#信道复用的技术" class="headerlink" title="信道复用的技术"></a>信道复用的技术</h3><h4 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h4><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</p>
<p>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/频分复用.JPG" alt="img"></p>
<h4 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h4><p>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。<br>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）。</p>
<p><strong>时分复用的所有用户是在不同的时间占用同样的频带宽度。</strong></p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/时分复用.JPG" alt="img"></p>
<p>时分复用可能会造成线路资源的浪费</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/时分复用_浪费.JPG" alt="img"></p>
<h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><p>光的频分复用，一根光纤同时传送多个光载波信号</p>
<h4 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h4><p>常用的名词是码分多址 CDMA </p>
<p>用code来区分用户，每个用户分配一个唯一的code码型（码片序列），通长是64位或128位</p>
<p>发送数据时，用code对原始信号的码元进行编码，生成发送信号。</p>
<h5 id="码片序列"><a href="#码片序列" class="headerlink" title="码片序列"></a>码片序列</h5><p>每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。<br>每个站被指派一个唯一的 m bit 码片序列。</p>
<ul>
<li><p>如发送比特 1，则发送自己的 m bit 码片序列。</p>
</li>
<li><p>如发送比特 0，则发送该码片序列的二进制反码。 </p>
</li>
</ul>
<p>例如，S 站的 8 bit 码片序列是 00011011。</p>
<ul>
<li><p>发送比特 1 时，就发送序列 00011011，</p>
</li>
<li><p>发送比特 0 时，就发送序列 11100100。</p>
</li>
</ul>
<p>每个站分配的码片序列不仅必须各不相同，并且还必须互相正交 (orthogonal)。</p>
<p>S · T = 0</p>
<p>在实用的系统中是使用伪随机码序列</p>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><strong>共有4个站进行码分多址通信。4个站的码片序列为</strong></p>
<p>A：（－1－1－1＋1＋1－1＋1＋1） B：（－1－1＋1－1＋1＋1＋1－1）</p>
<p>C：（－1＋1－1＋1＋1＋1－1－1） D：（－1＋1－1－1－1－1＋1－1）</p>
<p>现收到这样的码片序列S：（－1＋1－3＋1－1－3＋1＋1）。问哪个站发送数据了？发送数据的站发送的是0还是1？</p>
<script type="math/tex; mode=display">
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 -1 -1 +1 +1 -1 +1 +1) = (+1 -1 +3 +1 -1 +3 +1 +1)/8 = 1 A:1\\
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 -1 +1 -1 +1 -1 +1 -1) = (+1 -1 -3 -1 -1 -3 +1 -1)/8 = -1 B:0\\
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 +1 -1 +1 +1 +1 -1 -1) = (+1 +1 +3 +1 -1 -3 -1 -1)/8 = 0 C:不发\\
(-1 +1 -3 +1 -1 -3 +1 +1) \times(-1 +1 -1 -1 -1 -1 +1 -1) = (+1 +1 +3 -1 +1 +3 +1 -1)/8 = 1 D:1</script><h2 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路理解"><a href="#数据链路理解" class="headerlink" title="数据链路理解"></a>数据链路理解</h3><ul>
<li>链路：从一个结点到相邻结点的物理线路（中间无交换节点）</li>
<li>数据链路：包括链路与一些必要的通信协议来控制数据传输（使用网络适配器实现）</li>
<li>帧 （点对点信道的数据链路层协议单元）由网络层交下来的数据（ip数据报）构成</li>
</ul>
<h3 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务"></a>基本任务</h3><ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错检验</li>
</ul>
<h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>在网络层IP数据报的前后分别添加首部与尾部</p>
<p>包括帧首部 帧数据 帧尾部</p>
<p>首部与尾部用于进行帧定界含有帧定界符</p>
<ul>
<li>SOH开始定界符</li>
<li>EOT结束定界符</li>
</ul>
<p>数据部分最大上限称为<strong>最大传送单元（MTU）1500字节</strong></p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>无论什么样的比特流组合的数据都能按照原样没有差错地通过这个数据链路层，所以为了避免数据中有数据与EOT重复被视为帧提前结束，要使用<strong>字节填充</strong>来处理</p>
<p>字节填充：在SOH或EOT之前添加转译字符ESC(1B)</p>
<h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h4><p>使用循环冗余检测CRC</p>
<p>在要传输时会给出一根除数P 的k位数据后添加n（比P小一位）位冗余码</p>
<p>计算方法</p>
<p>现在K位要发送的数据后加n位0，将得到的k+n位数据作为被除数除以P，得到的n位余数就是冗余码（帧检验序列FCS）</p>
<p>接收端将收到的数据除以P检测得到的余数是否为0 </p>
<ul>
<li><p>如果为0证明没有出错则接受</p>
</li>
<li><p>若不为0证明出错（无法确定错在哪里，直接丢弃）</p>
</li>
</ul>
<h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><p>要发送的数据为1101011011。采用CRC的生成多项式是P(X)= X4+X+1。试求应添加在数据后面的余数。数据在传输过程中最后一个1变成了0，问接收端能否发现？若数据在传输过程中最后两个1都变成了0，问接收端能否发现？采用CRC检验后，数据链路层的传输是否就变成了可靠的传输？</p>
<script type="math/tex; mode=display">
P(X) = X^4 + X + 1 \\
P =10011(n=4)\\
余数：\frac{11010110110000}{10011}=1100001010 \cdots\cdots 1110\\
最后1变0：\frac{11010110101110}{10011}= 1100001011\cdots\cdots 1011可以发现\\
最后两个1变0：\frac{11010110001110}{10011}=1100000111 \cdots\cdots 10111可以发现\\可以发现
可靠传输：错了就直接仍</script><h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><ul>
<li>语法</li>
<li>语义 </li>
<li>同步</li>
</ul>
<h3 id="点对点传输协议"><a href="#点对点传输协议" class="headerlink" title="点对点传输协议"></a>点对点传输协议</h3><p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/PPP格式.JPG" alt="img"></p>
<p>FCS检测范围：A + C + 协议 + 数据部分</p>
<p>PPP协议场景：</p>
<ul>
<li>拨号上网</li>
<li>广域网两个相邻路由器之间</li>
</ul>
<p>满足的需求</p>
<ul>
<li><p>简单</p>
<p>只进行CRC检验，正确就收下否则就丢弃，其他什么都不管</p>
</li>
<li><p>封装成帧 PPP使用特数字符作为帧定界符 7E</p>
</li>
<li><p>透明传输</p>
<p>同步：零比特填充</p>
<p>有5个连续1就填入一个0（接收时删除）</p>
<p>异步：字节填充</p>
<p>采取有效措施解决数据中与帧定界符7E重合的情况</p>
<p>将0x7D视为转义字符 </p>
<p>数据中遇到0x7E就将其转为 0x7D 0x5E</p>
<p>数据中遇到0x7D将其转译为 0x7D 0x5D</p>
<p>遇到小于0x20的字符将其转译为 0x7D (0x20 + 原字符)</p>
<p>例题</p>
<p>一个PPP帧的数据部分（用十六进制写出）是7D 5E FE 27 7D 5D 7D 5D 65 7D 5E。试问真正的数据是什么（用十六进制写出）？</p>
<p>字节填充规定0x7D为转义字符，将0x7E变为（0x&amp;D，0x5E）将0x7D变为（0x7D，0x5D）</p>
<script type="math/tex; mode=display">
{\underbrace{7D\ \ 5E}\\ \ \ \ \ 7E\ \ }\ \  {FE\\FE}\ \ {27\\27}\ \ {\underbrace{7D\ \ 5D}\\ \ \ \ \ 7D}\ \ {\underbrace{7D\ \ 5D}\\ \ \ \ 7D}\ \ {65\\65}\ \ {\underbrace{7D\ \ 5E}\\ \ \ \ 7E}\\</script></li>
<li><p>多种网络层协议 支持多种网络层协议</p>
</li>
<li><p>多种链路层协议 支持在多种链路上运行如串行线路 并行链路 同步链路 异步链路等等</p>
</li>
<li><p>差错检测</p>
<p>CRC出错就丢弃</p>
</li>
<li><p>检测链接状态</p>
<p>自动检测链路是否正常工作</p>
</li>
<li><p>最大传输单元MTU 分片由高层协议处理，PPP收到超出长度的帧就丢弃</p>
</li>
<li><p>网络层地址协商</p>
</li>
<li><p>数据压缩协商</p>
</li>
</ul>
<p>异步传输按字符传输</p>
<p>同步传输按帧传输 </p>
<h3 id="载波侦听多路访问-冲突检测协议（CSMA-CD）"><a href="#载波侦听多路访问-冲突检测协议（CSMA-CD）" class="headerlink" title="载波侦听多路访问/冲突检测协议（CSMA/CD）"></a>载波侦听多路访问/冲突检测协议（CSMA/CD）</h3><p>局域网处理冲突</p>
<ul>
<li>多点接入 多个主机随机接入共享一根总线</li>
<li>载波监听 每个主机发送数据前检测是否有其他主机在发送数据避免冲突</li>
<li>碰撞检测 边发送数据便检测有无碰撞</li>
</ul>
<h4 id="CSMA-CD过程"><a href="#CSMA-CD过程" class="headerlink" title="CSMA/CD过程"></a>CSMA/CD过程</h4><p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/CSMACD过程.JPG" alt="img"></p>
<h5 id="随机数r选取方法"><a href="#随机数r选取方法" class="headerlink" title="随机数r选取方法"></a>随机数r选取方法</h5><ul>
<li><p>第一次重传</p>
<p>r从{0, 1}中随机选取一个后 等待r个争用期</p>
</li>
<li><p>第二次重传</p>
<p>r从{0, 1, 2}中随机选取一个后等待r个争用期</p>
</li>
<li><p>第三次重传</p>
<p>r从{0, 1, 2, 3}中随机选取一个后等待r个争用期</p>
</li>
<li><p>……</p>
</li>
<li><p>第十次重传</p>
<p>r从{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}中随机选取一个后等待r个争用期</p>
</li>
<li><p>第十一次重传</p>
<p>r=10 等待r个争用期</p>
</li>
<li><p>第十二次重传</p>
<p>r=10 等待r个争用期</p>
</li>
<li><p>……</p>
</li>
<li><p>第十六次重传</p>
</li>
<li><p>r = 10 若还未发送成功，放弃重传</p>
</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>先听后发</li>
<li>边听边发</li>
<li>冲突停发</li>
<li>随机延迟后重发</li>
</ul>
<h4 id="争用期"><a href="#争用期" class="headerlink" title="争用期"></a>争用期</h4><p>10Mbit/s 争用期（发送一个64字节的最短帧 512比特时间）长度为51.2us</p>
<p>100Mbit/s 争用期 5.12us</p>
<h3 id="最短帧"><a href="#最短帧" class="headerlink" title="最短帧"></a>最短帧</h3><p>64字节正好填充2.5km的线路一个来回</p>
<p>最小帧间隔：9.6us （96比特时间）</p>
<h3 id="以太网MAC"><a href="#以太网MAC" class="headerlink" title="以太网MAC"></a>以太网MAC</h3><p>MAC地址：6字节 48位 硬件地址（物理地址）网卡</p>
<p>MAC有6字节 2字节两种</p>
<p>IEEE提供前24位 厂商分配后24位</p>
<p>第一字节最低第2位为G/L位为1时为全球管理（全球不同）为0时为本地管理</p>
<h4 id="帧种类"><a href="#帧种类" class="headerlink" title="帧种类"></a>帧种类</h4><ul>
<li>单播 MAC地址与本站硬件地址相同</li>
<li>广播 全1</li>
<li>多播 发给本局域网一部分地址</li>
</ul>
<h4 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h4><p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/MAC帧.JPG" alt="img"></p>
<h3 id="以太网的物理层标准"><a href="#以太网的物理层标准" class="headerlink" title="以太网的物理层标准"></a>以太网的物理层标准</h3><div class="table-container">
<table>
<thead>
<tr>
<th>标准</th>
<th>颁布时间</th>
<th>数据率</th>
<th>拓扑</th>
<th>媒体</th>
<th>半双工</th>
<th>全双工</th>
</tr>
</thead>
<tbody>
<tr>
<td>10BASE5</td>
<td>DIX-1980<br> 802.3-1983</td>
<td>10 Mb/s</td>
<td>总线</td>
<td>一根 50 W 同轴电缆 (粗缆以太网) (10 mm 直径)</td>
<td>500</td>
<td>不使用</td>
</tr>
<tr>
<td>10BASE2</td>
<td>802.3a-1985</td>
<td>10  Mb/s</td>
<td>总线</td>
<td>一根 50 W RG 58 同轴电缆   (细缆以太网) (5 mm 直径)</td>
<td>185</td>
<td>不使用</td>
</tr>
<tr>
<td>10BASE-T</td>
<td>802.3i-1990</td>
<td>10  Mb/s</td>
<td>星形</td>
<td>两对100 W 的3类或更好的UTP 电缆</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>100BASE-TX</td>
<td>802.3u-1995</td>
<td>100  Mb/s</td>
<td>星形</td>
<td>两对100 W 的5类UTP 电缆</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>100BASE-FX</td>
<td>802.3u-1995</td>
<td>100  Mb/s</td>
<td>星形</td>
<td>两根光纤</td>
<td>412</td>
<td>2000</td>
</tr>
<tr>
<td>100BASE-T4</td>
<td>802.3u-1995</td>
<td>100  Mb/s</td>
<td>星形</td>
<td>4对100 W 的3 或更好的UTP电缆</td>
<td>100</td>
<td>不使用</td>
</tr>
</tbody>
</table>
</div>
<p>10BASE－T的主要技术特性：<br>(1)数据传输速率 10Mbps基带传输<br>(2)每段双绞线最大长度 100m (HUB与主机间及两个HUB之间)<br>(3)一条通路允许连接HUB数4个，最多5段传输介质<br>(4)拓扑结构星形<br>(5)访问控制方式 CSMA/CD<br>(6)帧长64~1518个字节<br>(7)最大传输距离 500m<br>(8)每个HUB可连接的主机 96个</p>
<ul>
<li>100BASE-TX：1对接收，1对发送</li>
<li>1000BASE-T：2对接收，2对发送。</li>
<li>100BASE-T4：1对收，1对发，2对动态切换。</li>
</ul>
<h3 id="MAC与IP的区别"><a href="#MAC与IP的区别" class="headerlink" title="MAC与IP的区别"></a>MAC与IP的区别</h3><ul>
<li>地址性质不同 MAC地址是物理地址 IP地址是逻辑地址</li>
<li>每个硬件出厂时候的MAC地址是固定的IP地址可变</li>
<li>长度不同 IP地址为32位 MAC地址为48位</li>
<li>IP地址应用于网络层和以上各层 MAC地址应用于数据链路层和物理层</li>
</ul>
<h3 id="集线器与交换机的不同"><a href="#集线器与交换机的不同" class="headerlink" title="集线器与交换机的不同"></a>集线器与交换机的不同</h3><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>碰撞域：如果一个网络中的主机通讯会发生冲突，这个网络就是一个碰撞域</p>
<ul>
<li>逻辑总线 <ul>
<li>集线器使用电子器件模拟实际电缆线的工作</li>
<li>使用集线器的以太网在逻辑上仍是一个总线网</li>
<li>使用的还是CSMA/CD协议</li>
</ul>
</li>
<li>多接口转发器： 有多个接口</li>
<li>转发时不进行碰撞检测<ul>
<li>集线器工作在物理层，每个接口仅仅转发比特，不进行碰撞检测</li>
</ul>
</li>
</ul>
<h4 id="交换机（交换式集线器）"><a href="#交换机（交换式集线器）" class="headerlink" title="交换机（交换式集线器）"></a>交换机（交换式集线器）</h4><ul>
<li>消除了冲突域</li>
<li>接口全双工</li>
<li>不使用CSMA/CD协议</li>
<li>比集线器安全</li>
<li>接口可以工作在不同频率</li>
<li>广播帧将转发到所有接口（广播域）</li>
</ul>
<p>交换机的自学习算法</p>
<p>查交换表，交换表里有对应目的MAC地址就之间转发</p>
<p>没有则发生广播帧询问</p>
<p>例题</p>
<p>交换机有6个接口，分别接到5台主机和一个路由器</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/交换机查表例题.JPG" alt="img"></p>
<p>在下面动作一栏中先后发送了4个帧，假设开始时以太网交换表是空的，补充下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>动作</th>
<th>交换表的状态</th>
<th>向哪些接口转发帧</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>A发送帧给D</td>
<td>MAC地址A    接口1</td>
<td>广播</td>
<td>交换表中没有D的对应接口，广播并记录A的接口</td>
</tr>
<tr>
<td>D发送帧给A</td>
<td>MAC地址D    接口4</td>
<td>接口1</td>
<td>交换表中有A的对应接口，向A发送帧并记录D的接口</td>
</tr>
<tr>
<td>E发送帧给A</td>
<td>MAC地址E    接口5</td>
<td>接口1</td>
<td>交换表中有A的对应接口，向A发送帧并记录E的接口</td>
</tr>
<tr>
<td>A发送帧给E</td>
<td>没有变动</td>
<td>接口5</td>
<td>交换表中有A和E对应接口，向E发送帧</td>
</tr>
</tbody>
</table>
</div>
<h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><ul>
<li>IP编制 ： 同一全球互联网的逻辑地址</li>
<li>地址转换： IP地址$\rightarrow$ 数据链路层MAC地址</li>
<li>路由协议：任意两个IP之间的路线规划</li>
<li>分组转发： IP协议实现分组交换</li>
</ul>
<h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><p>IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。</p>
<p>IP 地址现在由互联网名字和数字分配机构ICANN (Internet Corporation for Assigned Names and Numbers)进行分配</p>
<h4 id="IP编址的三个阶段"><a href="#IP编址的三个阶段" class="headerlink" title="IP编址的三个阶段"></a>IP编址的三个阶段</h4><ul>
<li>分类IP</li>
<li>子网划分</li>
<li>构造超网</li>
</ul>
<h4 id="分类IP"><a href="#分类IP" class="headerlink" title="分类IP"></a>分类IP</h4><p>这是最基本的编址方法，在 1981 年就通过了相应的标准协议</p>
<p>A类地址 1.0.0.0 ~ 126.255.255.255 主机数  256 <em> 256 </em> 256 - 2 首位为0<br>A类保留地址 127 首位为0<br>B类地址 128.0.0.0 ~ 191.255.255.255    256 * 256 - 2    首位为10<br>C类地址 192.0.0.0 ~ 223.255.255.255    256 - 2 首位为110<br>D类地址 224.0.0.0 ~ 239.255.255.255 多播地址 首位为1110<br>E类地址 240.0.0.0 ~ 255.255.255.255 保留地址 首位为1111</p>
<p>例题</p>
<p>试辨认以下IP地址的网络类别。</p>
<p> （1）128.36.199.3   （2）21.12.240.17  （3）183.194.76.253   （4）192.12.69.248  （5）89.3.0.1     （6）200.3.6.2</p>
<ol>
<li>128.36.199.3    B类地址</li>
<li>21.12.240.17    A类地址</li>
<li>183.194.76.253    B类地址</li>
<li>192.12.69.248   C类地址</li>
<li>89.2.0.1             A类地址</li>
<li>200.3.6.2          C类地址</li>
</ol>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>为了解决IP地址不够用的情况，对最基本的编址方法的改进，在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/子网划分_1.JPG" alt="img"></p>
<p>为了识别IP中的子网部分使用了子网掩码</p>
<p>子网掩码为1表示对应位为子网</p>
<p>子网掩码为0表示对应位为主机号</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/子网划分_2.JPG" alt="img"></p>
<p>划分子网的基本思路（子网划分中子网号全0全1不能使用）</p>
<ul>
<li>根据子网中最大的主机数量确定子网所需主机号位数</li>
<li>根据主机号位数与给定IP地址确定子网号位数</li>
<li>进行子网划分后选择一个可用地址分配给对应子网</li>
<li>若当前划分子网个数不够用则需要选择一个可用子网继续划分</li>
<li>根据剩余子网中最大的主机数量确定子网所需主机号位数</li>
<li>根据主机号位数与先前可用子网IP地址确定新的子网号位数</li>
<li>进行子网划分后选择一个可用地址分配给对应子网</li>
<li>重复先前4步直到划分完成</li>
</ul>
<p>子网划分的任务</p>
<ul>
<li>确定子网掩码</li>
<li>确定网络地址</li>
<li>确定子网中第一个可用的IP地址和最后一个可用的IP地址</li>
</ul>
<p>有等长子网和变长子网两种划分方式</p>
<p>例题（均分）</p>
<p>某单位分配到一个B类IP地址，其net-id为129.250.0.0.该单位有4000台机器，分布在16个不同的地点。如选用子网掩码为255.255.255.0，试给每一个地点分配一个子网掩码号，并算出每个地点主机号码的最小值和最大值4000/16=250，平均每个地点250台机器。如选255.255.255.0为掩码，则每个网络所连主机数=28-2=254&gt;250，共有子网数=28-2=254&gt;16，能满足实际需求。可给每个地点分配如下子网号码</p>
<p>129.250.0.0 为B类地址 其主机号对应16位，最多$ 256 \times 256 -2 $个ip，现有4000台主机平均分配到16个地点</p>
<script type="math/tex; mode=display">
每个地点的主机数: 4000 \div 16 = 250 台\\
表示250台主机需要8位二进制位\\
子网号最大位数: 16 - 8 = 8位\\
最少分为16个可用子网，需要5位\\
子网号最小位数: 5位</script><p>给定子网掩码255.255.255.0 所以子网号使用8位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1000 0001 1111 1010 0000 0001 0000 0000	为第1个子网	主机ip范围129.250.1.1~129.250.1.254</span><br><span class="line">1000 0001 1111 1010 0000 0010 0000 0000	为第2个子网	主机ip范围129.250.2.1~129.250.2.254</span><br><span class="line">1000 0001 1111 1010 0000 0011 0000 0000	为第3个子网	主机ip范围129.250.3.1~129.250.3.254</span><br><span class="line">1000 0001 1111 1010 0000 0100 0000 0000	为第4个子网	主机ip范围129.250.4.1~129.250.4.254</span><br><span class="line">1000 0001 1111 1010 0000 0101 0000 0000	为第5个子网	主机ip范围129.250.5.1~129.250.5.254</span><br><span class="line">1000 0001 1111 1010 0000 0110 0000 0000	为第6个子网	主机ip范围129.250.6.1~129.250.6.254</span><br><span class="line">1000 0001 1111 1010 0000 0111 0000 0000	为第7个子网	主机ip范围129.250.7.1~129.250.7.254</span><br><span class="line">1000 0001 1111 1010 0000 1000 0000 0000	为第8个子网	主机ip范围129.250.8.1~129.250.8.254</span><br><span class="line">1000 0001 1111 1010 0000 1001 0000 0000	为第9个子网	主机ip范围129.250.9.1~129.250.9.254</span><br><span class="line">1000 0001 1111 1010 0000 1010 0000 0000	为第10个子网	主机ip范围129.250.10.1~129.250.10.254</span><br><span class="line">1000 0001 1111 1010 0000 1011 0000 0000	为第11个子网	主机ip范围129.250.11.1~129.250.11.254</span><br><span class="line">1000 0001 1111 1010 0000 1100 0000 0000	为第12个子网	主机ip范围129.250.12.1~129.250.12.254</span><br><span class="line">1000 0001 1111 1010 0000 1101 0000 0000	为第13个子网	主机ip范围129.250.13.1~129.250.13.254</span><br><span class="line">1000 0001 1111 1010 0000 1110 0000 0000	为第14个子网	主机ip范围129.250.14.1~129.250.14.254</span><br><span class="line">1000 0001 1111 1010 0000 1111 0000 0000	为第15个子网	主机ip范围129.250.15.1~129.250.15.254</span><br><span class="line">1000 0001 1111 1010 0001 0000 0000 0000	为第16个子网	主机ip范围129.250.16.1~129.250.16.254</span><br></pre></td></tr></table></figure>
<p>子网划分中路由表中添加了子网掩码</p>
<h4 id="构造超网"><a href="#构造超网" class="headerlink" title="构造超网"></a>构造超网</h4><p>使用无分类编址CIDR，使用变长子网掩码VLSM进一步提高IP地址资源利用率。</p>
<p>消除了窗体A类B类C类与划分子网的概念</p>
<p>使用网络前缀类代替网络号和子网号，使IP地址由三级编址又回到了两级编址</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/无分类编址.JPG" alt="img"></p>
<p>CIDR使用斜线记法 即在IP地址后面加上一个斜线“/”之后写上前缀码位数</p>
<p>如 220.78.168.0/24</p>
<p>一个CIDR地址可用表示很多地址，叫做路由聚合，掩码这一名词仍在使用</p>
<p>例题（地址块子网划分）</p>
<p>一个自治系统有5个局域网，其连接图如图4-55示。LAN2至LAN5上的主机数分别为：91，150，3和15.该自治系统分配到的IP地址块为30.138.118/23。试给出每一个局域网的地址块（包括前缀）</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/构造超网.JPG" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">地址块: 30.138.118.0</span><br><span class="line">LAN1:3	LAN2:91	LAN3:150	LAN4:3	LAN5:15</span><br><span class="line">以二进制表示:	0001 1110 1000 1010 0111 0110 0000 0000</span><br><span class="line">地址掩码表示:	1111 1111 1111 1111 1111 1110 0000 0000</span><br><span class="line">可分配位数: 9</span><br><span class="line">最大主机数: LAN3 150</span><br><span class="line">子网数量: 5</span><br><span class="line">由主机数最多的子网开始分配</span><br><span class="line"></span><br><span class="line">LAN3:150个主机号需要8位二进制数作为主机号 将最后8位作为主机号 地址掩码位数为24 可分配两个子网</span><br><span class="line">子网1范围: 30.138.118.0 ~ 30.138.118.255 地址掩码24位</span><br><span class="line">子网2范围: 30.138.119.0 ~ 30.138.119.255 地址掩码24位</span><br><span class="line">将子网1分配给LAN3，子网2继续分配</span><br><span class="line"></span><br><span class="line">LAN2:91 个主机号需要7位二进制数作为主机号 将子网2的最后7位作为主机号 地址掩码位数为25 可分配两个子网</span><br><span class="line">子网2.1范围: 30.138.119.0 ~ 30.138.119.127 地址掩码25位</span><br><span class="line">子网2.2范围: 30.138.119.128 ~ 30.138.119.255 地址掩码25位</span><br><span class="line">将子网2.1分配给LAN2，子网2.2继续分配</span><br><span class="line"></span><br><span class="line">LAN5:15 个主机号需要5位二进制数作为主机号 将子网2.2的最后5位作为主机号 地址掩码位数为27 可分配四个子网</span><br><span class="line">子网2.2.1范围 30.138.119.128 ~ 30.138.119.159 地址掩码27位</span><br><span class="line">子网2.2.2范围 30.138.119.160 ~ 30.138.119.191 地址掩码27位</span><br><span class="line">子网2.2.3范围 30.138.119.192 ~ 30.138.119.223 地址掩码27位</span><br><span class="line">子网2.2.4范围 30.138.119.224 ~ 30.138.119.255 地址掩码27位</span><br><span class="line"></span><br><span class="line">将子网2.2.1分配给LAN5 子网2.2.2分配给LAN1 子网2.2.3分配给LAN4</span><br></pre></td></tr></table></figure>
<h5 id="超网合并网段"><a href="#超网合并网段" class="headerlink" title="超网合并网段"></a>超网合并网段</h5><p>判断连续的2个网段是否能够合并，只要第一个网络号能被2整除，就能够通过左移1位子网掩码合并</p>
<p>例如192.168.0.0/24与192.168.1.0/24</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/超网合并网段.JPG" alt="img"></p>
<p>同理，判断4个网段是否能合并，只要第一个网络号能被4整除就能通过左移两位子网掩码合并4个网段</p>
<h5 id="CIDR带来的变化"><a href="#CIDR带来的变化" class="headerlink" title="CIDR带来的变化"></a>CIDR带来的变化</h5><p>无分类编址进一步提高了IP地址利用率</p>
<p>路由聚合缩减了骨干网路由器路由表规模</p>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>将IP地址转为数据链路层MAC地址</p>
<p>IP地址与硬件地址的不同在数据链路层有描述</p>
<h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>从网络层使用的IP地址解析出数据链路层使用的硬件地址（点对点链路使用PPP协议不需要ARP协议）</p>
<p>每一个主机/路由器中都存在<strong>ARP高速缓存</strong> 里面存有所在局域网上各主机和路由器IP地址到硬件地址的映射表。</p>
<p>格式为</p>
<p>IP地址    MAC地址    TTL有效时间</p>
<h5 id="ARP工作流程"><a href="#ARP工作流程" class="headerlink" title="ARP工作流程"></a>ARP工作流程</h5><ol>
<li>主机A查找ARP缓存中主机B的IP匹配的MAC地址</li>
<li>若没有找到对应映射，将ARP请求包广播到本地网络上的所有主机，主机A的IP地址与MAC地址都在ARP请求中。对应本地网络上除B外其他主机，如果请求IP地址与本机IP不匹配直接丢弃</li>
<li>主机B确认ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中</li>
<li>主机B将包含其MAC地址的ARP响应包直接发送回主机A</li>
<li>主机A接收到B发来的ARP回复消息后用B的IP与MAC地址更新ARP缓存，本机缓存有生存期，生存期结束后重复上述请求</li>
</ol>
<h5 id="ARP四种典型情况"><a href="#ARP四种典型情况" class="headerlink" title="ARP四种典型情况"></a>ARP四种典型情况</h5><ul>
<li>发送方主机向本网络另一主机发送IP数据报：ARP直接找目的主机</li>
<li>41发送方主机向另一网络主机发送IP数据报：ARP找路由器 剩下交给路由器</li>
<li>发送方路由器向本网络主机发送IP数据报：ARP找目的主机</li>
<li>发送方路由器向另一网络主机发送IP数据报：ARP找到另一个路由器剩下的由另一个路由器解决</li>
</ul>
<p>ARP请求包</p>
<p>发送方MAC / 发送方IP / 目标硬件地址（未知填0）/目标IP</p>
<p>ARP响应包</p>
<p>发送方MAC / 发送方IP / 目标MAC / 目标IP</p>
<p>ARP包封装在物理层网络的帧中传输，ARP请求是一个广播帧</p>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>任意两个IP之间的路线规划</p>
<p>路由器对IP数据报进行转发的关键步骤：查路由表</p>
<h4 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h4><ul>
<li>内部网关协议</li>
<li>外部网关协议</li>
</ul>
<h5 id="内部网关协议-RIP路由信息协议"><a href="#内部网关协议-RIP路由信息协议" class="headerlink" title="内部网关协议 RIP路由信息协议"></a>内部网关协议 RIP路由信息协议</h5><p>Routing Information Protocol</p>
<p>RIP是一种分布式的、基于距离向量的路由选择协议</p>
<p>RIP协议要求网络中的每一个路由器都要维护从它到其他每一个目标网络的距离记录</p>
<p>RIP认为一个好的路由时它通过的路由器数目少“距离短”</p>
<p>RIP允许一条路径最多只能包含15个路由器16代表不可达</p>
<p>RIP不能再两个网络之间同时使用多条路由</p>
<p>RIP核心：通过分布式交换寻找最短路核心算法bellman-ford</p>
<p><strong>RIP协议的三个特点</strong></p>
<ul>
<li>之和相邻路由器交换信息</li>
<li>交换的是当前本路由器所知道的全部信息（路由表）</li>
<li>按固定时间间隔交换路由信息，网络拓扑发生变化也及时通过</li>
</ul>
<p><strong>路由表建立过程</strong></p>
<ul>
<li>路由器刚开始工作时只知道直接相连的网络距离为1</li>
<li>和相邻路由器交换并更新路由信息</li>
<li>经过若干次更新后所有路由器都知道到达本自治系统中任何网络的距离和下一跳</li>
</ul>
<p><strong>距离向量算法</strong></p>
<p>对于每一个相邻路由器（X）发送过来的RIP报文，执行以下步骤</p>
<ol>
<li>对地址为X的相邻路由器（X）发来的RIP报文，修改报文中的所有项目的下一跳地址都改为X，并把距离加1</li>
<li>对修改后的RIP报文的每一个项目执行以下步骤<ul>
<li>若原来路由表中没有目标网络，直接加入路由表</li>
<li>原来路由表中有目标网络，且下一跳地址为X，就直接用新的替换旧的</li>
<li>如果下一跳地址不为X则判断收到的距离是否小于当前距离，如果小于当前距离进行更新，否则什么都不做（相等也什么都不做）</li>
</ul>
</li>
<li>若3分钟没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达（距离16）</li>
<li>返回</li>
</ol>
<p>RIP首部（不重要）</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/RIP首部.JPG" alt="img"></p>
<p><strong>RIP协议特点</strong></p>
<p>好消息传的快，坏消息传的慢</p>
<p><strong>RIP存在问题</strong></p>
<p>网络出现故障，要经过较长时间才能传到所有路由器</p>
<p>收到故障报文前可能发送原来的报文，之后回开始循环直到距离超过16</p>
<p><strong>RIP优点</strong></p>
<p>实现简单开销小</p>
<p><strong>缺点</strong></p>
<p>RIP最大距离15限制了网络规模</p>
<p>由于交换整个路由表，随着网络规模增大开销增加</p>
<p>坏消息传播的慢，使更新过程收敛时间过长</p>
<h6 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h6><p>例题1：</p>
<p>假定网络中的路由器B的路由表有如下的项目（这三列分别表示“目的网络”、“距离”和“下一跳路由器”）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         N1     7     A</span><br><span class="line"></span><br><span class="line">​         N2     2     B</span><br><span class="line"></span><br><span class="line">​         N6     8     F</span><br><span class="line"></span><br><span class="line">​         N8     4     E</span><br><span class="line"></span><br><span class="line">​         N9     4     F</span><br></pre></td></tr></table></figure>
<p>现在B收到从C发来的路由信息（这两列分别表示“目的网络”“距离”）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         N2     4</span><br><span class="line"></span><br><span class="line">​         N3     8</span><br><span class="line"></span><br><span class="line">​         N6     4</span><br><span class="line"></span><br><span class="line">​         N8     3</span><br><span class="line"></span><br><span class="line">​         N9     5</span><br></pre></td></tr></table></figure>
<p>试求出路由器B更新后的路由表（详细说明每一个步骤）</p>
<ul>
<li>B原路由表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th>距离</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>N1</td>
<td>7</td>
<td>A</td>
</tr>
<tr>
<td>N2</td>
<td>2</td>
<td>C</td>
</tr>
<tr>
<td>N6</td>
<td>8</td>
<td>F</td>
</tr>
<tr>
<td>N8</td>
<td>4</td>
<td>E</td>
</tr>
<tr>
<td>N9</td>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>修改路由器C发送来的所有项目</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th>距离</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>N2</td>
<td>4 + 1 = 5</td>
<td>C</td>
</tr>
<tr>
<td>N3</td>
<td>8 + 1 = 9</td>
<td>C</td>
</tr>
<tr>
<td>N6</td>
<td>4 + 1 = 5</td>
<td>C</td>
</tr>
<tr>
<td>N8</td>
<td>3 + 1 = 4</td>
<td>C</td>
</tr>
<tr>
<td>N9</td>
<td>5 + 1 = 6</td>
<td>C</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>根据每一条信息更新B路由表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N2 4 C N2在B路由表中存在，且下一跳为C，进行替换 将原表N2 2 C更新为N2 5 C</span><br><span class="line">N3 9 C N3在B路由表中不存在，直接加入B路由表中 N3 9 C</span><br><span class="line">N6 5 C N6在B路由表中存在，下一跳地址不为C，但距离5小于原距离8，将原表N6 8 F更新为N6 5 C</span><br><span class="line">N8 4 C N8在B路由表中存在，下一跳地址不为C，距离4等于原距离4，不进行操作</span><br><span class="line">N9 4 C N9在B路由表中存在，下一跳地址不为C，距离6大于原距离4，不进行操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>B更新后的路由表</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th>距离</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>N1</td>
<td>7</td>
<td>A</td>
</tr>
<tr>
<td>N2</td>
<td>5</td>
<td>C</td>
</tr>
<tr>
<td>N3</td>
<td>9</td>
<td>C</td>
</tr>
<tr>
<td>N6</td>
<td>5</td>
<td>C</td>
</tr>
<tr>
<td>N8</td>
<td>4</td>
<td>E</td>
</tr>
<tr>
<td>N9</td>
<td>4</td>
<td>F</td>
</tr>
</tbody>
</table>
</div>
<p>例题2：</p>
<p>假定网络中的路由器A的路由表有如下的项目（格式同上题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      N1      4      B</span><br><span class="line"></span><br><span class="line">​      N2      2      C</span><br><span class="line"></span><br><span class="line">​      N3      1      F</span><br><span class="line"></span><br><span class="line">​      N4      5      G</span><br></pre></td></tr></table></figure>
<p>  现将A收到从C发来的路由信息（格式同上题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      N1      2</span><br><span class="line"></span><br><span class="line">​      N2      1</span><br><span class="line"></span><br><span class="line">​      N3      3</span><br><span class="line"></span><br><span class="line">​      N4      7</span><br></pre></td></tr></table></figure>
<p>试求出路由器A更新后的路由表（详细说明每一个步骤）</p>
<ul>
<li>A原路由表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>c</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>N1</td>
<td>4</td>
<td>B</td>
</tr>
<tr>
<td>N2</td>
<td>2</td>
<td>C</td>
</tr>
<tr>
<td>N3</td>
<td>1</td>
<td>F</td>
</tr>
<tr>
<td>N4</td>
<td>5</td>
<td>G</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>修改路由器C发送来的所有项目</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th>距离</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>N1</td>
<td>2 + 1 = 3</td>
<td>C</td>
</tr>
<tr>
<td>N2</td>
<td>1 + 1 = 2</td>
<td>C</td>
</tr>
<tr>
<td>N3</td>
<td>3 + 1 = 4</td>
<td>C</td>
</tr>
<tr>
<td>N4</td>
<td>7 + 1 = 8</td>
<td>C</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>根据每一条信息更新A路由表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N1 3 C N1在B路由表中存在，下一跳地址不为C，但距离3小于原距离4，将原表N1 4 B更新为N1 3 C</span><br><span class="line">N2 2 C N2在B路由表中存在，下一跳地址为C，直接更新，将原表N2 2 C替换为N2 2 C</span><br><span class="line">N3 4 C N3在B路由表中存在，下一跳地址不为C，距离4大于原距离1，不进行操作</span><br><span class="line">N4 8 C N4在B路由表中存在，下一跳地址不为C，距离8大于原距离5，不进行操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>A更新后的路由表</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th>距离</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>N1</td>
<td>3</td>
<td>C</td>
</tr>
<tr>
<td>N2</td>
<td>2</td>
<td>C</td>
</tr>
<tr>
<td>N3</td>
<td>1</td>
<td>F</td>
</tr>
<tr>
<td>N4</td>
<td>5</td>
<td>G</td>
</tr>
</tbody>
</table>
</div>
<h5 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h5><p>用于克服RIP缺点，基于Dijkstra（SPF）通过共享自己的链路状态信息，构建网络的全局拓扑图，从而计算最短路径，构建自己路由表。</p>
<ul>
<li>向本自治系统中所有路由器发送信息</li>
<li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</li>
<li>只有当链路状态发生变化时，路由器才用<strong>洪泛法</strong>向所有路由器发送此信息</li>
</ul>
<h5 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h5><p>是不同自治系统的路由器之间交换路由信息的协议。 </p>
<p>寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/路径选择协议对比.JPG" alt="img"></p>
<p><strong>防止环路</strong></p>
<p>如果某台BGP路由器从其外部对等体收到某条路由的AS_PATH中包含有自己的AS号那么该路由器就知道出现了环路，因而丢弃该路由。</p>
<p>AS：自治系统</p>
<h3 id="分组转发"><a href="#分组转发" class="headerlink" title="分组转发"></a>分组转发</h3><h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><p><strong>首部</strong></p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/IP首部.JPG" alt="img"></p>
<p>固定首部20字节</p>
<ul>
<li><p>版本4位：IP协议版本</p>
</li>
<li><p>首部长度4位：所以首部最大长度60字节</p>
</li>
<li><p>分区服务8位：只有用分区服务时才起效</p>
</li>
<li><p>总长度16位：首部和数据之和的长度，单位为字节，最大65535字节</p>
<p>总长度必须不超过最大传输单元MTU</p>
</li>
<li><p>标识16位：产生IP数据报标识</p>
</li>
<li><p>标志3位：只有前两位有意义 最低为位MF = 0代表这是最后分片 MF=1代表还有分片，中间一位为DF DF=0时才允许分片。</p>
</li>
<li><p>片偏移13位，指出较长的分组在分片后某片在原分组中的相对位置。（以8字节为偏移单位）</p>
</li>
<li><p>生存时间8位：TTL数据报的寿命</p>
</li>
<li><p>协议：指出IP数据报携带的数据是那种协议</p>
<p>1：ICMP    2：IGMP    4：IP    6：TCP    8：EGP    9：IGP    17：UDP    41：IPv6    50：ESP    89：OSPF</p>
</li>
<li><p>首部检验和</p>
<p>只检验首部不包括数据部分， 首部二进制16位对其相加后（若最高位有进位则加至最低位）取反便是检验和</p>
<p>例题</p>
<p>设IP数据报使用固定首部，其各字段的具体数值如图所示（除IP地址外，均为十进制表示）。试用二进制运算方法计算应当写入到首部检验和字段中的数值</p>
<table>
    <tr>
        <td rowspan="6">首部</td>
        <td rowspan="5">固定部分</td>
        <td>版本4</td>
        <td>首部长度4</td>
        <td colspan="2">区分服务8</td>
        <td colspan="4">总 长 度16</td>
    </tr>
    <tr>
        <td colspan="4">标识16</td>
        <td>标  志 4</td>
        <td colspan="3">片偏移12</td>
    </tr>
    <tr>
        <td colspan="2">生存时间8</td>
        <td colspan="2">协议8</td>
        <td colspan="4">首 部 检 验 和 16</td>
    </tr>
    <tr>
        <td colspan="8">源地址32</td>
    </tr>
    <tr>
        <td colspan="8">目的地址32</td>
    </tr>
    <tr>
        <td>可变部分</td>
        <td colspan="6">可选字段（长度可变）</td>
        <td colspan="2">填充</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td colspan="8">数据部分</td>
    </tr>
</table>

<table>
    <tr>
        <td>4</td>
        <td>5</td>
        <td colspan="2">0</td>
        <td colspan="4">28</td>
    </tr>
    <tr>
        <td colspan="4">1</td>
        <td>0</td>
        <td colspan="3">0</td>
    </tr>
    <tr>
        <td colspan="2">4</td>
        <td colspan="2">17</td>
        <td colspan="4">首 部 检 验 和 </td>
    </tr>
    <tr>
        <td colspan="8">10.12.14.5</td>
    </tr>
    <tr>
        <td colspan="8">12.6.7.9</td>
    </tr>
</table>

<table>
    <tr>
        <td>0100</td>
        <td>0101</td>
        <td colspan="2">0000 0000</td>
        <td colspan="4">0000 0000 0001 1100</td>
    </tr>
    <tr>
        <td colspan="4">0000 0000 0000 0001</td>
        <td>0000</td>
        <td colspan="3">0000 0000 0000</td>
    </tr>
    <tr>
        <td colspan="2">0000 0100</td>
        <td colspan="2">0001 0001</td>
        <td colspan="4">首 部 检 验 和 </td>
    </tr>
    <tr>
        <td colspan="8">0000 1010 0000 1100 0000 1110 0000 0101</td>
    </tr>
    <tr>
        <td colspan="8">0000 1100 0000 0110 0000 0111 0000 1001</td>
    </tr>
</table>

<table>
    <tr>
        <td>0100</td>
        <td>0101</td>
        <td>0000</td>
        <td>0000</td>
        <td>0000</td>
        <td>0000</td>
        <td>0001</td>
        <td>1100</td>
    </tr>
    <tr>
        <td>0000</td>
        <td>0000</td>
        <td>0000</td>
        <td>0001</td>
        <td>0000</td>
        <td>0000</td>
        <td>0000</td>
        <td>0000</td>
    </tr>
    <tr>
        <td>0000</td>
        <td>0100</td>
        <td>0001</td>
        <td>0001</td>
        <td colspan="4">首 部 检 验 和 </td>
    </tr>
    <tr>
        <td>0000</td>
        <td>1010</td>
        <td>0000</td>
        <td>1100</td>
        <td>0000</td>
        <td>1110</td>
        <td>0000</td>
        <td>0101</td>
    </tr>
    <tr>
        <td>0000</td>
        <td>1100</td>
        <td>0000</td>
        <td>0110</td>
        <td>0000</td>
        <td>0111</td>
        <td>0000</td>
        <td>1001</td>
    </tr>
</table>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">按16位对齐</span><br><span class="line">0100 0101 0000 0000</span><br><span class="line">0000 0000 0001 1100</span><br><span class="line">0000 0000 0000 0001</span><br><span class="line">0000 0000 0000 0000</span><br><span class="line">0000 0100 0001 0001</span><br><span class="line">0000 1010 0000 1100</span><br><span class="line">0000 1110 0000 0101</span><br><span class="line">0000 1100 0000 0110</span><br><span class="line">0000 0111 0000 1001</span><br><span class="line">-------------------</span><br><span class="line">0111 0100 0100 1110</span><br><span class="line">1000 1011 1011 0001</span><br></pre></td></tr></table></figure>
<p>所以检测和为1000 1011 1011 0001</p>
</li>
<li><p>源地址32位</p>
</li>
<li><p>目的地址32位</p>
</li>
</ul>
<h5 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h5><p>若将总长度为3820字节的数据报分片为长度不超过1420的数据报片</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/IP分片.JPG" alt="img"></p>
<h5 id="分组转发流程"><a href="#分组转发流程" class="headerlink" title="分组转发流程"></a>分组转发流程</h5><p>每个路由器都有路由表</p>
<p>路由表存储到达每一个主机所在网络的路径信息</p>
<p>路由表结构</p>
<p>| 目的网络 | 下一跳 | 交付接口 |</p>
<p>根据下一跳地址确定下一跳路由器多次间接交付后直接交付。</p>
<p>查询顺序</p>
<ul>
<li>特定主机路由</li>
<li>目的网络路由</li>
<li>默认路由</li>
</ul>
<p>分组转发算法（掩码存在时采用最长前缀匹配）</p>
<ol>
<li>从数据报中提取首部信息得到IP地址提取目的网络地址</li>
<li>若目的网络与此路由器直接相连则直接交付</li>
<li>查找路由表 特定主机$\rightarrow$目的网络$\rightarrow$默认路由</li>
<li>否则报告错误</li>
</ol>
<h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><p>设某路由器建立了如下路由表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th style="text-align:center">ip二进制</th>
<th style="text-align:center">子网掩码</th>
<th>子网掩码二进制</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>128.96.39.0</td>
<td style="text-align:center">1000 0000 0110 0000 0010 0111 0000 0000</td>
<td style="text-align:center">255.255.255.128</td>
<td>1111 1111 1111 1111 1111 1111 1000 0000</td>
<td>接口m0</td>
</tr>
<tr>
<td>128.96.39.128</td>
<td style="text-align:center">1000 0000 0110 0000 0010 0111 1000 0000</td>
<td style="text-align:center">255.255.255.128</td>
<td>1111 1111 1111 1111 1111 1111 1000 0000</td>
<td>接口m1</td>
</tr>
<tr>
<td>128.96.40.0</td>
<td style="text-align:center">1000 0000 0110 0000 0010 1000 0000 0000</td>
<td style="text-align:center">255.255.255.128</td>
<td>1111 1111 1111 1111 1111 1111 1000 0000</td>
<td>R2</td>
</tr>
<tr>
<td>192.4.153.0</td>
<td style="text-align:center">1100 0000 0000 0100 1001 1001 0000 0000</td>
<td style="text-align:center">255.255.255.192</td>
<td>1111 1111 1111 1111 1111 1111 1100 0000</td>
<td>R3</td>
</tr>
<tr>
<td>*（默认）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td>-</td>
<td>R4</td>
</tr>
</tbody>
</table>
</div>
<p> 现共收到5个分组，求下一跳</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th>ip地址</th>
<th>255.255.255.128与</th>
<th>255.255.255.192与</th>
<th>对应ip</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>128.96.39.10</td>
<td>1000 0000 0110 0000 0010 0111 0000 1010</td>
<td>1000 0000 0110 0000 0010 0111 0000 0000（128.96.39.0）</td>
<td>1000 0000 0110 0000 0010 0111 0000 0000（128.96.39.0）</td>
<td>128.96.39.0</td>
<td>接口m0</td>
</tr>
<tr>
<td>128.96.40.12</td>
<td>1000 0000 0110 0000 0010 1000 0000 1100</td>
<td>1000 0000 0110 0000 0010 1000 0000 0000（128.96.40.0）</td>
<td>1000 0000 0110 0000 0010 1000 0000 0000（128.96.40.0）</td>
<td>128.96.40.0</td>
<td>R2</td>
</tr>
<tr>
<td>128.96.40.151</td>
<td>1000 0000 0110 0000 0010 1000 1001 0111</td>
<td>1000 0000 0110 0000 0010 1000 1000 0000（128.96.40.128）</td>
<td>1000 0000 0110 0000 0010 1000 1000 0000（128.96.40.128）</td>
<td>*</td>
<td>R4</td>
</tr>
<tr>
<td>192.4.153.17</td>
<td>1100 0000 0000 0100 1001 1001 0001 0001</td>
<td>1100 0000 0000 0100 1001 1001 0000 0000（192.4.153.0）</td>
<td>1100 0000 0000 0100 1001 1001 0000 0000（192.4.153.0）</td>
<td>192.4.153.0</td>
<td>R3</td>
</tr>
<tr>
<td>192.4.153.90</td>
<td>1100 0000 0000 0100 1001 1001 0101 1010</td>
<td>1100 0000 0000 0100 1001 1001 0000 0000（192.4.153.0）</td>
<td>1100 0000 0000 0100 1001 1001 0100 0000（192.4.153.64）</td>
<td>*</td>
<td>R4</td>
</tr>
</tbody>
</table>
</div>
<p>例题2</p>
<p>如图，网络145.13.0.0/16划分为四个子网$N_1,N_2,N_3,N_4$，这四个子网与路由器R链接的接口分别为m0,m1,m2,m3。路由器R的第五个接口m4链接至互联网</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/路径转发.JPG" alt="img"></p>
<ol>
<li>给出路由器R的路由表</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的ip</th>
<th>地址掩码</th>
<th>下一跳</th>
</tr>
</thead>
<tbody>
<tr>
<td>145.13.0.0</td>
<td>255.255.192.0</td>
<td>直接交付 接口m0</td>
</tr>
<tr>
<td>145.13.64.0</td>
<td>255.255.192.0</td>
<td>直接交付 接口m1</td>
</tr>
<tr>
<td>145.13.128.0</td>
<td>255.255.192.0</td>
<td>直接交付 接口m2</td>
</tr>
<tr>
<td>145.13.192.0</td>
<td>255.255.192.0</td>
<td>直接交付 接口m3</td>
</tr>
<tr>
<td>其他</td>
<td>~</td>
<td>~ 接口m4</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>路由器R收到一个分组，其目的地址是145.13.160.78给出这个分组如何转发</p>
<p>拆包首部查找目标网络地址$\rightarrow$根据IP:145.13.160.78找到目标网络145.13.128.0$\rightarrow$由接口m2直接交付</p>
</li>
</ol>
<h4 id="ICMP（网际控制报文协议）"><a href="#ICMP（网际控制报文协议）" class="headerlink" title="ICMP（网际控制报文协议）"></a>ICMP（网际控制报文协议）</h4><h5 id="概念与作用"><a href="#概念与作用" class="headerlink" title="概念与作用"></a>概念与作用</h5><ul>
<li>IP协议为不可靠传输</li>
<li>转发过程中可能丢失数据</li>
<li>需可靠传输要实现一种机制，报告数据报转发中遇到的各种错误</li>
</ul>
<p>ICMP数据包是封装在IP数据报中的</p>
<h5 id="ICMP数据报格式"><a href="#ICMP数据报格式" class="headerlink" title="ICMP数据报格式"></a>ICMP数据报格式</h5><p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/ICMP数据报.JPG" alt="img"></p>
<h5 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h5><ul>
<li>ICMP差错报告报文</li>
<li>ICMP询问（请求/应答）报文</li>
</ul>
<h5 id="ICMP报文类型"><a href="#ICMP报文类型" class="headerlink" title="ICMP报文类型"></a>ICMP报文类型</h5><p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/ICMP报文类型.JPG" alt="img"></p>
<h5 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h5><ul>
<li><p>终点不可达</p>
<p>路由器或主机不能交付数据时向源点发送</p>
</li>
<li><p>时间超时</p>
<p>收到生存时间为0的数据报，时丢弃并向源点发送</p>
</li>
<li><p>参数问题</p>
<p>路由器或主机收到的数据报首部有字段的值不正确时丢弃并向源点发送</p>
</li>
<li><p>改变路由（重定向）</p>
<p>路由器把报文把报文发送给主机，让主机直到下次将数据报发给另外路由器（可通过更好的路由）</p>
</li>
</ul>
<h5 id="不应发送ICMP差错报告报文的情况"><a href="#不应发送ICMP差错报告报文的情况" class="headerlink" title="不应发送ICMP差错报告报文的情况"></a>不应发送ICMP差错报告报文的情况</h5><ul>
<li>对ICMP差错报告报文，不再发送ICMP差错报告报文</li>
<li>对于第一个分片后的所有后续分片都不发生差错报告报文</li>
<li>对具有多播地址的数据报，都不发送ICMP差错报告报文</li>
<li>对具有特殊地址（127.0.0.0或0.0.0.0）不发送ICMP差错报告报文</li>
</ul>
<h5 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h5><ul>
<li><p>回送请求和回答</p>
<p>由主机或路由器向特定主机发出询问，收到的主机必须给源主机或路由器发送ICMP回送回答报文（判断是否可达PING）</p>
</li>
<li><p>时间戳请求和回答</p>
<p>请某台主机或路由器回答当前日期和时间（32位 从1900.1.1开始的秒数）</p>
</li>
</ul>
<h3 id="NAT-amp-VPN"><a href="#NAT-amp-VPN" class="headerlink" title="NAT&amp;VPN"></a>NAT&amp;VPN</h3><h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h4><p>实现在专用网络上使用专用地址的主机于互联网主机通信</p>
<h5 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h5><ul>
<li>离开专用网时：替换源地址，将内部地址替换为全球地址</li>
<li>进入专用网络时：替换目标地址，将全球地址替换为内部地址</li>
</ul>
<p>专用网内部主机不能充当服务器</p>
<h5 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h5><p>把运输层端口也利用，使使多个本地地址主机工业一个NAT路由器上的全球地址。</p>
<h4 id="虚拟专用网络VPN"><a href="#虚拟专用网络VPN" class="headerlink" title="虚拟专用网络VPN"></a>虚拟专用网络VPN</h4><p>利用互联网作为本机构各专用网之间的通信载体</p>
<p>不使用通信专线实现专用网的效果</p>
<ul>
<li>隧道技术</li>
</ul>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>解决IPv4不够使用</p>
<ul>
<li>地址128位</li>
<li>基本首部40字节，有灵活的扩展首部</li>
<li>8字节对其</li>
</ul>
<p>首部结构</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/IPv6.JPG" alt="img">采用冒号十六进制记法</p>
<p>可用零压缩（只能一次）</p>
<p>相邻的0用::代替</p>
<h2 id="运输层（传输层）"><a href="#运输层（传输层）" class="headerlink" title="运输层（传输层）"></a>运输层（传输层）</h2><h3 id="传输层协议概述"><a href="#传输层协议概述" class="headerlink" title="传输层协议概述"></a>传输层协议概述</h3><h4 id="传输层地位"><a href="#传输层地位" class="headerlink" title="传输层地位"></a>传输层地位</h4><ul>
<li>面向通信的最高部分，用户功能的最低层</li>
<li>只有网络边缘部分主机协议栈才有传输层</li>
</ul>
<h4 id="传输层作用"><a href="#传输层作用" class="headerlink" title="传输层作用"></a>传输层作用</h4><ul>
<li>为应用程序提供逻辑通信服务（真正端点是主机中的进程）</li>
<li>在不可靠网络服务上提供可靠服务</li>
</ul>
<h4 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h4><ul>
<li>用户数据报协议UDP</li>
<li>传输控制协议TCP</li>
</ul>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>网络系统不能用操作系统进程标识符来区分不同进程所以使用协议端口号解决</p>
<p><strong>端口</strong>：应用进程在传输层的地址</p>
<p><strong>服务器端口号</strong></p>
<p>熟知端口 0 ~ 1023</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FTP: 21	TELNET: 23	SMTP: 25	DNS: 53	TFTP: 69</span><br><span class="line">HTTP: 80	SNMP: 161	HTTPS: 443</span><br></pre></td></tr></table></figure>
<p>登记端口 1024 ~ 49151</p>
<p><strong>客户端端口号</strong>（短暂端口号）</p>
<p>49153 ~ 65535</p>
<h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul>
<li>UDP是无连接的</li>
<li>UDP尽最大努力交付，不保证可靠交付</li>
<li>UDP面向报文</li>
<li>UDP没有拥塞控制</li>
<li>UDP支持一对一、一对多、和多对多交互通信</li>
<li>UDP首部开销小 8字节</li>
</ul>
<h4 id="报文首部格式"><a href="#报文首部格式" class="headerlink" title="报文首部格式"></a>报文首部格式</h4><p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/UDP首部.JPG" alt="img"></p>
<p>UDP检验和 12字节伪首部，首部与数据一同检测</p>
<h5 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h5><p>例题1：如果程序愿意通过UDP完成可靠传输，这可能吗？</p>
<p>可能，只要UDP手动实现了与TCP相同的确认、重传便可做到可靠传输，大部分关键帧+普通帧的应用中的关键帧便是如此实现的。</p>
<p>例题2：某个应用进程使用运输层的用户数据报UDP，然而继续向下交给IP层后，又封装成IP数据报。既然都是数据报，可否跳过UDP而直接交给IP层？哪些功能UDP提供了但IP没提提供？</p>
<p>不能跳过，IP数据报只能找到对应的主机，找不到主机开放的对应端口，而UDP可以。</p>
<p>例题3：一个UDP用户数据的数据字段为8192季节。在数据链路层要使用以太网来传送。试问应当划分为几个IP数据报片？说明每一个IP数据报字段长度和片偏移字段的值。</p>
<p>UDP数据报总长 8192 + 8 = 8200</p>
<p>以太网数据部分最大长度为1500，但是需要减去ip的首部20，因为问的是ip数据报的字段长度，所以不需要减去其中的UDP首部，最长帧中ip数据字段长度为1480。</p>
<p>8200 $\div$ 1480 = 5 …… 800.</p>
<p>所以前5个ip数据报数据字段长度为1480，最后一个ip数据报数据字段长度为800. </p>
<p>1480 $\div $ 8 = 185</p>
<p>片偏移为0, 185, 370, 555, 925</p>
<p>例题4：UDP用户数据报的首部十六进制表示是：06 32 00 45 00 1C  E2 17.试求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报是从客户发送给服务器发送给客户？使用UDP的这个服务器程序是什么？</p>
<p>首部: 06 32 00 45 00 1C E2 17</p>
<p>源端口: 06 32 $\rightarrow$ 1571</p>
<p>目的端口: 00 45 $\rightarrow $ 69</p>
<p>长度: 00 1C $\rightarrow $  28</p>
<p>检验和: E2 17 $\rightarrow$ 60449 $\rightarrow$ 1110 1100 0010 0001</p>
<p>目的端口小于1023所以是由客户端发给服务器，69是TFTP</p>
<h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><h4 id="TCP主要特点"><a href="#TCP主要特点" class="headerlink" title="TCP主要特点"></a>TCP主要特点</h4><ul>
<li>TCP是面向链接的（建立-传输-释放）</li>
<li>每条TCP链接只能有两个端点</li>
<li>TCP提供可靠交付服务（无差错、不丢失、不重复、按序到达）</li>
<li>全双工</li>
<li>面向字节流（TCP将应用程序交下来的数据看成一串无结构的字节流）</li>
</ul>
<h4 id="TCP报文段首部"><a href="#TCP报文段首部" class="headerlink" title="TCP报文段首部"></a>TCP报文段首部</h4><p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/TCP首部.JPG" alt="img"></p>
<ul>
<li><p>源端口和目的端口（各占2字节）</p>
</li>
<li><p>序号字段（4字节）</p>
<p>TCP链接中传送的数据流中的每一个字节都有一个编号</p>
<p>序号字段指的是本报文段所发送的数据的第一个字节的序号</p>
<p>[0,$2^{32}$-1]共$2^{32}$个序号，增加到$2^{32}-1$后下一个序号又会回到0</p>
</li>
<li><p>确认号（4字节）</p>
<p>期望收到对方的下一个报文段的数据的第一字节的序号</p>
</li>
<li><p>数据偏移（4<strong>位</strong>）</p>
<p>指出TCP报文的数据其实处距TCP报文段的起始处有多远</p>
<p>以4字节（32位）为单位，最大60字节</p>
</li>
<li><p>保留字段（6<strong>位</strong>）</p>
<p>当前为0 保留为今后使用</p>
</li>
<li><p>紧急URG（1<strong>位</strong>）</p>
<p>URG = 1时表明紧急指针字段有效，告诉系统此报文中有紧急数据，应尽快传送</p>
</li>
<li><p>确认ACK（1<strong>位</strong>）</p>
<p>ACK = 1时确认号字段才有效</p>
</li>
<li><p>推送PSH（1<strong>位</strong>）</p>
<p>收到PSH = 1应尽快交付接收应用程序进程，不再等待缓冲区都填满再向上交付</p>
</li>
<li><p>复位RST（1<strong>位</strong>）</p>
<p>RST = 1表明TCP链接中出现严重差错（主机崩溃等），必须释放连接，然后重新建立传输连接</p>
</li>
<li><p>同步SYN（1<strong>位</strong>）</p>
<p>SYN = 1而ACK = 0时，表明这是一个连接请求报文段，对方若同意建立连接，则应在响应报文段中使用SYN = 1和ACK = 1</p>
</li>
<li><p>终止FIN（1<strong>位</strong>）</p>
<p>用来释放一个连接  FIN = 1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p>
</li>
<li><p>窗口字段（2字节）</p>
<p>接收窗口大小，从本报文段首部确认号算起接收方目前允许对方发送的数据量（单位字节）用于进行流量控制</p>
</li>
<li><p>检验和（2字节）</p>
<p>检验和字段检验包括首部和数据这两部分，在计算检验和时，要在TCP报文前面加上12字节伪首部</p>
</li>
<li><p>紧急指针字段（2字节）</p>
</li>
<li><p>本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据最前方）</p>
</li>
<li><p>选项字段（非固定首部长度可变）</p>
</li>
<li><p>填充</p>
<p>填充至4字节对齐</p>
</li>
</ul>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><ul>
<li>无差错</li>
<li>无丢失</li>
<li>无重复</li>
<li>顺序接收</li>
</ul>
<h4 id="理想传输"><a href="#理想传输" class="headerlink" title="理想传输"></a>理想传输</h4><ul>
<li>传输信道不产生差错</li>
<li>不管发送方以多快的速度发送，接收方总是来得及处理收到的数据</li>
</ul>
<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><ul>
<li>每发送完一个报文段，就停止发送，等待对方确认，收到确认后再发送下一个分段。</li>
<li>全双工通信，双方既是发送方也是接收方</li>
</ul>
<h5 id="超时重传时间与基本原则"><a href="#超时重传时间与基本原则" class="headerlink" title="超时重传时间与基本原则"></a>超时重传时间与基本原则</h5><ul>
<li>重传时间： 比往返时间RTT要长一些</li>
<li>实现重发： 缓存已发送的分段的副本</li>
<li>避免重复： 为每个分段编号</li>
</ul>
<p>发送方再发送完一个报文后，如果再超时重传时间内没有收到确认，就自动重发该报文段</p>
<p>接收端如果收到重复的报文段，则丢弃该报文段并发送报文段的确认报文</p>
<h4 id="自动重传请求ARQ"><a href="#自动重传请求ARQ" class="headerlink" title="自动重传请求ARQ"></a>自动重传请求ARQ</h4><p>基于以上确认和重传的可靠传输协议称为自动重传请求ARQ </p>
<p>重传自动进行，不需要接收方请求发送方重传某个分段</p>
<h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><p>通过流水线传输提高信道利用率</p>
<ul>
<li>通过滑动窗口协议实现连续ARQ</li>
<li>滑动窗口是TCP协议的精髓，不止实现ARQ，还实现<strong>流量控制</strong>和<strong>拥塞控制</strong></li>
</ul>
<p><strong>连续ARQ原理</strong></p>
<ul>
<li>发送方有一个发送窗口，位于发送窗口内的分段都可以连续发送出去，而不需要等待对方确认</li>
<li>发送方每收到一个确认，就把发送窗口向前滑动一个分段的位置</li>
</ul>
<p><strong>解决ARQ差错、丢失、迟到</strong></p>
<ul>
<li>接收端： 收到一个确认一个</li>
<li>发送端：超时重传</li>
</ul>
<p><strong>解决连续ARQ差错、丢失、迟到</strong></p>
<ol>
<li><p>选择确认：哪一个分段的确认没有收到就重传哪个分段</p>
<p>前提：接收方能给出明确的确认</p>
<p>选择重传 SR协议 实现复杂度高</p>
</li>
<li><p>Go-back-N重传</p>
<p>接收方无法给出明确确认，采用<strong>累计确认</strong>的方式，只确认按需到达的的分段</p>
<p>重传：超时后将没有确认的分段全部重发</p>
<p>回退重传 GBN协议</p>
<ul>
<li>如果发送方发送了前 5 个分段，而中间的第 3 个分段丢失了。这时接收方只能对前两个分段发出确认。发送方无法知道后面三个分段的下落，而只好把后面的三个分段都再重传一次。</li>
<li>这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分段</li>
</ul>
</li>
</ol>
<p><strong>TCP是一种连续ARQ协议，综合了SR与Go-back-N</strong></p>
<h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><ul>
<li>不必对收到的分段逐个确认，而是累计一段时间后对按序到达的最后一个分段发送确认</li>
<li>优点：容易实现，即使确认丢失也不必重传</li>
<li>缺点：不能像发送方反映出已经正确收到的所有分组信息</li>
</ul>
<h4 id="窗口相关"><a href="#窗口相关" class="headerlink" title="窗口相关"></a>窗口相关</h4><ul>
<li>后沿 <ul>
<li>不动 没有收到新的确认</li>
<li>前移 收到新的确认</li>
</ul>
</li>
<li>前沿<ul>
<li>不动 没有收到新的确认</li>
<li>后移 对方通知窗口缩小（一半不出现）</li>
<li>前移 其他情况</li>
</ul>
</li>
</ul>
<p>在双方建立连接的三次握手过程中要确定窗口大小</p>
<p>A与B建立连接 B告诉A自己的接收窗口大小</p>
<p>A根据B接收窗口大小设置发送窗口大小</p>
<p>窗口初始位置位于缓存最小编号的位置</p>
<h4 id="TCP超时重传时间设置"><a href="#TCP超时重传时间设置" class="headerlink" title="TCP超时重传时间设置"></a>TCP超时重传时间设置</h4><ul>
<li>太短会引起多报文段不必要传输</li>
<li>太长会使网络空闲时间增大</li>
<li>TCP采取自适应算法，记录一个报文发出到收到确认的时间RTT</li>
</ul>
<p>加权平均往返时间$RTT_s$初始为第一次测量的RTT，之后每次按下式计算</p>
<p>$RTT_S = (1-\alpha) \times (旧RTT_S) + \alpha \times(新的RTT样本)$</p>
<p>0 &lt;= $\alpha$ &lt; 1若$\alpha$接近于0，标识RTT更新较慢，接近于1表示更新较快</p>
<p>RFC2988推荐$\alpha = \frac 18$</p>
<p>重传超时$RTO = RTT_S + 4 \times RTT_D$ </p>
<p>RTT偏差加权平均值$RTT_D$</p>
<p>$RTT_D = (1- \beta) \times (旧RTT_D) + \beta \times|RTT_S - 新RTT样本|$</p>
<p>推荐$\beta = \frac 14$</p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>让发送方的发送速率不要太快，既让接收方来得及接收，也不使网络发生拥塞</p>
<p>利用滑动窗口可以方便实现流量控制</p>
<h5 id="滑动窗口进行流量控制"><a href="#滑动窗口进行流量控制" class="headerlink" title="滑动窗口进行流量控制"></a>滑动窗口进行流量控制</h5><p>让接收端通知发送端接收窗口大小</p>
<p>举例</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/TCP流量控制.JPG" alt="img"></p>
<p><strong>可能发生死锁</strong></p>
<ul>
<li><p>接收端通知发送端接收窗口大小的报文丢失</p>
</li>
<li><p>接收端一直等待发送端发送的数据</p>
</li>
<li><p>发送端一直等待接收端发送非零窗口通知</p>
</li>
</ul>
<p><strong>解决死锁</strong></p>
<ul>
<li><p>TCP为每一个连接设有持续计时器</p>
</li>
<li><p>只要有一方收到另一方的零窗口通知，就启动持续计时器</p>
</li>
<li><p>若持续计时器时间到期，就发送零窗口探测报文，接收到探测报文的一方在确认这个报文时就给出了现在的窗口值</p>
</li>
<li>如果窗口仍然是0，则收到确认报文的一方重设持续计时器</li>
<li>若不是零，死锁被打破</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h5 id="拥塞"><a href="#拥塞" class="headerlink" title="拥塞"></a>拥塞</h5><p>某段时间，对网络中某资源的需求超过了该资源所能提供的可用部分，网络性能变坏（网络吞吐量随输入负荷的增大而下降），这种现象称为拥塞</p>
<h5 id="拥塞控制本质"><a href="#拥塞控制本质" class="headerlink" title="拥塞控制本质"></a>拥塞控制本质</h5><p>防止过多数据注入网络中，使网络中的路由器或链路不过载</p>
<h5 id="拥塞控制的解决方法"><a href="#拥塞控制的解决方法" class="headerlink" title="拥塞控制的解决方法"></a>拥塞控制的解决方法</h5><ul>
<li><p><strong>开环控制</strong>：</p>
<p>在设计网络时先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。适用于用户固定的小型网络</p>
</li>
<li><p><strong>闭环控制</strong>：</p>
<p>基于反馈环路概念，属于闭环控制的有以下几种措施</p>
<ul>
<li>检测网络系统以便检测到拥塞在何时、何处发生</li>
<li>将拥塞发生的信息传送到可采取行动的地方</li>
<li>调整网络系统的运行以解决出现的问题</li>
</ul>
<p>TCP采取的基于窗口的方法进行拥塞控制属于闭环控制</p>
<p>TCP发送方维护一个拥塞窗口CWND</p>
<ul>
<li>拥塞窗口大小取决于网络拥塞程度，并动态变化</li>
<li>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量</li>
</ul>
<p>真正的发送窗口值 = min(接收窗口值,拥塞窗口值)</p>
</li>
</ul>
<h5 id="拥塞的判断"><a href="#拥塞的判断" class="headerlink" title="拥塞的判断"></a>拥塞的判断</h5><ul>
<li>重传定时器超时</li>
<li>收到3个相同的确认（ACK）</li>
</ul>
<h5 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h5><ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
<p><strong>慢开始</strong></p>
<p>由小到大逐渐增大拥塞窗口的数值</p>
<p>拥塞窗口初始值cwnd</p>
<p>旧规定：1至2个发送方最大报文段SMSS的值</p>
<p>新规定SFC5681：不超过2至4个SMSS的数值</p>
<p>慢开始门限ssthresh（状态变量）：防止拥塞窗口cwnd过大引起网络拥塞</p>
<p>拥塞窗口cwnd控制方法：在每收到一个<strong>对新的报文段的确认</strong>后，可以把拥塞窗口cwnd每次增加量最多一个SMSS的值</p>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/慢开始.JPG" alt="img"></p>
<p>慢开始门限ssthresh使用</p>
<ul>
<li>当cwnd &lt; ssthresh时使用慢开始算法</li>
<li>当cwnd &gt; ssthresh时停止使用慢开始转而使用拥塞避免算法</li>
<li>当cwnd = ssthresh时既可以使用慢开始也可以使用拥塞避免</li>
</ul>
<h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><p><strong>思路</strong></p>
<p>让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍（加法增大）</p>
<h5 id="当网络出现拥塞（重传定时器超时）"><a href="#当网络出现拥塞（重传定时器超时）" class="headerlink" title="当网络出现拥塞（重传定时器超时）"></a>当网络出现拥塞（重传定时器超时）</h5><p>$ssthresh = max(\frac {cwnd}2, 2)$</p>
<p>$cwnd = 1$</p>
<p>执行慢开始算法</p>
<h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h5><p>发送方只要一连收到三个重复确认就直到立即进行重传，这样就不会出现超时，发送方也不会误认为出现了网络拥塞</p>
<h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><ul>
<li><p>慢开始门限$ssthresh = \frac {cwnd}2$</p>
</li>
<li><p>新拥塞窗口cwnd = 慢开始门限ssthresh</p>
</li>
<li><p>开始执行拥塞避免算法</p>
</li>
</ul>
<p><img src="/2019/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/拥塞控制.JPG" alt="img"></p>
<h5 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h5><p>例题1：设TCP的ssthresh的初始值为8(单位为报文段)。当拥塞窗口上升到12时网络发生了超时，TCP使用慢开始和拥塞避免。试分别求出第1次到第15次传输的各拥塞窗口大小。你能说明拥塞控制窗口每一次变化的原因吗？ 答案：拥塞窗口大小分别为：1，2，4，8，9，10，11，12，1，2，4，6，7，8，9.</p>
<ul>
<li><p>第一轮次</p>
<p>cwnd = 1 (慢开始cwnd初始值)</p>
</li>
<li><p>第二轮次</p>
<p>cwnd = 2（慢开始指数增长）</p>
</li>
<li><p>第三轮次</p>
<p>cwnd = 4  (慢开始指数增长)</p>
</li>
<li><p>第四轮次</p>
<p>cwnd = 8  (慢开始指数增长达到ssthresh)</p>
</li>
<li><p>第五轮次</p>
<p>cwnd = 9  (拥塞避免线性增长)</p>
</li>
<li><p>第六轮次</p>
<p>cwnd = 10(拥塞避免线性增长)</p>
</li>
<li><p>第七轮次</p>
<p>cwnd = 11(拥塞避免线性增长)</p>
</li>
<li><p>第八轮次</p>
<p>cwnd = 12(拥塞避免线性增长)</p>
</li>
<li><p>第九轮次</p>
<p>cwnd = 1 sshtresh = 6(重传定时器超时)</p>
</li>
<li><p>第十轮次</p>
<p>cwnd = 2（慢开始指数增长）</p>
</li>
<li><p>第十一轮次</p>
<p>cwnd = 4（慢开始指数增长）</p>
</li>
<li><p>第十二轮次</p>
<p>cwnd = 6（慢开始指数增长达到ssthresh）</p>
</li>
<li><p>第十三轮次</p>
<p>cwnd = 7（拥塞避免线性增长）</p>
</li>
<li><p>第十四轮次</p>
<p>cwnd = 8（拥塞避免线性增长）</p>
</li>
<li><p>第十五轮次</p>
<p>cwnd = 9（拥塞避免线性增长）</p>
</li>
</ul>
<h3 id="传输连接的三个阶段"><a href="#传输连接的三个阶段" class="headerlink" title="传输连接的三个阶段"></a>传输连接的三个阶段</h3><ul>
<li>连接建立</li>
<li>数据传送</li>
<li>连接释放</li>
</ul>
<h4 id="建立连接过程中的三个问题"><a href="#建立连接过程中的三个问题" class="headerlink" title="建立连接过程中的三个问题"></a>建立连接过程中的三个问题</h4><ul>
<li>要使每一方能够确知对方存在</li>
<li>允许双方协商一些参数（最大窗口值、是否使用窗口扩大选项和时间戳选项）</li>
<li>能够传输实体资源（缓存大小、连接表中的项目）进行分配</li>
</ul>
<h4 id="客户端-服务器方式"><a href="#客户端-服务器方式" class="headerlink" title="客户端-服务器方式"></a>客户端-服务器方式</h4><ul>
<li>主动发起连接建立的应用进程叫客户（client）</li>
<li>被动等待连接建立的应用进程叫服务器（server）</li>
</ul>
<h4 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h4><ul>
<li>TCP建立连接的过程叫做握手</li>
<li>握手需要在客户端和服务之间交换三个TCP报文段，叫做<strong>三报文握手</strong>（三次握手）</li>
<li>采用三报文握手主要是为了防止已失效的连接请求报文突然又传输到了，而产生错误。</li>
</ul>
<h5 id="建立过程"><a href="#建立过程" class="headerlink" title="建立过程"></a>建立过程</h5><ul>
<li><p>客户机向服务器发送连接请求报文段</p>
<p>首部同步位 SYN = 1 选择序号 seq = x表明本报文传送数据的第一个数据字节的序号为x ACK（确认） = 0</p>
</li>
<li><p>服务器收到连接请求报文后，若同意，则发回确认报文段</p>
<p>同步位 SYN = 1 ACK（确认） = 1 确认号ack  = x + 1，自己选择序号seq = y</p>
</li>
<li><p>客户搜到确认报文后向服务器发送确认报文 ACK = 1 确认号 = y + 1</p>
<p>客户TCP通知上层应用进程，连接已建立。（本段已经可以传送数据）</p>
</li>
</ul>
<h5 id="为何需要第三次握手"><a href="#为何需要第三次握手" class="headerlink" title="为何需要第三次握手"></a>为何需要第三次握手</h5><p>为了防止已失效的连接请求报文段突然达到服务器（如果没有第三次握手，服务器在发送确认报文后以为链接已经建立，等待接收数据，浪费资源）</p>
<p>若有第三次握手，上述连接无法建立</p>
<h4 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h4><ul>
<li>数据传输结束后，通信双方都可以释放连接</li>
<li>TCP连接的释放过程叫四报文握手（四次挥手）</li>
</ul>
<h5 id="释放过程"><a href="#释放过程" class="headerlink" title="释放过程"></a>释放过程</h5><p>假设A与B要释放TCP连接</p>
<ul>
<li><p>A的应用程序进程向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接，A把连接释放报文段 FIN = 1 序号seq = u等待B确认</p>
</li>
<li><p>B收到释放报文，发送确认 ACK = 1 确认号 ack = u + 1 序号seq = v B的TCP进程通知高层应用程序进程，此时A到B的方向连接释放，TCP处于半关闭状态但此时B若向A发送数据A仍要接收</p>
</li>
<li><p>若B已经没有要向A发送的数据，其应用程序进程也要通知TCP释放连接</p>
<p>发送连接释放报文 FIN = 1 ACK=1 序号seq =  w 确认号 ack = u + 1</p>
</li>
<li><p>A接到B的连接释放报文，必须发出确认 ACK = 1 确认号 ack = w + 1序号 seq = u + 1</p>
</li>
<li><p>B收到A的确认报文后关闭TCP连接</p>
</li>
<li><p>A等待2MSL后关闭TCP连接</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/" class="post-title-link" itemprop="url">操作系统理论梳理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-17 22:00:50" itemprop="dateCreated datePublished" datetime="2019-12-17T22:00:50+08:00">2019-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%BD%92%E7%BA%B3/" itemprop="url" rel="index"><span itemprop="name">理论归纳</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OS理论梳理"><a href="#OS理论梳理" class="headerlink" title="OS理论梳理"></a>OS理论梳理</h1><p>[TOC]</p>
<h2 id="3大基本操作系统（批处理、实时、分时）的主要特点"><a href="#3大基本操作系统（批处理、实时、分时）的主要特点" class="headerlink" title="3大基本操作系统（批处理、实时、分时）的主要特点"></a>3大基本操作系统（批处理、实时、分时）的主要特点</h2><h3 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>系统资源利用率高</li>
<li>系统吞吐量大</li>
<li>平均周转时间长</li>
<li>无交互能力</li>
</ul>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ol>
<li>用户将作业交给系统操作员</li>
<li>系统操作员将许多用户作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续作业流</li>
<li>启动操作系统</li>
<li>系统自动、依次执行每个作业</li>
<li>由操作员将作业结果交给用户</li>
</ol>
<h4 id="追求目标"><a href="#追求目标" class="headerlink" title="追求目标"></a>追求目标</h4><p>提高资源利用率，增加作业处理吞吐量</p>
<h4 id="批处理系统中的作业"><a href="#批处理系统中的作业" class="headerlink" title="批处理系统中的作业"></a>批处理系统中的作业</h4><ul>
<li>用户程序</li>
<li>数据</li>
<li>作业说明书</li>
</ul>
<h4 id="成批"><a href="#成批" class="headerlink" title="成批"></a>成批</h4><p>通常由若干个作业组成，用户提交作业后只能等待处理结果，不能干预自己作业的执行</p>
<h4 id="批作业处理"><a href="#批作业处理" class="headerlink" title="批作业处理"></a>批作业处理</h4><p>对一批作业中的每个作业进行相同处理：从磁带读入用户作业和编译链接程序，编译链接用户作业生成可执行程序；启动执行；执行并输出结果</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>慢速的输入输出处理直接由主机来完成，输入输出时，cpu处于等待状态</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>卫星机：由卫星机完成面向用户的输入输出（纸带），中间结果暂存在磁带或磁盘上</p>
<h4 id="批处理方式"><a href="#批处理方式" class="headerlink" title="批处理方式"></a>批处理方式</h4><ul>
<li>单道批处理</li>
<li>多道批处理</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>spooling系统：利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O真正并行</p>
<p>现代计算机打印通常也采用spooling技术</p>
<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><p>最早的交互式操作系统</p>
<h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p>一台主机为多个没有计算能力的终端服务，由终端输入命令，主机进行回答</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>独立性</li>
<li>多路性</li>
<li>交互性</li>
<li>及时性</li>
</ul>
<h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>操作系统将cpu的时间划分为若干个片段，称为时间片</p>
<ul>
<li>操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片</li>
<li>利用人的错觉使用户感觉不到计算机在服务他人</li>
</ul>
<h4 id="追求目标-1"><a href="#追求目标-1" class="headerlink" title="追求目标"></a>追求目标</h4><p>及时响应（依据响应时间：从终端发出命令到系统给出回答所经历的时间）</p>
<h4 id="通用操作系统"><a href="#通用操作系统" class="headerlink" title="通用操作系统"></a>通用操作系统</h4><p>分时系统于批处理系统结合</p>
<p>原则：分时优先，批处理在后 “前台”:需要频繁交互的作业；”后台”:时间性要求不强的作业</p>
<h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>计算机能及时响应外部事件请求，在规定的严格时间内完成对该事件的处理，并控制所有实施设备和实时任务协调一致工作</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>可靠性</li>
<li>独立性</li>
<li>多路性</li>
<li>交互性</li>
<li>及时性</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li><p>实时过程控制</p>
<p>工业控制、航空、军事控制</p>
</li>
<li><p>实时通信处理</p>
<p>电讯、银行、飞机订票、股市行情</p>
</li>
</ul>
<h4 id="追求目标-2"><a href="#追求目标-2" class="headerlink" title="追求目标"></a>追求目标</h4><ul>
<li>对外部请求在严格时间范围内做出响应</li>
<li>高可靠性<ul>
<li>硬实时系统（某个动作必须在某个时刻或时间内完成）</li>
<li>软实时系统（接受偶尔违反最终时限）</li>
</ul>
</li>
</ul>
<h2 id="什么是进程，引入进程的目的，进程的特征"><a href="#什么是进程，引入进程的目的，进程的特征" class="headerlink" title="什么是进程，引入进程的目的，进程的特征"></a>什么是进程，引入进程的目的，进程的特征</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位</p>
<p>总结如下</p>
<ol>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的独立单位</li>
</ol>
<h3 id="引入进程的目的"><a href="#引入进程的目的" class="headerlink" title="引入进程的目的"></a>引入进程的目的</h3><p>为了使程序能够并发执行，并且可以对并发执行的程序加以描述与控制。</p>
<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ol>
<li>动态性：进程的实质是进程实体的执行过程，因此动态性是进程最基本特征</li>
<li>并发性：多个进程实体同时存在与内存中，且能在同一时间运行。</li>
<li>独立性：进程实体是能独立运行、独立获取资源、独立接受调度的基本单位</li>
<li>异步性：进程是按异步方式运行的，即按各自独立不可预知的速度向前推进（可进行同步配置）</li>
</ol>
<h2 id="进程的所有状态及状态转换"><a href="#进程的所有状态及状态转换" class="headerlink" title="进程的所有状态及状态转换"></a>进程的所有状态及状态转换</h2><ul>
<li><p>运行态</p>
<p>占有CPU，并在CPU上运行</p>
</li>
<li><p>就绪态</p>
<p>进程已经具备运行条件，但由于没有空闲CPU暂时无法运行</p>
</li>
<li><p>等待态（阻塞态）</p>
<p>因为等待某一事件而暂时不能运行（如读盘）</p>
</li>
<li><p>其他状态</p>
<ul>
<li>创建态 已完成创建进程所必要的工作但尚未同意执行该进程（如资源有限）</li>
<li>终止态 终止执行后进程进入的状态，此时可完成一些数据统计工作与资源回收</li>
<li>挂起态 就绪挂起与阻塞挂起 拥有调节负载，进程不占用内存空间，进程映像交换至磁盘上（不在五状态模型中）</li>
</ul>
</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><ul>
<li>就绪$\rightarrow$运行：调度程序选择新的进程运行</li>
<li>运行$\rightarrow$就绪<ul>
<li>运行进程用完时间片</li>
<li>被更高优先级的进程抢占</li>
</ul>
</li>
<li>运行$\rightarrow$阻塞：当一个进程发送某些事件时<ul>
<li>请求OS服务</li>
<li>对资源的访问尚不能进行</li>
<li>等待I/O结果</li>
<li>等待另一进程提供信息</li>
</ul>
</li>
<li>……</li>
</ul>
<h2 id="PCB-进程描述符（进程属性）"><a href="#PCB-进程描述符（进程属性）" class="headerlink" title="PCB 进程描述符（进程属性）"></a>PCB 进程描述符（进程属性）</h2><p>用于管理进程的专门的数据结构，记录进程的各种属性，描述进程的动态变化过程</p>
<p>PCB是系统感知进程存在的唯一标志，进程于PCB一一对应</p>
<p>进程表：所有进程PCB的集合</p>
<h3 id="PCB所包含的信息"><a href="#PCB所包含的信息" class="headerlink" title="PCB所包含的信息"></a>PCB所包含的信息</h3><ul>
<li>进程描述信息<ul>
<li>进程标识符（process ID）唯一，通常为一个整数</li>
<li>进程名 不唯一，通常基于可执行文件名</li>
<li>用户标识符（user ID）</li>
<li>进程组关系</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>当前状态</li>
<li>优先级</li>
<li>代码执行入口地址</li>
<li>程序磁盘地址</li>
<li>运行统计信息</li>
<li>进程间同步于通信</li>
<li>进程的队列指针</li>
<li>进程的消息队列</li>
</ul>
</li>
<li>所拥有的资源和使用情况</li>
<li>CPU现场信息</li>
</ul>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><ul>
<li>操作系统为每一类进程建立一个或多个队列</li>
<li>队列元素为PCB</li>
<li>伴随进程状态的改变，其PCB从一个队列进入另一个队列（如就绪队列、等待队列）</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>控制进程操作完成进程各状态之间的转换，由具有特定功能的原语完成</p>
<ul>
<li><p>进程创建原语</p>
</li>
<li><p>进程撤销原语</p>
</li>
<li><p>阻塞原语</p>
</li>
<li><p>唤醒原语</p>
</li>
<li><p>挂起原语</p>
</li>
<li><p>激活原语</p>
</li>
<li><p>改变优先级</p>
</li>
<li><p>……</p>
<p>原语执行过程中不允许被中断</p>
</li>
</ul>
<h3 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h3><ul>
<li>系统进程/用户进程</li>
<li>前台进程/后台进程</li>
<li>cpu密集型进程/io密集型进程</li>
</ul>
<p>UNIX存在进程家族树，init为根，Windows虽然也是一个进程创建另一个进程但是他们地位相同。</p>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><ul>
<li>进程能更准确刻画并发，而程序不能</li>
<li>程序只是一组有序指令的集合，是静态的，进程是动态的</li>
<li>进程有生命周期，是短暂的；程序是长久的</li>
<li>一个程序可以对应多个进程</li>
<li>进程具有创建其他进程的功能</li>
</ul>
<h2 id="引入线程的目的，线程的特征"><a href="#引入线程的目的，线程的特征" class="headerlink" title="引入线程的目的，线程的特征"></a>引入线程的目的，线程的特征</h2><h3 id="引入线程的目的"><a href="#引入线程的目的" class="headerlink" title="引入线程的目的"></a>引入线程的目的</h3><ul>
<li><p>应用的需要</p>
</li>
<li><p>开销的考虑</p>
<p>线程的开销小，两个线程切换花费时间少，线程间通讯无限调用内核</p>
</li>
<li><p>性能的考虑</p>
<ul>
<li>充分发挥多处理器优势</li>
</ul>
</li>
</ul>
<p>例如构造服务器（应用的需要）</p>
<p>多线程：有并发、阻塞系统调用</p>
<p>单线程进程：无并发、阻塞系统调用</p>
<p>有限状态机：有并发、非阻塞系统调用、中断</p>
<h3 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3><p>线程继承了进程的两个基本属性中的一个（资源的拥有者，<strong>cpu的调度单位</strong>），线程是cpu的调度单位。</p>
<p>所以线程是进程中的一个运行实体，是CPU的调度单位，有时将线程称为轻量级进程</p>
<h3 id="线程的特征（属性）"><a href="#线程的特征（属性）" class="headerlink" title="线程的特征（属性）"></a>线程的特征（属性）</h3><ul>
<li><p>标识符 ID</p>
</li>
<li><p>有状态及状态转换</p>
</li>
<li><p>不运行时需要保存的上下文</p>
<p>有上下文环境：程序计数器等寄存器</p>
</li>
<li><p>有自己的栈和栈指针</p>
</li>
<li><p><strong>共享所在进程的地址空间和其他资源</strong></p>
</li>
<li><p>线程可以创建、撤销另一个线程，程序开始是是单线程的方式运行的。</p>
</li>
</ul>
<h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><ul>
<li>在用户空间建立线程库：提供一组管理线程的过程</li>
<li>运行时系统：完成线程的管理工作（操作、线程表 创建、线程数据结构管理）</li>
<li>内核管理的还是进程，不知道线程的存在</li>
<li><p>线程切换不需要内核态权限</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5></li>
<li><p>线程切换快</p>
</li>
<li>调度算法是应用程序特定的</li>
<li>用户级线程可运行在任何操作系统上（只需实现线程库）</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上</li>
<li>大多数系统调用是阻塞的，因此、由于内核阻塞进程，故进程中所有线程也被阻塞</li>
</ul>
<h4 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h4><ul>
<li>内核管理所有线程，并向应用程序提供API接口</li>
<li>内核维护进程和线程的上下文</li>
<li>线程的切换需要内核支持</li>
<li>以线程为基础进行调度</li>
</ul>
<h2 id="处理机的调度层次（高级、中级、低级）及典型应用"><a href="#处理机的调度层次（高级、中级、低级）及典型应用" class="headerlink" title="处理机的调度层次（高级、中级、低级）及典型应用"></a>处理机的调度层次（高级、中级、低级）及典型应用</h2><h3 id="作业调度（高级调度）"><a href="#作业调度（高级调度）" class="headerlink" title="作业调度（高级调度）"></a>作业调度（高级调度）</h3><p>按照一定原则从外部存储器中处于后备队列选择作业调入内存，并为它们创建进程，分配必要资源后调入就绪队列。</p>
<ul>
<li>应用：批处理系统</li>
<li>执行频率较低，通常几分钟一次</li>
</ul>
<h3 id="内存调度（中级调度）"><a href="#内存调度（中级调度）" class="headerlink" title="内存调度（中级调度）"></a>内存调度（中级调度）</h3><p>将暂时不能运行的进程调至外存等待，此时进程状态为挂起态，当它们已经具备了运行条件且内存有空闲由内存调度决定是否将其调入内存，并修改状态为就绪态</p>
<ul>
<li>应用：解决内存紧张问题，提高内存利用率和系统吞吐量，完成了存储器管理中的对换功能</li>
</ul>
<h3 id="进程调度（低级调度）"><a href="#进程调度（低级调度）" class="headerlink" title="进程调度（低级调度）"></a>进程调度（低级调度）</h3><p>根据某种算法决定就绪队列中哪个进程获得处理机</p>
<ul>
<li>是OS中最基本的调度</li>
<li>频繁使用（毫秒级）要求高效</li>
<li>通常有抢占非抢占两种方式</li>
</ul>
<h2 id="死锁定义，产生死锁的必要条件，预防死锁的方法"><a href="#死锁定义，产生死锁的必要条件，预防死锁的方法" class="headerlink" title="死锁定义，产生死锁的必要条件，预防死锁的方法"></a>死锁定义，产生死锁的必要条件，预防死锁的方法</h2><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><p>一组进程中，每个进程都无限等待被该组进程中另一组进程所占有的资源，因而永远无法得到资源，这种现象称为进程死锁，这组进程称为死锁进程。</p>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul>
<li><p>互斥使用（资源独占）</p>
<p>一个资源每次只能给一个进程使用</p>
</li>
<li><p>占有且等待（请求和保持，部分分配）</p>
<p>进程在申请新的资源的同时保持对原有资源的占有</p>
</li>
<li><p>不可抢占（不和剥夺）</p>
<p>资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者资源释放</p>
</li>
<li><p>循环等待</p>
<p>存在一个进程等待队列{P1, P2,…, Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个等待环路</p>
</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>破坏产生死锁的四个必要条件之一</p>
<h4 id="破坏资源独占"><a href="#破坏资源独占" class="headerlink" title="破坏资源独占"></a>破坏资源独占</h4><ul>
<li>资源转换技术：把独占资源变为共享资源</li>
<li>SPOOLing技术：解决不允许任何线程直接占用不可抢占资源的问题，设计一个”守护进程/线程“负责管理不可抢占资源，进程需要使用不可抢占资源时，向守护进程/线程发送请求，由它来完成对应任务</li>
</ul>
<h4 id="破坏占有且等待"><a href="#破坏占有且等待" class="headerlink" title="破坏占有且等待"></a>破坏占有且等待</h4><ul>
<li>在每个进程运行前必须一次性申请所要求的所有资源，当且仅当该进程所要资源均可满足时才给予一次性资源分配<ul>
<li>问题：资源利用率低；容易产生”饥饿“现象</li>
</ul>
</li>
<li>在允许进程动态申请资源的前提下规定，一个进程在申请新的资源不能立刻得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请</li>
</ul>
<h4 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h4><ul>
<li>当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源（优先级）</li>
<li>局限性：适用于状态易于保存和恢复的资源(CPU 内存)</li>
</ul>
<h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><ul>
<li><p>通过定义资源类型的线性顺序实现</p>
</li>
<li><p>实施方案：资源有序分配法</p>
<p>把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配</p>
</li>
<li><p>要考虑如何编号（如按使用频率）</p>
</li>
<li><p>实现方法：让当前占有编号最大的进程继续执行（之后的编号肯定没有分配）</p>
</li>
</ul>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul>
<li><p>不考虑死锁（鸵鸟算法）</p>
</li>
<li><p>不让死锁发生</p>
<ul>
<li><p>死锁预防 </p>
<p>静态策略：设计合适的资源分配算法，不让死锁发生</p>
</li>
<li><p>死锁避免</p>
<p>动态策略：以不让死锁发生为目标，跟踪并评估资源分配过程，根据评估结果决策是否分配资源</p>
</li>
</ul>
</li>
<li><p>让死锁发生</p>
<p>死锁检测与解除</p>
</li>
</ul>
<h2 id="虚拟存储器的定义、特征"><a href="#虚拟存储器的定义、特征" class="headerlink" title="虚拟存储器的定义、特征"></a>虚拟存储器的定义、特征</h2><h3 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h3><p>是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储系统</p>
<ul>
<li>把内存与磁盘有机结合使用从而得到一个容量很大的”内存“，就是虚拟存储器</li>
<li>虚拟存储器是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用</li>
<li>虚拟存储器提供了一个比物理空间大得多的地址空间</li>
</ul>
<h3 id="虚拟存储器特征"><a href="#虚拟存储器特征" class="headerlink" title="虚拟存储器特征"></a>虚拟存储器特征</h3><ul>
<li><p>多次性</p>
<p>无需在程序运行时一次性将其全部调入内存，而是被分为多次调入内存运行</p>
</li>
<li><p>对换性</p>
<p>在程序运行中无需一直常驻内存，而是在运行过程中进行换进与换出</p>
</li>
<li><p>虚拟性</p>
<p>从逻辑上扩充内存容量，使用户看到的内存容量远大于实际内存容量</p>
</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>分页请求系统</li>
<li>分段请求系统</li>
</ul>
<h2 id="内存的连续分配方式和离散分配方式的种类特点和不同"><a href="#内存的连续分配方式和离散分配方式的种类特点和不同" class="headerlink" title="内存的连续分配方式和离散分配方式的种类特点和不同"></a>内存的连续分配方式和离散分配方式的种类特点和不同</h2><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>为一个用户程序分配一个连续的内存空间，程序中代码或数据的逻辑地址相邻</p>
<h4 id="连续分配的方式"><a href="#连续分配的方式" class="headerlink" title="连续分配的方式"></a>连续分配的方式</h4><ul>
<li><p>单一连续分配</p>
<p>内存分为系统区与用户区，用户区被一个程序独占</p>
</li>
<li><p>固定分区分配</p>
<p>将整个用户空间划分为若干固定大小的区域，每个区域被一个程序独占</p>
</li>
<li><p>动态分区分配</p>
<p>根据进程实际需要动态地为之分配内存空间。</p>
</li>
<li><p>基于顺序搜索的动态分区分配</p>
<p>将系统中的空闲分区链接成一个栈，依次搜索空闲分区链上的空闲分区，来找到合适的分区</p>
</li>
</ul>
<p>连续分配方式会形成许多“碎片”虽然可以拼接但开销很大</p>
<h3 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h3><h4 id="离散分配方式"><a href="#离散分配方式" class="headerlink" title="离散分配方式"></a>离散分配方式</h4><p>允许将一个进程直接分散装入到许多不同内存分区中。</p>
<ul>
<li><p>分页存储管理方式</p>
<p>将用户程序地址空间分为若干固定大小的区域，称为页或页面，相应的也将内存空间分为若干个物理块或页框，页和块大小相同，可将用户程序的任一页放在任一物理块中</p>
</li>
<li><p>分段存储管理方式</p>
<p>把用户程序地址空间分为若干大小不同的段，每段可定义一组完整的信息，在存储器分配时，以段为单位，这些段在内存中可以不相连</p>
</li>
<li><p>段页式存储管理方式</p>
<p>分页与分段结合，既有两者优点，是应用较为广泛的一种存储管理方式</p>
</li>
</ul>
<h2 id="缓冲的引入原因，缓冲的分类"><a href="#缓冲的引入原因，缓冲的分类" class="headerlink" title="缓冲的引入原因，缓冲的分类"></a>缓冲的引入原因，缓冲的分类</h2><h3 id="缓冲的引入"><a href="#缓冲的引入" class="headerlink" title="缓冲的引入"></a>缓冲的引入</h3><ul>
<li>缓和CPU与IO设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应实际的限制</li>
<li>解决数据粒度不匹配问题</li>
<li>提高CPU和IO设备之间的并行性</li>
</ul>
<h3 id="缓冲的分类"><a href="#缓冲的分类" class="headerlink" title="缓冲的分类"></a>缓冲的分类</h3><ul>
<li><p>单缓冲区</p>
<p>每当用户进程发出一IO请求，操作系统便在主存中为之分配一个缓冲区</p>
</li>
<li><p>双缓冲区</p>
<p>（由于缓冲区是共享资源，生产者和消费者在使用缓冲区时必须互斥，如果消费者尚未取走缓冲区中的数据，即使生产者又生产出新的数据，也无法将它送入缓冲区，所以为消费者生产者设置两个缓冲区）</p>
<p>双缓冲区（缓冲对换）在设备输入时，先将数据送入第一缓冲区，装满后转向第二缓冲区，此时操作系统可以从第一缓冲区中移出数据，并送入用户进程。</p>
</li>
<li><p>环形缓冲区（多缓冲区）</p>
<p>（生产者与消费者之间速度差距明显）环形缓冲区中有多个缓冲区，可以分为三种</p>
<ul>
<li>空缓冲区R</li>
<li>满缓冲区G</li>
<li>消费者正在使用的缓冲区C</li>
</ul>
<p>作为输入的缓冲区可以设置三个指针</p>
<ul>
<li>Nextg：指示消费者可以使用的下一个满缓冲区</li>
<li>Nexti：指示生产者可以使用的下个空缓冲区</li>
<li>Current：指示消费者正在使用的缓冲区</li>
</ul>
<p>环形缓冲区的使用</p>
<ul>
<li>Getbuf ：<ul>
<li>消费者：<ol>
<li>将Nextg所指向的缓冲区交给消费者Current使用</li>
<li>Nextg移向下一个满缓冲区</li>
</ol>
</li>
<li>生产者：<ol>
<li>将Nexti所指的缓冲区交给生产者使用</li>
<li>将Nexti移向下一个空缓冲区</li>
</ol>
</li>
</ul>
</li>
<li>Releasebuf<ul>
<li>消费者将缓冲区中数据提取完：将先行工作缓冲区C改为空缓冲区R</li>
<li>生产者把缓冲区装满：将缓冲区释放并改为G缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><p>缓冲池</p>
<p>（当系统较大时应该会有许多环形缓冲区，不仅要消耗大量内存空间，而且利用率不高，可以用公共缓冲池解决）</p>
<p>缓冲池管理着多个缓冲区</p>
<p><strong>缓冲区组成</strong></p>
<ul>
<li><p>缓冲首部：</p>
<p>用于标识和管理，包括缓冲区号、设备号、设备上的数据块号、同步信号量、队列链接指针</p>
</li>
<li><p>缓冲体：用于存放数据</p>
</li>
</ul>
<p>为了方便管理将缓冲池中具有相同类型的缓冲区链接成一个队列每个队列有队首指针F与队尾指针L</p>
<ol>
<li><p>空白缓冲队列</p>
<p>由空缓冲区组成</p>
</li>
<li><p>输入队列</p>
<p>由装满输入数据的缓冲区组成</p>
</li>
<li><p>输出队列</p>
<p>由装满输出数据的缓冲区组成</p>
</li>
</ol>
</li>
</ul>
<h2 id="四种I-O设备控制方式，各自的工作原理和它们之间的不同"><a href="#四种I-O设备控制方式，各自的工作原理和它们之间的不同" class="headerlink" title="四种I/O设备控制方式，各自的工作原理和它们之间的不同"></a>四种I/O设备控制方式，各自的工作原理和它们之间的不同</h2><h3 id="程序控制I-O（查询方式）"><a href="#程序控制I-O（查询方式）" class="headerlink" title="程序控制I/O（查询方式）"></a>程序控制I/O（查询方式）</h3><p>由CPU代表进程向I/O模块发送I/O命令，不断询问设备控制器状态，进程进入忙等待，直到操作完成才继续执行</p>
<p><img src="/2019/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/程序控制IO.JPG" alt="img"></p>
<h3 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I/O"></a>中断驱动I/O</h3><p>为了减少设备驱动程序不断询问控制器状态寄存器的开销，当正设备在执行某一I/O操作时，CPU可以根据需要转去执行另一程序，I/O操作结束后，由设备控制器主动通知设备驱动程序</p>
<p><img src="/2019/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/中断驱动IO.JPG" alt="img"></p>
<h3 id="DMA（直接存储器访问）"><a href="#DMA（直接存储器访问）" class="headerlink" title="DMA（直接存储器访问）"></a>DMA（直接存储器访问）</h3><p>允许主存储器和I/O设备之间通过“DMA控制器(DMAC)”直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须CPU的干预。每传输一个“块”数据只需要占用一个主存周期。</p>
<p><img src="/2019/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/DMA.JPG" alt="img"></p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>通道是负责外围设备与主存之间进行 数据交换、能单独完成输入输出操作的<strong>处理机</strong>，它控制设备与内存直接进 行数据交换。它有自己的通道指令， 这些通道指令的运行由CPU启动，并 在操作结束时向CPU发出中断信号。</p>
<p>通道所需要的CPU控制更少，一个通道可以控制多个设备，并且能够一次进行多个不连续的数据块的存取交换.</p>
<h4 id="通道的类型"><a href="#通道的类型" class="headerlink" title="通道的类型"></a>通道的类型</h4><ul>
<li>字节多路通道</li>
<li>选择通道</li>
<li>数组多路通道</li>
</ul>
<h2 id="利用记录型信号量机制：P（wait-s-）V（signal-s-）解决进程同步问题"><a href="#利用记录型信号量机制：P（wait-s-）V（signal-s-）解决进程同步问题" class="headerlink" title="利用记录型信号量机制：P（wait(s)）V（signal(s)）解决进程同步问题"></a>利用记录型信号量机制：P（wait(s)）V（signal(s)）解决进程同步问题</h2><h3 id="采用信号量的目的"><a href="#采用信号量的目的" class="headerlink" title="采用信号量的目的"></a>采用信号量的目的</h3><ul>
<li>同步</li>
<li>互斥</li>
<li>描述前驱关系</li>
</ul>
<p>设公共汽车上，司机活动是：启动车辆、正常行车、到站停车；售票员的活动是：关车门、售票、开车门。在汽车不停的到站、停战、行驶过程中，这两个活动有什么同步关系？用信号量P、V操作实现它们的同步</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore s1 = <span class="number">0</span>;	<span class="comment">// 车门</span></span><br><span class="line">semaphore s2 = <span class="number">0</span>;	<span class="comment">// 车辆状态</span></span><br><span class="line">main()&#123;</span><br><span class="line">    driver();</span><br><span class="line">    busman();</span><br><span class="line">&#125;</span><br><span class="line">driver&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        P(s1);</span><br><span class="line">        启动车辆;</span><br><span class="line">        正常行车;</span><br><span class="line">        到站停车;</span><br><span class="line">        V(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">busman()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        关闭车门;</span><br><span class="line">        V(S1);</span><br><span class="line">        售票;</span><br><span class="line">        P(S2);</span><br><span class="line">        开启车门;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某寺庙，有小和尚、老和尚若干，有一缸水，有小和尚提水入缸供老和尚引用。水缸可容10桶水，水取自同一井中。水井颈窄，每次只能容一个桶取水。水桶总数为3个。每次入、取缸水仅为1桶，且不可同时进行。试用P、V操作给出取水、入水的算法描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">semaphore cnt = <span class="number">3</span>;	<span class="comment">// 桶</span></span><br><span class="line">semaphore mutexg = <span class="number">1</span>;	<span class="comment">// 缸</span></span><br><span class="line">semaphore mutexj = <span class="number">1</span>;	<span class="comment">// 井</span></span><br><span class="line">semaphore full = <span class="number">0</span>;	<span class="comment">// 满</span></span><br><span class="line">semaphore empty = <span class="number">10</span>;	<span class="comment">// 空</span></span><br><span class="line">main()&#123;</span><br><span class="line">    put();</span><br><span class="line">    pop();</span><br><span class="line">&#125;</span><br><span class="line">put()&#123;</span><br><span class="line">    P(cnt);</span><br><span class="line">    P(mutexj);</span><br><span class="line">    P(empty);</span><br><span class="line">    取水</span><br><span class="line">    V(mutexj);</span><br><span class="line">    P(mutexg);</span><br><span class="line">    倒入缸;</span><br><span class="line">    V(full);</span><br><span class="line">    V(cnt);</span><br><span class="line">    V(mutexg);</span><br><span class="line">&#125;</span><br><span class="line">pop()&#123;</span><br><span class="line">    P(cnt);</span><br><span class="line">    P(mutexg);</span><br><span class="line">    P(full);</span><br><span class="line">    喝水;</span><br><span class="line">    V(empty);</span><br><span class="line">    V(cnt);</span><br><span class="line">    V(mutexg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>爸爸专向盘中放苹果，妈妈专向盘中放橘子，儿子专等吃盘里的橘子，女儿专等吃盘里的苹果。只要盘子空，爸爸妈妈可向盘中放水果，仅当盘中有自己需要的水果时，儿子或女儿可从中取出，请给出他们四人之间的同步关系，并用PV操作实现四人正确活动的程序。。使用p、v操作来完成父亲、妈妈、儿子、女儿的同步行为模拟。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore pan = <span class="number">1</span>;	<span class="comment">// 盘子容量1</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line">main()&#123;</span><br><span class="line">    father();</span><br><span class="line">    mother();</span><br><span class="line">    son();</span><br><span class="line">    daughter();</span><br><span class="line">&#125;</span><br><span class="line">father()&#123;</span><br><span class="line">    P(pan);</span><br><span class="line">    放入苹果;</span><br><span class="line">    V(apple);</span><br><span class="line">&#125;</span><br><span class="line">mother()&#123;</span><br><span class="line">    P(pan);</span><br><span class="line">    放入橘子;</span><br><span class="line">    V(orange);</span><br><span class="line">&#125;</span><br><span class="line">son()&#123;</span><br><span class="line">    P(orange);</span><br><span class="line">    吃橘子</span><br><span class="line">    V(pan);</span><br><span class="line">&#125;</span><br><span class="line">daughter()&#123;</span><br><span class="line">    P(apple);</span><br><span class="line">    吃苹果</span><br><span class="line">    V(pan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假定生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息，对生产者-消费者问题可描述如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty = n;	<span class="comment">// 空缓冲区</span></span><br><span class="line">semaphore full = <span class="number">0</span>;	<span class="comment">// 满缓冲区</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 缓冲池</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">	producter();</span><br><span class="line">	consumer();</span><br><span class="line">&#125;</span><br><span class="line">producter()&#123;</span><br><span class="line">	whille(<span class="literal">true</span>)&#123;</span><br><span class="line">		P(empty);</span><br><span class="line">		P(mutex);</span><br><span class="line">		将消息送入缓冲池;</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		P(full);</span><br><span class="line">		P(mutex);</span><br><span class="line">		将消息取出</span><br><span class="line">		V(mutex);</span><br><span class="line">		V(empty);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算相关作业调度算法的完成时间、周转时间、带权周转时间"><a href="#计算相关作业调度算法的完成时间、周转时间、带权周转时间" class="headerlink" title="计算相关作业调度算法的完成时间、周转时间、带权周转时间"></a>计算相关作业调度算法的完成时间、周转时间、带权周转时间</h2><ul>
<li>$ 周转时间 = 完成时间 - 到达时间$</li>
<li>$ 带权周转时间 = \frac {周转时间}{服务时间}$</li>
<li>$ 平均周转时间 = \frac {周转时间}{进程数}$</li>
<li>$ 平均带权周转时间 = \frac {带权周转时间}{进程数}$</li>
</ul>
<h3 id="FCFS先来先服务"><a href="#FCFS先来先服务" class="headerlink" title="FCFS先来先服务"></a>FCFS先来先服务</h3><p>按照作业提交或进程变为就绪状态的顺序分派CPU，当前作业或进程占用CPU直到执行完或阻塞才让出CPU</p>
<ul>
<li>优点<ul>
<li>有利于长作业</li>
<li>有利于CPU繁忙的作业</li>
</ul>
</li>
<li>缺点<ul>
<li>不利于短作业</li>
<li>不利于I/O繁忙的作业</li>
</ul>
</li>
</ul>
<h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><p>对预计执行时间最短的作业或进程优先分派处理机，通常后来的作业不抢占正在执行的作业</p>
<ul>
<li>优点<ul>
<li>比FCFS改善平均周转时间和平均带权周转时间</li>
<li>缩短短作业等待时间</li>
<li>提高系统吞吐量</li>
</ul>
</li>
<li>缺点<ul>
<li>对长作业不利，可能产生饥饿现象</li>
<li>未能根据作业的紧迫程度划分执行优先级</li>
<li>实际操作中进程的执行时间难以准确估计</li>
</ul>
</li>
</ul>
<h3 id="最高优先级优先"><a href="#最高优先级优先" class="headerlink" title="最高优先级优先"></a>最高优先级优先</h3><p>为每个作业或进程引入优先权，对优先权高的作业或进程优先分配处理机</p>
<p>分为抢占式与非抢占式两种</p>
<p>优先级有静态优先级与动态优先级两种</p>
<ul>
<li>静态优先级<ul>
<li>用户根据作业紧急程度输入</li>
<li>由系统或操作员根据作业类型指派优先级</li>
<li>根据作业要求资源情况确定优先级</li>
</ul>
</li>
<li>动态优先级<ul>
<li>根据进程占有CPU时间的长短决定</li>
<li>根据就绪进程等待CPU的时间长短来决定</li>
</ul>
</li>
</ul>
<h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><p>将系统中所有的就绪进程按FCFS排成队列，每次调度将处理机分配给队首元素，让其执行一个时间片，时间片结束后发生时钟中断，调度程序将队首进程送至就绪队列的末尾后将处理机分配给当前队首元素。</p>
<p>每个进程在就绪队列中的等待时间与享受服务的时间成正比例</p>
<h2 id="避免死锁：银行家算法（要求给出全步骤计算）"><a href="#避免死锁：银行家算法（要求给出全步骤计算）" class="headerlink" title="避免死锁：银行家算法（要求给出全步骤计算）"></a>避免死锁：银行家算法（要求给出全步骤计算）</h2><p>由Dijkstra于1965年提出</p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul>
<li>在固定数量进程中共享固定数量的资源</li>
<li>每个进程预先指定完成工作所需的最大资源量</li>
<li>进程不能申请比系统中可用资源总数还多的资源</li>
<li>进程等待资源的时间是有限的</li>
<li>如果系统满足了进程对资源的最大需求，那么，进程应该在有限的时间内使用资源，然后归还给系统</li>
</ul>
<h3 id="进程资源申请步骤"><a href="#进程资源申请步骤" class="headerlink" title="进程资源申请步骤"></a>进程资源申请步骤</h3><ul>
<li>申请资源若大于该进程最大资源量，报错返回</li>
<li>申请的资源大于系统当前持有可分配资源量，进程等待</li>
<li>进行假设分配</li>
<li>判断假设分配后系统处于安全状态，则分配完成</li>
<li>若系统处于不安全状态，恢复原来状态，进程等待</li>
</ul>
<h3 id="安全状态判断"><a href="#安全状态判断" class="headerlink" title="安全状态判断"></a>安全状态判断</h3><ul>
<li>寻找当前可以系统可分配资源满足的进程</li>
<li>若找到满足的进程，将该进程占有的资源假设归还给系统，寻找下一个进程</li>
<li>所有进程都被处理则证明当前状态安全</li>
<li>若找不到这种进程且并未处理完所有进程，证明该状态不安全</li>
</ul>
<h2 id="动态分区分配方式的分配算法，分区的分配和释放过程"><a href="#动态分区分配方式的分配算法，分区的分配和释放过程" class="headerlink" title="动态分区分配方式的分配算法，分区的分配和释放过程"></a>动态分区分配方式的分配算法，分区的分配和释放过程</h2><h3 id="单一连续分区"><a href="#单一连续分区" class="headerlink" title="单一连续分区"></a>单一连续分区</h3><p>同一时间只能由一个进程在内存内，内存利用率低</p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ul>
<li>把内存空间分割为若干区域</li>
<li>每个分区大小可以相同也可以不同</li>
<li>分区大小固定不变</li>
<li>每个分区能且只能装一个进程</li>
</ul>
<p>存在外碎片</p>
<h4 id="碎片问题解答"><a href="#碎片问题解答" class="headerlink" title="碎片问题解答"></a>碎片问题解答</h4><p>紧缩技术(压缩技术)</p>
<p>将所有小的分区合并为较大的空闲区</p>
<h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><ul>
<li>根据进程的需要，把内存空闲空间分割出一个分区分配给该进程</li>
<li>剩余空闲部分称为新的空闲分区</li>
</ul>
<h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>将空闲分区连以地址递增的形式链接，在内存分配时，从链首开始查找，直到找到一颗分区大小可以满足需求，按该作业大小分配内存，剩余的空闲分区仍在空闲分区链中。</p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>将空闲分区链中的空闲分区按大小由小到大排序，每次从链首进行查找，直至找到何合适的空闲分区，每次找到的分区是与作业大小最接近的</p>
<h4 id="下次适应算法"><a href="#下次适应算法" class="headerlink" title="下次适应算法"></a>下次适应算法</h4><p>第二个进程从第一个进程分配的分区开始查找，抵达结尾返回开头</p>
<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>用满足作业空间需求的最大分区进行分割</p>
<h4 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h4><p>当某一分区归还后，将前后的空闲空间合并，并修改内存空闲表</p>
<p>四种相邻的情况</p>
<ul>
<li>上相邻</li>
<li>下相邻</li>
<li>上下相邻</li>
<li>上下都不相邻</li>
</ul>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>将系统中的空闲分区根据其大小进行分类，相同大小的分区单独建立一个空闲分区双向链表</p>
<p>当需要为进程分配长度为n的存储空间时，首先计算一个i值，使$2^{i-1}&lt;n ≤ 2^i$ ，然后查找空闲分区大小为$ 2^i $ 的空闲链表，若找到进行分配，若没找到，则在分区大小为 $ 2^{i+1}$的空闲分区链表中查找，若找到一个空闲分区，则把该分区分为相等的两个分区，这两个分区称为一对伙伴，其中一个分区用于分配，而把另一个加入分区大小为$2^i$的空闲分区链表中</p>
<h2 id="在分页系统中，如何分址？如何根据逻辑地址计算页号和页内偏移量，并转换物理地址？"><a href="#在分页系统中，如何分址？如何根据逻辑地址计算页号和页内偏移量，并转换物理地址？" class="headerlink" title="在分页系统中，如何分址？如何根据逻辑地址计算页号和页内偏移量，并转换物理地址？"></a>在分页系统中，如何分址？如何根据逻辑地址计算页号和页内偏移量，并转换物理地址？</h2><h3 id="分址方式"><a href="#分址方式" class="headerlink" title="分址方式"></a>分址方式</h3><p>用户进程地址空间被划分成大小相等的部分，称为页，从0开始编号，页大小为2的幂通常为1KB~8KB</p>
<p>内存空间按同样大小被划分为大小相等的页，称为页框，从0开始编号</p>
<p>内存分配时以页为单位进行分配，逻辑上相邻的页在物理上不一定相邻</p>
<p>逻辑地址格式： （32位）如4KB页面最多1M页：页号（20） + 页内偏移（12位）</p>
<p>页表中保存着页号和内存块号的映射</p>
<h3 id="根据逻辑地址计算页号和页内偏移量并转换物理地址"><a href="#根据逻辑地址计算页号和页内偏移量并转换物理地址" class="headerlink" title="根据逻辑地址计算页号和页内偏移量并转换物理地址"></a>根据逻辑地址计算页号和页内偏移量并转换物理地址</h3><h4 id="计算页号和页内偏移量"><a href="#计算页号和页内偏移量" class="headerlink" title="计算页号和页内偏移量"></a>计算页号和页内偏移量</h4><ul>
<li>根据给定的页面大小计算页号长度</li>
<li>将给定的逻辑地址转换为二进制</li>
<li>计算页号和页内偏移</li>
</ul>
<p>对某特定机器，其地址结构是一定的。若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得</p>
<p>$P=INT[\frac AL]$</p>
<p>$d = [A]\ MOD\ L$</p>
<h4 id="转换物理地址"><a href="#转换物理地址" class="headerlink" title="转换物理地址"></a>转换物理地址</h4><p>根据页号查询页表，找到对应页的物理地址$(块号 \times 页大小)$，物理地址加上页偏移量就是物理地址</p>
<h2 id="根据页面置换算法，计算置换页面、缺页次数、缺页率"><a href="#根据页面置换算法，计算置换页面、缺页次数、缺页率" class="headerlink" title="根据页面置换算法，计算置换页面、缺页次数、缺页率"></a>根据页面置换算法，计算置换页面、缺页次数、缺页率</h2><h3 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h3><p>从内存中移出永远不在需要的页面，如果不存在，则移除在最长(未来)时间内不再被访问的页面</p>
<h4 id="最近最久未使用（LRU）置换算法"><a href="#最近最久未使用（LRU）置换算法" class="headerlink" title="最近最久未使用（LRU）置换算法"></a>最近最久未使用（LRU）置换算法</h4><p>选择最近最久未使用的页面予以淘汰。该算法为每个页面赋予一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t</p>
<p><img src="/2019/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/LRU1.JPG" alt="img"></p>
<p>利用栈来保存当前使用的各页面页号。当要访问某页面时，便将该页的页号从栈中移出，将它压入栈顶</p>
<p><img src="/2019/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/LRU栈.JPG" alt="img"></p>
<h3 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h3><p>当需要淘汰一个页面时，总是淘汰内存中存在时间最长的页面</p>
<h3 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h3><p>$缺页率 = \frac {缺页次数}{访问次数}$</p>
<h2 id="磁盘存储空间的分配，磁盘调度算法解决访问序列以及访问的时间"><a href="#磁盘存储空间的分配，磁盘调度算法解决访问序列以及访问的时间" class="headerlink" title="磁盘存储空间的分配，磁盘调度算法解决访问序列以及访问的时间"></a>磁盘存储空间的分配，磁盘调度算法解决访问序列以及访问的时间</h2><h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h3><p>为每一个文件分配一组相邻接的盘块</p>
<p>在采用连续组织方式时，可把逻辑文件中的记录顺序地存储到邻接的各物理盘块中，这样所形成的文件结构称为顺序文件结构，此时的物理文件称为顺序文件。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>顺序访问容易</li>
<li>顺序访问速度快</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>只能为一个文件分配连续的存储空间</li>
<li>必须事先知道文件的长度</li>
<li>不能灵活地删除和插入记录</li>
<li>不能灵活处理动态增长的文件</li>
</ul>
<h3 id="链接分配方式"><a href="#链接分配方式" class="headerlink" title="链接分配方式"></a>链接分配方式</h3><p>一个文件的信息存放在若干个不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块。fat中每个文件同样只需要一项，包括文件名、起始块号和最后块号。任何一个自由块都可以加入到链中。</p>
<h4 id="显式连接"><a href="#显式连接" class="headerlink" title="显式连接"></a>显式连接</h4><p>这是指把用于链接文件各物理块的指针显式地存放在内存的一张链接表中</p>
<h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>这是指把用于链接文件各物理块的指针存放在磁盘上的一张链接表中</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>提高磁盘的空间利用率，不存在外部碎片问题</li>
<li>有利于文件的插入和删除</li>
<li>有利于文件的动态扩充</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>存取速度慢，一般只适用于信息的顺序存取，不适于随机存取</li>
<li>查找某一块必须从头到尾沿着指针进行</li>
<li>可靠性问题（只要一个指针出错就会出现可怕问题）</li>
<li>更多的寻道次数和寻道时间</li>
<li>链接指针占一定的空间，将多个块组成簇，按簇进行分配而不是按块进行分配</li>
</ul>
<h3 id="索引分配方式"><a href="#索引分配方式" class="headerlink" title="索引分配方式"></a>索引分配方式</h3><p>每个文件在FAT中有一个一级索引，索引包含分配给文件的每个分区的入口。文件的索引保存在单独的一个块中，FAT中该文件的入口指向这一块</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>索引分配支持顺序访问文件和直接访问文件</li>
<li>满足了文件动态增长，插入删除的要求</li>
<li>能充分利用外存空间</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>较多的寻道次数和寻道空间</li>
<li>索引表本身带来了系统开销</li>
</ul>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="先来先服务算法（FCFS）"><a href="#先来先服务算法（FCFS）" class="headerlink" title="先来先服务算法（FCFS）"></a>先来先服务算法（FCFS）</h4><p>根据进程请求访问磁盘的先后次序进行调度</p>
<h5 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h5><ul>
<li>公平、简单，且每个进程的请求都能依次得到处理</li>
<li>不会出现某一进程的请求长期得不到满足的情况</li>
</ul>
<h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量</li>
</ul>
<h4 id="最短寻道时间优先算法（SSTF）"><a href="#最短寻道时间优先算法（SSTF）" class="headerlink" title="最短寻道时间优先算法（SSTF）"></a>最短寻道时间优先算法（SSTF）</h4><p>访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短</p>
<h5 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h5><ul>
<li>可以得到比较好的吞吐量</li>
</ul>
<h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>不能保证平均寻道时间最短</li>
<li>对用户的服务请求的响应机会不是均等的</li>
<li>响应时间的变化幅度很大</li>
<li>内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期</li>
</ul>
<h4 id="扫描算法（SCAN）（电梯调度）"><a href="#扫描算法（SCAN）（电梯调度）" class="headerlink" title="扫描算法（SCAN）（电梯调度）"></a>扫描算法（SCAN）（电梯调度）</h4><p>不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向</p>
<p>例如，当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的，这样自里向外地访问，直到最边缘磁道才将磁臂换向，自外向里移动。</p>
<h5 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h5><ul>
<li>避免了饥饿现象的出现</li>
<li>吞吐量较大，平均响应时间较小</li>
</ul>
<h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道</li>
</ul>
<h4 id="循环扫描算法（CSCAN）"><a href="#循环扫描算法（CSCAN）" class="headerlink" title="循环扫描算法（CSCAN）"></a>循环扫描算法（CSCAN）</h4><p>循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的磁道时，磁头立即返回到最里的磁道</p>
<h4 id="LOOK"><a href="#LOOK" class="headerlink" title="LOOK"></a>LOOK</h4><p>当磁头正在自里向外移动时，扫描算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的，这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。</p>
<h5 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h5><h4 id="CLOOK"><a href="#CLOOK" class="headerlink" title="CLOOK"></a>CLOOK</h4><p>循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的<strong>欲</strong>被访问磁道时，磁头立即返回到最里的<strong>欲</strong>访问磁道</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/12/16/Spring%E7%90%86%E8%AE%BA%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/16/Spring%E7%90%86%E8%AE%BA%E6%A2%B3%E7%90%86/" class="post-title-link" itemprop="url">Spring理论梳理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-16 18:48:29" itemprop="dateCreated datePublished" datetime="2019-12-16T18:48:29+08:00">2019-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%90%86%E8%AE%BA%E5%BD%92%E7%BA%B3/" itemprop="url" rel="index"><span itemprop="name">理论归纳</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>[TOC]</p>
<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><h3 id="WEB架构层"><a href="#WEB架构层" class="headerlink" title="WEB架构层"></a>WEB架构层</h3><ul>
<li>关系数据库层</li>
<li>表示层</li>
<li>业务层</li>
</ul>
<h3 id="Spring使用简单POJO来克服的问题"><a href="#Spring使用简单POJO来克服的问题" class="headerlink" title="Spring使用简单POJO来克服的问题"></a>Spring使用简单POJO来克服的问题</h3><ul>
<li>Web应用程序可能包含实现其核心功能所不需要的大量代码</li>
<li>单元测试困难</li>
<li>j2ee设计模式由开发人员变更，其他应用不能使用这些设计模式</li>
<li>应用代码依赖于j2ee容器不能迁移至其他容器</li>
</ul>
<h3 id="Spring功能"><a href="#Spring功能" class="headerlink" title="Spring功能"></a>Spring功能</h3><ul>
<li>可插拔性</li>
<li>依赖注入(DI) DI松散耦合，无需自建与关联业务层对象，只需在Spring配置文件中描述如何创建与依赖，允许可插拔性易于维护重用</li>
<li>面向方面(AOP)</li>
<li>容器</li>
<li>轻量级</li>
</ul>
<h3 id="SpringMVC优点"><a href="#SpringMVC优点" class="headerlink" title="SpringMVC优点"></a>SpringMVC优点</h3><ul>
<li>清晰分离控制器视图与模型</li>
<li>高度灵活</li>
<li>提供控制器</li>
<li>支持多种视图技术：jsp，velocity，tiles，jsf</li>
<li>通过依赖注入配置控制器</li>
<li>容易测试</li>
<li>验证器作为应用程序对象，不依赖于SpringAPI 而 struts需要借助StrutsAPI ActionForm.validate()</li>
</ul>
<h3 id="Spring框架的七个模块"><a href="#Spring框架的七个模块" class="headerlink" title="Spring框架的七个模块"></a>Spring框架的七个模块</h3><ul>
<li>核心：提供基本功能，包含bean工厂 使用org.springframework.core包</li>
<li>DAO（数据访问对象）：通过Hibernate、JDBC等标准化数据访问，编写简单数据库代码，无需考虑打开关闭数据库，提供异常层次结构 使用org.springframework.dao包</li>
<li>ORM（关系映射）：将Spring框架与其他对象关系映射工具（Hibernate、iBatis）集成，<strong>构建在DAO模块之上</strong> 使用org.springframework.orm包</li>
<li>AOP：面向切面，实现事务管理与安全性等，借助XML配置文件在应用程序中声明企业服务，使用org.springframework.aop包</li>
<li>MVC：模型视图控制器，将模型应用、视图应用、用户界面分开实现松散耦合，可重用，可与其他MVC框架集成（struts等），使用org.springframework.web包</li>
<li>应用程序上下文：构建在<strong>核心模块之上</strong>，使Spring成为一个框架， 通过一致的SpringAPI获取对象与资源，基于bean工厂 支持消息、应用程序生命周期事件验证国际化，由Spring配置文件定义，为Spring框架提供上下文信息（bean定义、安全性、事务管理）还提供了一些企业级服务（JNDI、EJB、电子邮件、远程通信、日程安排），使用org.springframework.context包*</li>
<li>Web上下文：属于Web应用程序开发堆栈（该堆栈包括MVC模块）构建于<strong>应用程序上下文模块之上</strong>，提供创建Web应用程序的上下文，支持Spring框架与Struts，WebWorks，JSF等框架集成，使用org.springframework.web包</li>
</ul>
<h2 id="实现依赖注入"><a href="#实现依赖注入" class="headerlink" title="实现依赖注入"></a>实现依赖注入</h2><p>web应用程序由大量逻辑组件组成，这些逻辑组件被称为应用程序对象，作为实现web应用程序业务目标的内聚单元。spring通过依赖注入（DI）概念管理应用程序对象</p>
<h3 id="Spring框架提供容器"><a href="#Spring框架提供容器" class="headerlink" title="Spring框架提供容器"></a>Spring框架提供容器</h3><ul>
<li>Bean工厂：提供对DI的支持 使用org.springframework.beans.factory.BeanFactory接口定义</li>
<li>应用程序上下文：基于bean工厂，提供如与SpringAOP集成、国际化等 使用org.springframework.context.ApplicationContext接口定义</li>
</ul>
<h3 id="介绍bean工厂"><a href="#介绍bean工厂" class="headerlink" title="介绍bean工厂"></a>介绍bean工厂</h3><p>bean可以是Spring容器创建、管理的任何java对象或实例。bean工厂容器用于实例化、配置、管理bean，bean工厂创建的对象是完全配置、可使用、知道关系的，管理一创建对象生命周期也涉及bean工厂。</p>
<p>要实例化Web应用程序的bean工厂首先要加载bean配置文件，使用org.springframework.core.io.Resource接口定义的Rescource对象完成 可从不同位置加载bean配置文件。</p>
<h3 id="resource接口实现检索配置文件资源"><a href="#resource接口实现检索配置文件资源" class="headerlink" title="resource接口实现检索配置文件资源"></a>resource接口实现检索配置文件资源</h3><ul>
<li>org.springframework.core.io.ByteArrayResource 一组字节资源</li>
<li>org.springframework.core.io.ClassPathResource 指定路径*</li>
<li>org.springframework.core.io.FileSystemResource 指定文件系统</li>
<li>org.springframework.core.io.InputStreamResource 输入流</li>
<li>org.springframework.web.context.support.ServletContextResource servlet上下文*</li>
<li>org.springframework.core.io.UrlResource 给定URL</li>
</ul>
<h3 id="bean标记属性"><a href="#bean标记属性" class="headerlink" title="bean标记属性"></a>bean标记属性</h3><ul>
<li>id：唯一标识bean定义默认bean名称不可包含特殊字符</li>
<li>name：指定bean别名可包含特殊字符</li>
<li>class：指定bean类的全限定名</li>
<li>scope：指定bean作用域 有singleton或prototype</li>
</ul>
<h3 id="bean生命周期步骤"><a href="#bean生命周期步骤" class="headerlink" title="bean生命周期步骤"></a>bean生命周期步骤</h3><ol>
<li>实例化</li>
<li>填充属性</li>
<li>设置bean名称</li>
<li>设置bean工厂</li>
<li>预初始化</li>
<li>初始化bean</li>
<li>初始化后</li>
<li>bean可使用</li>
<li>销毁bean</li>
</ol>
<h3 id="应用程序上下文介绍"><a href="#应用程序上下文介绍" class="headerlink" title="应用程序上下文介绍"></a>应用程序上下文介绍</h3><p>应用程序上下文是高级容器，继承了BeanFactory接口的所有功能，所以ApplicationContext更常用，缺乏资源用bean工厂</p>
<h4 id="企业级功能"><a href="#企业级功能" class="headerlink" title="企业级功能"></a>企业级功能</h4><ul>
<li>提供解析文本消息的方式与消息国际化</li>
<li>提供加载图像之类文件资源的常规方法</li>
<li>将事件发布到作为侦听器注册的bean</li>
</ul>
<h4 id="应用程序上下文常用实现"><a href="#应用程序上下文常用实现" class="headerlink" title="应用程序上下文常用实现"></a>应用程序上下文常用实现</h4><ul>
<li>ClassPathXmlApplicationContext 指定路径找配置文件</li>
<li>FileSystemXmlApplicationContext 文件系统找配置文件</li>
<li>XmlWebApplicationContext web.xml上下文参数contextConfigLocation找配置文件</li>
</ul>
<p>ClassPathXmlApplicationContext例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Sport/Spring-Config.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>FileSystemXmlApplicationContext例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"C:/Sport/Spring-Config.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>XmlWebApplicationContext例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext = <span class="keyword">new</span> XmlWebApplicationContext();</span><br></pre></td></tr></table></figure>
<p>bean工厂只有在调用getBean()时才创建bean， 应用程序上下文一旦启动就会预加载所有bean</p>
<h4 id="应用程序上下文bean生命周期步骤"><a href="#应用程序上下文bean生命周期步骤" class="headerlink" title="应用程序上下文bean生命周期步骤"></a>应用程序上下文bean生命周期步骤</h4><ol>
<li>实例化</li>
<li>填充属性</li>
<li>设置bean名称</li>
<li>设置bean工厂</li>
<li>设置应用程序上下文</li>
<li>预初始化</li>
<li>初始化bean</li>
<li>初始化后</li>
<li>bean可使用</li>
<li>销毁bean</li>
</ol>
<h3 id="注入应用程序对象"><a href="#注入应用程序对象" class="headerlink" title="注入应用程序对象"></a>注入应用程序对象</h3><p>应用程序对象之间创建和管理的过程形成了依赖注入DI核心并被成为装配</p>
<h4 id="完成装配的方式"><a href="#完成装配的方式" class="headerlink" title="完成装配的方式"></a>完成装配的方式</h4><ul>
<li>显示装配：根据配置文件中的显式声明</li>
<li>自动装配：由容器自动确定</li>
</ul>
<h4 id="显式装配"><a href="#显式装配" class="headerlink" title="显式装配"></a>显式装配</h4><p>可用设值注入(setter)和构造函数注入，通过\<property>元素配置，其中又可以注入简单值或引用其他bean</property></p>
<p>示例代码(setter)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SetterInject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SetterInject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FootballPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String football;</span><br><span class="line">    <span class="keyword">private</span> FootballBoots boots;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FootballPlayer</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.plintln(<span class="string">"I am playing with "</span> + football + <span class="string">" football."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFootball</span><span class="params">(String football)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.football = football;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoots</span><span class="params">(FootballBoots boots)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.boots = boots;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SetterInject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FootballBoots</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wearBoots</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入简单值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Kaka"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fotball"</span> <span class="attr">value</span>=<span class="string">"Adidas"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Forlan"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fotball"</span> <span class="attr">value</span>=<span class="string">"Nike"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SetterInject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Predator</span> <span class="keyword">implements</span> <span class="title">FootballBoots</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Predator</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wearBoots</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.plintln(<span class="string">"I am wearing Adids predator boots."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用其他bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"predator"</span> <span class="attr">class</span>=<span class="string">"SetterInject.Predator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Kaka"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fotball"</span> <span class="attr">value</span>=<span class="string">"Adidas"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"boots"</span> <span class="attr">ref</span>=<span class="string">"predator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Forlan"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fotball"</span> <span class="attr">value</span>=<span class="string">"Nike"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"boots"</span> <span class="attr">ref</span>=<span class="string">"predator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am playing with Adidas football. I am wearing Adids predator boots.</span><br><span class="line">I am playing with Nike football. I am wearing Adids predator boots.</span><br></pre></td></tr></table></figure>
<p>示例代码(构造函数)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> SetterInject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FootballPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> shirtNumber;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">FootballPlayer</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FootballPlayer</span><span class="params">(<span class="keyword">int</span> shirtNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shirtNumber = shirtNumber;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.plintln(<span class="string">"I am playing with "</span> + football + <span class="string">" football."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Kaka"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Forlan"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"21"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am playing with shirt nubmer 7.</span><br><span class="line">I am playing with shirt nubmer 21.</span><br></pre></td></tr></table></figure>
<h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>紫铜装配通过设置对被装配bean配置autowire完成</p>
<h5 id="autowire属性"><a href="#autowire属性" class="headerlink" title="autowire属性"></a>autowire属性</h5><ul>
<li>byName： 寻找名称与被装配属性匹配的bean，找不到不匹配</li>
<li>byType：寻找类型与被装配属性类型匹配的bean找不到不装配，找到多个抛出org.springframework.beans.factory.UnsatisfiedDependencyException异常</li>
<li>constructor：尝试将容器中的一个或多个bean与被装配bean构造函数匹配，构造函数或bean中存在二义性抛出org.springframework.beans.factory.UnsatisfiedDependencyException异常</li>
<li>autodetect：如果有默认无参构造先尝试用constructor然后用byType尝试装配bean</li>
</ul>
<p>通过名称</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"boots"</span> <span class="attr">class</span>=<span class="string">"SetterInject.Predator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Kaka"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"football"</span> <span class="attr">value</span>=<span class="string">"Adidas"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过类型</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"boots"</span> <span class="attr">class</span>=<span class="string">"SetterInject.Predator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Kaka"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"football"</span> <span class="attr">value</span>=<span class="string">"Adidas"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果找到多个类型相符的bean将抛出异常，所以需要只有一个bean可以匹配自动装配的类型。</p>
<p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AutowireInject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RugByPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span></span>&#123;</span><br><span class="line">    privite RugByBoots rugByBoots;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> shirtNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RugByPlayer</span><span class="params">(RugByBoots rugByBoots)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rugByBoots = rugByBoots;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getShirtNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shirtNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShirtNumber</span><span class="params">(<span class="keyword">int</span> shirtNumber)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.shirtNumber = shirtNumber;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am playing with shirt number "</span> + shirtNumber + </span><br><span class="line">                           <span class="string">" and "</span> + rugByBoots.getBoots() + <span class="string">" rugby boots."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AutowireInject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RugByBoots</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String boots;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBoots</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boots;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetBoots</span><span class="params">(String boots)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.boots = boots;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Wilkinson"</span> <span class="attr">class</span>=<span class="string">"AutowireInject.RugByPlayer"</span> <span class="attr">autowire</span>=<span class="string">"constructor"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"shirtNumber"</span> <span class="attr">value</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"NikeBoots"</span> <span class="attr">class</span>=<span class="string">"AutowireInject.RugByBoots"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"boots"</span> <span class="attr">value</span>=<span class="string">"Nike"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am playing with shirt number 7 and Nike rugby boots.</span><br></pre></td></tr></table></figure>
<p>如果有多个可被装配的bean会抛出异常，如果有多个构造函数也会抛出异常</p>
<p>自动检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;Kaka&quot; class&#x3D;&quot;SetterInject.FootballPlayer&quot; autowire&#x3D;&quot;autodetect&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>先构造函数后byType</p>
<h4 id="使用默认自动装配"><a href="#使用默认自动装配" class="headerlink" title="使用默认自动装配"></a>使用默认自动装配</h4><p>需要在beans元素中配置default-autowire</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-autowire</span>=<span class="string">"byType"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="显式装配与自动装配结合"><a href="#显式装配与自动装配结合" class="headerlink" title="显式装配与自动装配结合"></a>显式装配与自动装配结合</h4><p>可以对任何属性使用\<property>或\<constructor-arg>，会覆盖已经自动装配过的属性。</constructor-arg></property></p>
<p>使用byType时可以显式装配有二义性的属性如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Kaka"</span> <span class="attr">class</span>=<span class="string">"SetterInject.FootballPlayer"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"football"</span> <span class="attr">value</span>=<span class="string">"Adidas"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"boots"</span> <span class="attr">value</span>=<span class="string">"boot2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"boot1"</span> <span class="attr">class</span>=<span class="string">"SetterInject.Predator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"boot2"</span> <span class="attr">class</span>=<span class="string">"SetterInject.Predator"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>\<constructor-arg>不能与构造函数自动装配混合。</constructor-arg></p>
<h2 id="Spring与Web层集成"><a href="#Spring与Web层集成" class="headerlink" title="Spring与Web层集成"></a>Spring与Web层集成</h2><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="SpringMVC具有的胜过其他MVC框架的功能"><a href="#SpringMVC具有的胜过其他MVC框架的功能" class="headerlink" title="SpringMVC具有的胜过其他MVC框架的功能"></a>SpringMVC具有的胜过其他MVC框架的功能</h4><ul>
<li>可插拔视图技术：支持各种视图技术，如JSP、Tiles、JSF</li>
<li>将服务注入控制器：结合了Spring优点，如依赖注入与AOP，可以将业务层对象隐式注入控制器以减少用户界面和业务逻辑层之间代码的冗余</li>
<li>集成支持：支持与Struts与Hibernate等其他控件集成</li>
</ul>
<h4 id="MVC设计模式组成"><a href="#MVC设计模式组成" class="headerlink" title="MVC设计模式组成"></a>MVC设计模式组成</h4><ul>
<li>模型：应用程序存留的数据</li>
<li>视图：应用程序用户界面</li>
<li>控制器：负责接收用户请求并将其传递给模型进行操作，基于操作结果由控制器指向对应视图</li>
</ul>
<h4 id="SpringMVC处理用户请求利用的组件"><a href="#SpringMVC处理用户请求利用的组件" class="headerlink" title="SpringMVC处理用户请求利用的组件"></a>SpringMVC处理用户请求利用的组件</h4><ul>
<li>处理程序映射：使分发程序servlet能将传入请求转发到适当的控制器</li>
<li>控制器：处理请求生成响应（包括视图逻辑名称）</li>
<li>视图解析器：将控制器返回的视图逻辑名称解析为实际视图</li>
<li>视图：向用户显示响应</li>
</ul>
<h4 id="SpringMVC框架优点"><a href="#SpringMVC框架优点" class="headerlink" title="SpringMVC框架优点"></a>SpringMVC框架优点</h4><ul>
<li>易于测试</li>
<li>可重用的应用程序代码</li>
<li>简单强大的标记库</li>
<li>支持多种视图技术与Web框架</li>
</ul>
<h4 id="Web请求的生命周期"><a href="#Web请求的生命周期" class="headerlink" title="Web请求的生命周期"></a>Web请求的生命周期</h4><p>Web应用程序的web.xml包含关于如何处理某个Web请求的信息，当服务器收到请求将读取web.xml并将请求转发至负责处理的servlet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	G(用户请求) --1--&gt; A</span><br><span class="line">	A(分发程序servlet) --2--&gt;B(处理程序映射)</span><br><span class="line">    A -- 5 --&gt; E(视图解析器)</span><br><span class="line">    A -- 6 --&gt; F(视图)</span><br><span class="line">    A -- 3 --&gt; C(控制器) -- 4 --&gt; D(模型和视图) --&gt; A</span><br></pre></td></tr></table></figure>
<h5 id="请求生命周期"><a href="#请求生命周期" class="headerlink" title="请求生命周期"></a>请求生命周期</h5><ol>
<li>请求抵达分发程序servlet</li>
<li>分发程序servlet咨询一个或多个处理程序确定对应控制器</li>
<li>分发程序servlet将请求转发给控制器</li>
<li>控制器以逻辑视图名称与数据对象发送请求给分发程序servlet</li>
<li>分发程序servlet请求视图解析器将逻辑视图名称解析为视图</li>
<li>视图实现，交付模型数据并通过响应发送给浏览器</li>
</ol>
<h3 id="Web请求"><a href="#Web请求" class="headerlink" title="Web请求"></a>Web请求</h3><h4 id="使服务器支持Spring的MVC-Web应用程序中的Web请求"><a href="#使服务器支持Spring的MVC-Web应用程序中的Web请求" class="headerlink" title="使服务器支持Spring的MVC Web应用程序中的Web请求"></a>使服务器支持Spring的MVC Web应用程序中的Web请求</h4><ol>
<li>创建和配置分发程序servlet</li>
<li>创建对应控制器类</li>
<li>在分发程序servlet上下文配置中配置控制器</li>
<li>声明视图解析器将控制器与视图绑定</li>
<li>创建视图渲染请求页面</li>
</ol>
<h4 id="创建和配置分发程序servlet"><a href="#创建和配置分发程序servlet" class="headerlink" title="创建和配置分发程序servlet"></a>创建和配置分发程序servlet</h4><p>分发程序servlet由org.springframework.web.servlet.DispatherServlet类表示，DispatherServlet与Spring框架的ApplicationContext集成。</p>
<p>分发程序servlet需要在web.xml中通过\<servlet>与\<servlet-mapping>声明和配置</servlet-mapping></servlet></p>
<p>dispatcher-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码*.hml表示扩展名为.hml的所有被请求URL都由分发程序servlet处理，若配置为*.* 表示分发servlet可以处理任何扩展名的所有被请求URL</p>
<h4 id="创建和配置控制器"><a href="#创建和配置控制器" class="headerlink" title="创建和配置控制器"></a>创建和配置控制器</h4><p>编写一个类并注解为@Controller,假设已经配置了分发程序servlet TickDispatcher，创建机票预定控制器BookController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"><span class="keyword">import</span> bookTickets.Passenger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ModelAttribute;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> service.BookService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RquestMapping</span>(value=<span class="string">"/BookTickets.hmt"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoolController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BookService <span class="title">getBookService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookService</span><span class="params">(BookService bookService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookService = bookService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method=RequestMethod.GET)</span><br><span class="line">    <span class="function">Public String <span class="title">processForm</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">        Passenger p = <span class="keyword">new</span> Passenger();</span><br><span class="line">        model.addAttribute(<span class="string">"Passenger"</span>, p);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookTickets"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method=RequestMethod.POST)</span><br><span class="line">    <span class="function">Public String <span class="title">processFrom</span><span class="params">(@ModelAttribute(value=<span class="string">"Passenger"</span>)</span> Passenger p, ModelMap model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"helloMessage"</span>, bookService.sayHello(p.getNumTravellers()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookConfirmed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Congratulations!!! The tickets have been booked for "</span> + num + <span class="string">" travellers."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping()"></a>@RequestMapping()</h4><ul>
<li>value：指定类充当控制器的URL</li>
<li>method：指定http请求方法<ol>
<li>RequestMethod.GET</li>
<li>RequestMethod.POST</li>
</ol>
</li>
</ul>
<p>控制器不自己处理请求，而是将请求委托给对应service服务类如上述BokService。</p>
<p>控制器以org.springframework.ui.ModelMap类返回的ModelMap对象的形式将结构转发回浏览器</p>
<h4 id="ModelMap中addAttribute方法"><a href="#ModelMap中addAttribute方法" class="headerlink" title="ModelMap中addAttribute方法"></a>ModelMap中addAttribute方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelMap <span class="title">addAttribute</span><span class="params">(String attributeName, Object attributeValue)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>attributeName：要添加到ModelMap对象的属性名</li>
<li>attributeValue：要添加到ModelMap对象的对象</li>
</ul>
<h4 id="在分发程序servlet中配置控制器"><a href="#在分发程序servlet中配置控制器" class="headerlink" title="在分发程序servlet中配置控制器"></a>在分发程序servlet中配置控制器</h4><p>以上述BookController为例配置TickerDispatcher-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"BookController"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.ParameterizableViewControler"</span> <span class="attr">p:viewName</span>=<span class="string">"BookTickets"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.BookController"</span> <span class="attr">p:bookService-ref</span>=<span class="string">"bookService"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="修改applicationcontext-xml通过注解创建控制器类的自动检测"><a href="#修改applicationcontext-xml通过注解创建控制器类的自动检测" class="headerlink" title="修改applicationcontext.xml通过注解创建控制器类的自动检测"></a>修改applicationcontext.xml通过注解创建控制器类的自动检测</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xis:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           "</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResurceBundleMessageSource"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/messages"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">preperty</span> <span class="attr">name</span>=<span class="string">"cacheSeconds"</span> <span class="attr">value</span>=<span class="string">"3000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span>/&gt;</span> <span class="comment">&lt;!-- * --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span> <span class="comment">&lt;!-- * --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bookService"</span> <span class="attr">class</span>=<span class="string">"service.BookService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookController"</span> <span class="attr">class</span>=<span class="string">"controller.BookController"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">porperty</span> <span class="attr">name</span>=<span class="string">"bookService"</span> <span class="attr">ref</span>=<span class="string">"bookService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码中\<context:component-scan>标记用于在Spring中启用自动扫描base-package指定需扫描文件夹找出并注册带有@Controller注解的bean，\<mvc:annotation-driven>标记指定应用程序支持注解驱动的MVC控制器。</mvc:annotation-driven></context:component-scan></p>
<h4 id="将请求映射到控制器"><a href="#将请求映射到控制器" class="headerlink" title="将请求映射到控制器"></a>将请求映射到控制器</h4><p>Spring中处理映射由org.springframework.web.servlet.HandlerMapping接口表示</p>
<p><strong>映射实现类</strong></p>
<ul>
<li>BeanNameUrlHandlerMapping</li>
<li>SimpleUrlHandlerMapping</li>
<li>ControllerClassNameHandlerMapping</li>
</ul>
<p>考虑用户访问以下URL</p>
<ol>
<li><a href="http://myurl.com/account/showAccount" target="_blank" rel="noopener">http://myurl.com/account/showAccount</a></li>
<li><a href="http://myurl.com/account/createAccount" target="_blank" rel="noopener">http://myurl.com/account/createAccount</a></li>
<li><a href="http://myurl.com/account/deleteAccount" target="_blank" rel="noopener">http://myurl.com/account/deleteAccount</a></li>
</ol>
<h5 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h5><p>使用org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanhandlermapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/showAccount.htm"</span> <span class="attr">class</span>=<span class="string">"controller.ShowAccountController"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/createAccount.htm"</span> <span class="attr">class</span>=<span class="string">"controller.CreateAccountController"</span>/&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/deleteAccount.htm"</span> <span class="attr">class</span>=<span class="string">"controller.DeleteAccountController"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h5><p>使用org.springframework.web.servlet.handler.SimpleUrlHandlerMapping类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"showAccountController"</span> <span class="attr">class</span>=<span class="string">"controller.ShowAccountController"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"createAccountController"</span> <span class="attr">class</span>=<span class="string">"controller.CreateAccountController"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"deleteAccountController"</span> <span class="attr">class</span>=<span class="string">"controller.DeleteAccountController"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simplehandlermapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapping"</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/showAccount.htm"</span>&gt;</span>showAccountController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/createAccount.htm"</span>&gt;</span>createAccountController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/deleteAccount.htm"</span>&gt;</span>deleteAccountController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="ControllerClassNameHandlerMapping"><a href="#ControllerClassNameHandlerMapping" class="headerlink" title="ControllerClassNameHandlerMapping"></a>ControllerClassNameHandlerMapping</h5><p>使用org.springframework.web.servlet.handler.ControllerClassNameHandlerMapping类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ControllerClassNameHandlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.ControllerClassNameHandlerMapping"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.ShowAccountController"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.CreateAccountController"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.DeleteAccountController"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="将响应渲染至客户机"><a href="#将响应渲染至客户机" class="headerlink" title="将响应渲染至客户机"></a>将响应渲染至客户机</h4><ul>
<li>声明视图解析器</li>
<li>创建视图</li>
</ul>
<h5 id="声明视图解析器"><a href="#声明视图解析器" class="headerlink" title="声明视图解析器"></a>声明视图解析器</h5><p>Spring使用视图解析器将逻辑通名称解析为视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	A(Controller) --&gt; B(DispatcherServlet) --&gt; C(View)</span><br><span class="line">	B --&gt;D(ViewResolver) --&gt; B</span><br></pre></td></tr></table></figure>
<p>Spring利用org.springframework.web.servlet.ViewResolver接口执行此任务</p>
<p><strong>ViewResolver接口</strong></p>
<ul>
<li>InternalResourceViewResolver</li>
<li>BeanNameViewResolver</li>
<li>ResourceBundleViewResolver</li>
<li>XmlViewResolver</li>
</ul>
<p>例如渲染JSP视图使用InternalResourceViewResolver</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">p:prefix</span>=<span class="string">"WEB-INF/jsp"</span> <span class="attr">p:suffix</span>=<span class="string">".jsp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><p>Spring提供了自己的标记库来创建视图</p>
<p>使用spring标记库需要在视图中包含以下指令</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"http://www.springframework.org/tags"</span> prefix=<span class="string">"spring"</span> %&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Spring标记库标记</strong></p>
<ul>
<li><p>\<spring:bing>将bean属性与表单组件绑定，包括一个path用于指定需要与表单组件绑定的bean属性路径</spring:bing></p>
<p>假设将input与Student bean的name绑定</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;spring:bind path=<span class="string">"Student.name"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"$&#123;status.expression&#125;"</span> value=<span class="string">"$&#123;status.value&#125;"</span>/&gt;</span><br><span class="line">&lt;/spring:bind&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>status.expression：用于返回表示bean属性的表达式，提交表单时Spring使用此表达式将表单组件与bean属性绑定</p>
</li>
<li><p>status.value：用于返回bean的属性值</p>
</li>
<li><p>status.nestedPath指定\<spring:bind>标记path的前缀路径</spring:bind></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring:nestedPath</span> <span class="attr">path</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring:bind</span> <span class="attr">path</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"$&#123;status.expression&#125;"</span> <span class="attr">value</span>=<span class="string">"$&#123;status.value&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">spring:bind</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring:bind</span> <span class="attr">path</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"$&#123;status.expression&#125;"</span> <span class="attr">value</span>=<span class="string">"$&#123;status.value&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">spring:bind</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">spring:nestedPath</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h2><h3 id="介绍AOP"><a href="#介绍AOP" class="headerlink" title="介绍AOP"></a>介绍AOP</h3><p>Web应用程序中有多个服务不属于应用程序的主业务逻辑的组成部分，如登录、安全性和事务管理，可以将这些服务视为横切关注点，因为它们趋向于横跨应用程序的多个模块。通过在应用程序的多个模块实现这些关注点可能会引入如下复杂性</p>
<ul>
<li>这些服务对于Web是必需的，需要在每个模块中实现，所以这些横切关注点代码在应用程序多个模块间是重复的，一旦更改需要更改每个模块，即使为这些横切关注点创建了单独的模块也需要在每个模块中写代码调用。</li>
<li>应用程序模块包含于核心功能无关的代码。</li>
</ul>
<p>为了降低复杂性简化程序结构Spring提供了面向方面编程（AOP）</p>
<h4 id="AOP功能"><a href="#AOP功能" class="headerlink" title="AOP功能"></a>AOP功能</h4><ul>
<li>将次要逻辑与主逻辑隔离增加模块性</li>
<li>提供封装如高速缓存、安全性、持久性、事务之类的横切关注点，将这些模块与核心应用程序分离</li>
<li>可以通过Java类中定义方法实现方面减少重复代码。</li>
<li>能够轻松删除先前定义的功能</li>
</ul>
<h4 id="AOP组件"><a href="#AOP组件" class="headerlink" title="AOP组件"></a>AOP组件</h4><ul>
<li>通知：是切入切点的时机，是方面的执行操作，用于表示应用程序的次要关注点。（订票中诸如验证用户、检查座位可用性、更新剩余票数之类的次要工作这些可以为前置通知或后置通知）</li>
<li>连接点：是应用程序的点或位置，可在该处插入通知。（主逻辑是订票所以包含订票逻辑的<strong>方法</strong>为连接点）</li>
<li>切入点：定义特定通知应用于哪个连接点。（订票所有通知的切入点为订票方法book()这个3-）</li>
<li>目标：是方面应用到的对象，所以执行应用程序主逻辑的类被称为目标对象。（实现订票主逻辑的类）</li>
<li>代理：包裹目标对象并截取该对象所作的所有调用</li>
<li>织入：在指定连接点将方面应用到目标对象以创建新的被代理对象的过程。</li>
</ul>
<h3 id="实现AOP-1"><a href="#实现AOP-1" class="headerlink" title="实现AOP"></a>实现AOP</h3><h4 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h4><p>SpringAOP借助AspectJ的语法  可以通过@EnableAspectJAutoProxy注解开启（SpringBoot引入依赖后默认开启）</p>
<p>可以通过@Aspect 将一个类声明为一个切面</p>
<p>@Pointcut声明切点，使用指示符execution匹配方法执行的连接点</p>
<p>使用@Before @AfterReturning @AfterThrowing @After @Around声明通知</p>
<p>为top.suvvm.dao包下所有方法添加前置通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuvvmAspect</span> </span>&#123;	<span class="comment">// 这是一个切面</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(execution(* top.suvvm.dao..*.*(..)))</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">xxxTransfer</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">//这是一个切点里面包含一些连接点</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"xxxTransfer()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advice</span><span class="params">()</span> </span>&#123;	<span class="comment">//这是一个前置通知</span></span><br><span class="line">        <span class="comment">// do some things</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Xml实现"><a href="#Xml实现" class="headerlink" title="Xml实现"></a>Xml实现</h4><p>以上述订票为例</p>
<p>用于订票book()方法的BookTicketInterface</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookTicketInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">book</span><span class="params">(String numTravelers, String trnPass)</span></span>;	<span class="comment">//乘客人数与交易密码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookTicket</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AOP;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookTicket</span> <span class="keyword">implements</span> <span class="title">BookTicketInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">book</span><span class="params">(String numTravelers, String trnPass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 各种订票代码实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现AOP要执行以下操作</p>
<ul>
<li>创建通知</li>
<li>定义切入点</li>
<li>创建代理</li>
</ul>
<h5 id="创建通知"><a href="#创建通知" class="headerlink" title="创建通知"></a>创建通知</h5><p>通知种类</p>
<ul>
<li><p>前置通知：在连接点（book()）前执行，需导入org.springframework.aop.MethodBeforeAdvice接口，该接口包含before()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwalbe</span></span><br></pre></td></tr></table></figure>
<ol>
<li>method 通知将应用到的方法</li>
<li>args 调用方法是传递给方法的参数</li>
<li>target 方法调用的目标（对其调用方法的对象）</li>
</ol>
</li>
<li><p>返回后通知：在连接点正常执行完成后执行，需导入org.springframework.aop.AfterReturningAdvice接口，该接口包含afterReturning()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwalbe</span></span><br></pre></td></tr></table></figure>
<ol>
<li>returnValue 保存从被调用的方法返回的值</li>
</ol>
</li>
<li><p>抛出后通知：在抛出异常后执行，需导入org.springframework.aop.ThrowsAdvice接口，该接口包含afterThrowing()方法BookTicketApp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable throwable)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>应由通知处理的异常</li>
</ol>
</li>
</ul>
<p>BookTicketApp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AOP;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookTicketApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String password;	<span class="comment">// 用户交易密码</span></span><br><span class="line">    <span class="keyword">private</span> String travelers;	<span class="comment">// 乘客数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassowrd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTravelers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">return</span> travelers;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTravelers</span><span class="params">(String travelers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.travelers = travelers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandleRequestController</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/BookTicket.htm"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleRequestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showView</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">        BookTicketApp bt = <span class="keyword">new</span> BookTicketApp();</span><br><span class="line">        model.addAttribute(<span class="string">"book"</span>, bt);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookTicket"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method=RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">processView</span><span class="params">(@ModelAttribute(<span class="string">"book"</span>)</span> BookTicketApp bt, ModelMap model) </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"AOP/Config.xml"</span>);</span><br><span class="line">        BookTicetInterface perf=(BookTickInterface)ctx.getBean(<span class="string">"bookProxy"</span>);</span><br><span class="line">        <span class="comment">// 如果用户验证成功将对于用户验证结果，总价格信息，奖励信息加入ModelMap</span></span><br><span class="line">        <span class="comment">// 否则将错误信息加入ModelMap</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookTicket"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要功能机票预定，次要工作验证用户、检查座位可用性、更新座位、奖励礼券等</p>
<p>SecondaryJob类</p>
<ol>
<li>验证用户</li>
<li>检查座位可用性</li>
<li>更新订票后的可用座位数</li>
<li>奖励礼券</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AOP;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondaryJob</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String pwd)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 成功记录 User is Authenticated</span></span><br><span class="line">        <span class="comment">// 失败记录 Authentiction Failed. Please Enter a Valid Transaction Password.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证座位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSeatsAvailability</span><span class="params">(String numTrav)</span></span>&#123;</span><br><span class="line">   		<span class="comment">// 对比传入的乘客数与座位总数</span></span><br><span class="line">        <span class="comment">// 成功记录成功信息</span></span><br><span class="line">        <span class="comment">// 失败记录失败信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新订票后的可用座位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSeat</span><span class="params">(String numTrav)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 现有座位减去传入的乘客数</span></span><br><span class="line">        <span class="comment">// 上一步验证座位成功记录成功信息</span></span><br><span class="line">        <span class="comment">// 上一步验证座位失败不做记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奖励方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rewardGift</span><span class="params">(String numTrav)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证座位且超过1000美元就记录奖励信息</span></span><br><span class="line">        <span class="comment">// 否则什么也不记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring配置文件Config.xml中配置SecondaryJob</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sj"</span> <span class="attr">class</span>=<span class="string">"AOP.SecondaeyJob"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>之后便是配置通知</strong></p>
<ul>
<li>使用java类</li>
<li>使用配置元素</li>
</ul>
<h5 id="使用JAVA类"><a href="#使用JAVA类" class="headerlink" title="使用JAVA类"></a>使用JAVA类</h5><p>创建SeconaryJobAdvice实现通知</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AOP;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondaryJonAdvice</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondaryJobAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span>,<span class="title">AfterReturningAdvice</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> SecondaryJob secondary;</span><br><span class="line">        <span class="comment">// 前置</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">            secondary.authenticate(args[<span class="number">1</span>].toString());</span><br><span class="line">            secondary.checkSeatsAvailability(args[<span class="number">0</span>].toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回后</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">            secondary.updateSeat(args[<span class="number">0</span>].toString());</span><br><span class="line">            secondary.rewardGift(args[<span class="number">0</span>].toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecondary</span><span class="params">(SecondaryJob secondary)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.secondary = secondary;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后需要在Spring配置文件Config.xml将上方类配置为bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"secondaryJobAdvice"</span> <span class="attr">class</span>=<span class="string">"AOP.SecondaryJobAdvice"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"secondary"</span> <span class="attr">ref</span>=<span class="string">"sj"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="使用配置元素"><a href="#使用配置元素" class="headerlink" title="使用配置元素"></a>使用配置元素</h5><p>可用使用Spring配置文件中的aop名称空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br></pre></td></tr></table></figure>
<p><strong>配置元素</strong></p>
<ul>
<li>\<aop:config>：SpringAop配置元素 用于定义所有AOP配置</aop:config></li>
<li>\<aop:aspect>：用于声明方面，具有引用Spring配置文件中定义的相应方面bean的ref属性</aop:aspect></li>
<li>\<aop:before>：用于定义前置通知</aop:before></li>
<li>\<aop:after-returning>：返回后通知</aop:after-returning></li>
<li>\<aop:atter-throwing>：抛出后通知</aop:atter-throwing></li>
<li>\<aop:around>：配置之前和返回后都执行的方法</aop:around></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"js"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"authenticate"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"checkSeatsAvailability"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"updateSeats"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"rewardGift"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="定义切入点"><a href="#定义切入点" class="headerlink" title="定义切入点"></a>定义切入点</h5><p>切入点在Srping配置文件中定义Spring提供了org.springframework.aop.support.JdkRegexpMethodPointcut类，该类允许使用正则表达式定义切入点，此类有一个名为pattern的属性，其value属性用于指定引用通知可以应用到的方法的特定模式</p>
<p>例如：value属性为PrimaryJob.*book的模式将把通知应用于PrimaryJob类中任何以book结尾的方法</p>
<p>为用户预定机票的方法名为book()这里将book指定为模式的切入点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookingPointCut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">prorerty</span> <span class="attr">neme</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">".*book"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义了切入点后还需要定义将那些通知应用到该切入点，所以要创建将通知与切入点相链接的通知器，Spring提供org.springframework.aop.support.DefaultPointcutAdvisor类来创建通知器</p>
<p>以上方机票预定程序为例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"secondarryJobAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"secondaryJobAdvice"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span> <span class="attr">ref</span>=<span class="string">"bookingPontCut"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码创建了将secondaryJobAdvice bean与bookingPointCut bean所定义的切入点相链接的secondaryJobAdvisor bean</p>
<p>也可以使用Spring配置元素来定义切入点</p>
<p>\<aop:pointcut>元素用来定义切入点此元素包含名为expression的属性，此属性用于定义执行连接点方法的表达式，语法：</aop:pointcut></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression &#x3D; &quot;execution(regular_expression)&quot;</span><br></pre></td></tr></table></figure>
<p>regular_expression为精确确定需要执行哪种方法的切入点表达式</p>
<p>使用pointcut-ref属性可在多个通知元素之间引用切入点。</p>
<p>以机票预定程序为例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"js"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">expression</span>=<span class="string">"execution(* book*())"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"authenticate"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"checkSeatsAvailability"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"updateSeats"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"rewardGift"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h5><p>创建通知器后还需要创建调用该通知类的代理，代理充当通知、目标对象、连接点、切入点和通知器之间的链接，Spring提供了org.springframework.aop.config.ProxyFactory类</p>
<p>所需参数</p>
<ul>
<li>target：指定想要代理的目标对象</li>
<li>interceptorNames： 已在Spring配置文件中定义的通知器bean名称的列表</li>
<li>proxyInterfaces：指定应用程序主逻辑界面的名称</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inst"</span> <span class="attr">class</span>=<span class="string">"AOP.BookTicket"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bookProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.config.ProxyFactory"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"inst"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"secondaryJovAdvisor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterface"</span> <span class="attr">value</span>=<span class="string">"AOP.BookTicketInterface"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建了bookProxy bean目标对象时主逻辑类BooKTicket通知器为secondaryJovAdvisor bean</p>
<p>主逻辑界面为声明book()方法的BookTicketInterface接口</p>
<p>要从HandleRequestController调用代理以订票要添加如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processView</span><span class="params">(@MedelAttribute(<span class="string">"book"</span>)</span> BookTicketApp bt, ModelMap model) </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPatchXmlApplicationContext(<span class="string">"AOP/Config.xml"</span>);</span><br><span class="line">    BookTicketInterface perf = (BootTicketInterface)ctx.getBean(<span class="string">"bootProxy"</span>);</span><br><span class="line">    perf.book(bt.getTravelers(), bt.getPassword());</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="踩坑警告"><a href="#踩坑警告" class="headerlink" title="踩坑警告"></a>踩坑警告</h4><p>当开启springAOP功能时，spring将通过CDLIB生成连接点所在对象的子类作为代理类，CGLIB将直接生成字节码而不经过Java编译器，所生成的子类在构造时不会调用super()，也就是说代理类不会初始化任何成员变量，包括final类型的成员变量，所以使用方法调用连接点所在对象中的属性。</p>
<h2 id="将Spring与业务层和表示层集成"><a href="#将Spring与业务层和表示层集成" class="headerlink" title="将Spring与业务层和表示层集成"></a>将Spring与业务层和表示层集成</h2><h3 id="Spring集成JSF"><a href="#Spring集成JSF" class="headerlink" title="Spring集成JSF"></a>Spring集成JSF</h3><h4 id="解析JSF-Bean"><a href="#解析JSF-Bean" class="headerlink" title="解析JSF Bean"></a>解析JSF Bean</h4><p>在JSF配置文件faces-config.xml声明JSF受管Bean JsfBean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">managed-bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">managed-bean-name</span>&gt;</span>JsfBean<span class="tag">&lt;/<span class="name">meanaged-bean-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">managed-bean-class</span>&gt;</span>JsfManagedBean<span class="tag">&lt;/<span class="name">meanaged-bean-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">managed-bean-scop</span>&gt;</span>request<span class="tag">&lt;/<span class="name">managed-bean-scop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">managed-bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="添加Spring框架"><a href="#添加Spring框架" class="headerlink" title="添加Spring框架"></a>添加Spring框架</h4><p>在jsf应用程序中添加Spring框架需要在web.xml中提供applicationContext.xml的映射</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上段代码是在web.xml中声明ContextLoaderListener侦听器类以加载Spring上下文，之后applicationContext.xml中声明的bean将在整个应用程序中可见</p>
<p>之后还要声明程序分发servlet</p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.htm<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="解析Spring-Bean"><a href="#解析Spring-Bean" class="headerlink" title="解析Spring Bean"></a>解析Spring Bean</h4><p>为了调用Spring应用程序上下文中声明的Spring bean，Spring框架提供org.springframework.web.jsf.el.SpringBeanFaccesELResolver类此类在faces-config.xml文件的\<el-resover>中指定</el-resover></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">el-resolver</span>&gt;</span>org.springframework.web.jsf.el.SpringBeanFacesELResolver<span class="tag">&lt;/<span class="name">el-resolver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码声明的SpringBeanFacesELResolver bean变量解析器首先尝试从Spring应用上下文文件解析bean，如果不能解析bean，解析器将查找JSFbean变量解析器中是否有同名bean。</p>
<p>JSF受管bean JsfBean在Spring applicationContext.xml中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"JsdBean"</span> <span class="attr">class</span>=<span class="string">"JsfManagedBean"</span> <span class="attr">scope</span>=<span class="string">"request"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring集成Hibernate"><a href="#Spring集成Hibernate" class="headerlink" title="Spring集成Hibernate"></a>Spring集成Hibernate</h3><p>Hubernate是ORM（对象关系映射工具）Spring位于应用程序类和ORM之间，集成后可将Hibernate对象作为Spring bean使用。</p>
<h4 id="Hibernate功能"><a href="#Hibernate功能" class="headerlink" title="Hibernate功能"></a>Hibernate功能</h4><ul>
<li>提供对象\关系映射</li>
<li>支持基本面向对象原则</li>
<li>提供透明持久性</li>
<li>独立于数据库平台</li>
<li>提供Hibernate查询语言（HQL）</li>
<li>支持查询高速缓存，提供统计信息</li>
<li>受常用ide支持</li>
<li>提供xml保存映射信息</li>
<li>可以在受管和非受管环境运行，也可以在应用服务器容器外部和独立应用程序内部运行</li>
<li>提供有助于发现已被修改的对象的攒肚数据检查的功能</li>
</ul>
<h4 id="实现ORM"><a href="#实现ORM" class="headerlink" title="实现ORM"></a>实现ORM</h4><p>要将Spring与Hibernate集成需要</p>
<ul>
<li>在Spring中配置SessionFactory对象</li>
<li>使用数据访问对象DAO访问和更新数据</li>
</ul>
<h5 id="在Spring中配置SessionFactory对象"><a href="#在Spring中配置SessionFactory对象" class="headerlink" title="在Spring中配置SessionFactory对象"></a>在Spring中配置SessionFactory对象</h5><p>首先需要创建Spring配置文件spring-hibernate.xml</p>
<p>之后使用Spring提供的org.springframework.orm.hibernate4.LocalSessionFactoryBean类声明会话工厂</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate4.LocalSessionFactoryBean"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"hibernate.cfg.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上方声明了带有id mySessionFactory的会话工厂bean 为配置此bean，提供了Hibernate配置文件的位置作为configLocation属性的值</p>
<p>hibernate.cfg.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding-"UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration P	ublic 	"-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.DerbyDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.contection.driver_class"</span>&gt;</span>org.apache.deerby.jdbc.ClientDriver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:derby://localhost:1527/University<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.contection.username"</span>&gt;</span>university<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.contection.password"</span>&gt;</span>password<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"university/Coursedetaills.hbm.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码与已有University数据库建立连接，Coursedetail.hbm.xml文件包含带有Coursedetails类的COURSEDETAILS表的映射信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"nuiversity.Coursedetails"</span> <span class="attr">table</span>=<span class="string">"COURSEDETAILS"</span> <span class="attr">schema</span>=<span class="string">"UNIVERSITY"</span>&gt;</span>			<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"courseid"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"COURSEID"</span> <span class="attr">length</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"assigned"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"courseduration"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"COURSENAME"</span> <span class="attr">length</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"courseeligibility"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"COURSEFEE"</span> <span class="attr">length</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"coursefee"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"COURSEFEE"</span> <span class="attr">length</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>DAO类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Criteria;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuaration;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.criterion.Restrictions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseDetailsDAO</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionFactory</span><span class="params">(SessionFactory sessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sessionFactory = sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CourseDetailsDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">getcourseByName</span><span class="params">(String courseName)</span></span>&#123;</span><br><span class="line">        List&lt;Coursedetails&gt; courselist=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Session session = sessionFactory.openSession();</span><br><span class="line">            org.hibernate.Transaction tx = session.beginTransaction();</span><br><span class="line">            Criteria criteria = session.createCriteria(Coursedetails.class).add(Restrictions.eq(<span class="string">"coursename"</span>, courseName));</span><br><span class="line">            courselist = (List&lt;Coursedetails&gt; criteria.list());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStrackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> courselist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了DAO类CourseDetailsDAO。此类创建了SessionFactory对象并使用该对象打开了一个会话以从数据库中检索数据</p>
<p>除了DAO还需要再spring-hibernate.xml中将其声明为bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"courseDetailsDAO"</span> <span class="attr">class</span>=<span class="string">"unversity.CourseDetails.DAO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"mySessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以用以下代码像访问其他Spring bean一样访问该bean及其方法</p>
<p>CourseDetailDAO类的getcourseByName()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext apc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"university/spring-hibernate.xml"</span>);</span><br><span class="line">CourseDetailsDAO courseDao=(CourseDetailsDAO)apc.getBean(<span class="string">"courseDeatilsDao"</span>);</span><br><span class="line">List&lt;Coursedetails&gt; courses = <span class="keyword">new</span> ArraryList&lt;Coursedetails&gt;();</span><br><span class="line">courses = courseDao.getcourseByName(cName);</span><br></pre></td></tr></table></figure>
<h2 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h2><h3 id="事务的功能"><a href="#事务的功能" class="headerlink" title="事务的功能"></a>事务的功能</h3><p>事务将任意数量的单个操作组成组，从而使整个过程看起来是一个工作逻辑单元。</p>
<h4 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h4><ul>
<li>原子性：执行所有数据修改或不执行任何数据修改</li>
<li>一致性：成功完成事务后所以数据均处于一致状态。关系数据库中的所有规则必须均应用到事务中的修改，以维护整个数据的完整性</li>
<li>隔离性： 每个事务执行都必须看起来好像独立于在同一环境中并发运行的其他事务</li>
<li>持久性：完成的事务对数据库所做的任何更改在系统中永久有效，因此由于完成的事务在数据中做的任何更改甚至在系统故障的情况下也得以保持，这由日志备份和恢复事务日志的概念所确保。</li>
</ul>
<h3 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h3><ul>
<li>传播行为</li>
<li>隔离级别</li>
<li>只读</li>
<li>事务超时</li>
<li>回滚规则</li>
</ul>
<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>传播行为定义为org.springframework.transactionDefintion接口中的常量</p>
<ul>
<li>PROPAGATION_MANDATORY 当前方法必须在事务内运行，如果没有任何现有事务在运行将抛出异常</li>
<li>PROPAGATION_REQUIRED 当前方法必须在事务内运行，如果由现有事务正在运行，那么该方法将在事务内运行，如果没有事务在运行将开启新事务</li>
<li>PROPAGATION_NOT_SUPPORTED 当前方法不应该在事务内运行，如果有某个现有事务正在进行，那么它将暂挂直到方法的持续时间结束。</li>
<li>PROPAGATION_REQUIRED_NEW 当前方法必须在自己的事务中运行，因此将开始一个新事物，但是如果有某个现有事务正在进行，那么它将暂挂直到方法的持续时间结束。</li>
<li>PROPAGATION_SUPPORTS 当前事务不需要运行事务，但如果有某个事务正在运行，当前方法可以在其内运行</li>
<li>PROPAGATION_NESTED 如果有某个现有事务正在运行，方法应在嵌套事务内运行，嵌套事务可以被提交，也可以单独从外围事务中回归，如果不存在外围事务那么它的行为像PROPAGATION_REQUIRED 一样</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>有多个事务并发运行可能导致</p>
<ul>
<li>脏读：当一个事务读取已由另一个事务写入但是尚未提交的数据时发生，如果稍后回滚更改那么第一个事务所获得的数据将无效。</li>
<li>不可重复读：当事务两次或多次执行同一查询而每次检索的数据都不同时发生。由于有另一个并发事务正在更新数据</li>
<li>幻象度：当事务T1度多行数据而并发事务T2同时插入更多行时发生，进行后续查询时第一个事务T1发现了原先不在该处的更多行</li>
</ul>
<p>为了避免上述问题，事务应该彼此完全隔离，因此Spring提供了几种隔离级别</p>
<ul>
<li>ISOLATION_DEFAULT 使用底层数据存储的默认隔离级别，默认隔离级别可以是任何隔离级别</li>
<li>ISOLATION_READ_UNCOMMITTED 允许事务读取尚未由其他事务提交的更改，可能会导致脏读、幻象读和不可重复读</li>
<li>ISOLATION_READ_COMMITTED 允许事务仅读取已由其他事务提交的那些更改，可以防止脏读，但幻象读和不可重复读仍会发生</li>
<li>ISOLATION_REPEATABLE_READ 确保事务从同一字段执行多次读取将生成同一结果，其他事务在正在进行的事务读取期间对此字段所作的任何更新都将被禁止，可以防止脏读、不可重复读，但幻象读仍可能发生</li>
<li>ISOLATION_SERIALIZABLE 这是完全符合ACID的隔离级别，可以确保防止发生所有问题，在当前事务的持续时间中，其他并发事务不能访问同一数据表，是所有隔离级别中最慢的一种。</li>
</ul>
<p>只读</p>
<p>只读事务不修改任何事务</p>
<p>事务超时</p>
<p>声明事务在特定时间段后自动回滚，防止死锁</p>
<p>回滚规则</p>
<p>指定那些异常导致事务回滚</p>
<h2 id="实现事务"><a href="#实现事务" class="headerlink" title="实现事务"></a>实现事务</h2><h3 id="定义事务管理器"><a href="#定义事务管理器" class="headerlink" title="定义事务管理器"></a>定义事务管理器</h3><p>Spring提供了用于所有事务管理器的一般接口，PlatformTransactionManager接口，封装了事务管理的核心功能并提供以下三种方法管理事务</p>
<ul>
<li>getTransaction() ：根据指定传播行为返回当前活动的事务或创建新事务</li>
<li>commit()：将给定事务提交至数据存储</li>
<li>rollback() ：回滚给定事务</li>
</ul>
<p>与不同事务管理API一同使用</p>
<ul>
<li>JDBC：DataSourceTransactionManager</li>
<li>JTA：JtaTransactionManager</li>
<li>Hibernate：HibernateTransactionManager</li>
<li>JPA：JpaTransactionManager</li>
<li>JDO：JdoTransactionManager</li>
</ul>
<p>使用事务管理器需要在Spting配置文件中声明为bean，如使用Hibernate</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate4.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"mySessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>声明了一个将事务管理委托给Hibernate事务的事务管理器，需要设置sessionFactory属性以便底层事务管理器可以使用指定会话工厂创建事务</p>
<p>mySessionFactory</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.srpingframework.orm.hibernate4.LocalSessionFactory"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"org.apache.derby.jdbc.ClientDriver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">value</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上方声明了mySessionFactorybean保存通过org.springframework.jdbc.datasource.DiverManagerDataSource类声明的数据源bean的引用</p>
<p>数据源bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DiverManagerDataSource"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">class</span>=<span class="string">"org.apache.derby.jdbc.DlientDriver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:derby://localhost:1527/Sample"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"Sample"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passowrd"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>声明dataSource bean保存了在Hibernate配置文件中声明的数据源信息</p>
<h3 id="使用配置管理元素"><a href="#使用配置管理元素" class="headerlink" title="使用配置管理元素"></a>使用配置管理元素</h3><p>要声明事务需要在Spring配置文件中添加tx名称空间，由于事务作为方面实现所以也要添加aop名称空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br></pre></td></tr></table></figure>
<p>tx模式和aop模式位置(beans)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xis:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">           http://www.springframework.org/schema/aop</span><br><span class="line">           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</span><br><span class="line">           http://www.springframework.org/schema/tx</span><br><span class="line">           http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</span><br></pre></td></tr></table></figure>
<p>tx名称空间提供的xml配置元素</p>
<ul>
<li>tx:advice：创建调用事务管理器的通知，每个事务通知都要在配置文件中有一个标识符和到事务管理器的引用</li>
<li>tx:attributes：设置事务属性描述事务行为</li>
<li>tx:method：定义一个或多个方法的事务属性，策略：<ul>
<li>name：指定方法的名称（*指定所有方法）</li>
<li>propagation：定义事务传播规则</li>
<li>isolation：设置用于事务的隔离级别</li>
<li>timeout：超时时间（秒）</li>
<li>read-only：只读</li>
<li>roolback-for：回滚异常列表</li>
<li>no-rollback-for：不需要回滚的异常列表</li>
</ul>
</li>
</ul>
<p>以机场订票为例</p>
<p>PaymentServices接口声明了方法bookTicket()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testl;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bookTicket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BookingDAO定义bookTicket()，使用当前会话工厂创建事务预定机票更新可用座位数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookingDAO</span> <span class="keyword">implements</span> <span class="title">PaymentServices</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SessionFActory sessionFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookingDAO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionFactory</span><span class="params">(SessionFactory sessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sessionFactory = sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        org.hibernate.Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Session session = sessionFactory.openSession();</span><br><span class="line">            tx = session.beginTransaction();</span><br><span class="line">            tx.commit()</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tx != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tx.rollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Spring配置文件中装配BookingDAO</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transaction"</span> <span class="attr">class</span>=<span class="string">"test.BookingDAO"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mySessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在可用tx:adivce元素声明事务策略</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txadvide"</span> <span class="attr">transcation-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>事务管理器引用称为txManager，所有方法都必须在事务内执行；否则抛出异常</p>
<p>在aop:config元素声明一个通知器将通知与切入点关联</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pp"</span> <span class="attr">expression</span>=<span class="string">"execution(*test.PaymentService.*())"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上方创建了一个一个切入点和一个通知器。pointcut属性使用切入点表达式来指示此通知器应通知PaymentServices接口的所有方法，但是事务内实际运行的方法由事务通知定义，该通知从通知器的advice-ref属性引用。</p>
<p>在Spring配置文件中配置事务总结</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate4.LocalSessionFactoryBean"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"hibernate.cfg.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DiverManagerDataSource"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">class</span>=<span class="string">"org.apache.derby.jdbc.DlientDriver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:derby://localhost:1527/Sample"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"Sample"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passowrd"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txadvide"</span> <span class="attr">transcation-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pp"</span> <span class="attr">expression</span>=<span class="string">"execution(*test.PaymentService.*())"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txadvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate4.HibernaetTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"mySessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transaction"</span> <span class="attr">class</span>=<span class="string">"test.BookingDAO"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mySessonFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在需要调用trasaction bean将返回一个 为此bean启用了事务管理的代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"Config.xml"</span>);</span><br><span class="line">PaymentServices perf=(PaymentServices)ctx.getBean(<span class="string">"transaction"</span>);</span><br><span class="line">pref.bookTicket();</span><br></pre></td></tr></table></figure>
<p>上述代码在应用程序上下文对象ctx中检索了配置文件Config.xml的引用 transaction bean引用返回代理对象perf用于执行transaction bean的bookTicket()方法</p>
<p>使用注解配置事务</p>
<p>Spring使用org.springframework.transction.anntation.Transactional类的@Transactional元素并提供tx:annotation-driven元素支持注解驱动的事务管理，其具有transaction-amager属性，此属性指定对将调用其以实现事务的现有PlatformTransactionManager bean的引用</p>
<p>@Transactional注解属性</p>
<ul>
<li>propagation 类型：org.springframework.annotation.transaction.propagation 指定要使用的事务传播</li>
<li>isolation 类型org.springframework.annotation.transaction.isolation 设置隔离级别</li>
<li>timeout 类型 int 指定超时时间</li>
<li>readOnly 类型 boolean 是否为只读事务 </li>
<li>onRollbackFor 类型 java.lang.class<T> 不回滚的异常列表</T></li>
<li>rollbackFor 类型 java.lang.class<T> 回滚的异常列表</T></li>
</ul>
<p>@Transactional默认设置</p>
<ul>
<li>传播设置：PROPAGATION_REQUIRED</li>
<li>隔离级别：ISOLATION_DEFAULT</li>
<li>事务是读写事务</li>
<li>事务超时为底层事务系统默认超时时间或者不支持超时</li>
</ul>
<p>使用注解的BookDAO</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookingDAO</span> <span class="keyword">implements</span> <span class="title">PaymentServices</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SessionFActory sessionFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookingDAO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionFactory</span><span class="params">(SessionFactory sessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sessionFactory = sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED, readOnly = <span class="keyword">false</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bookTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        org.hibernate.Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Session session = sessionFactory.openSession();</span><br><span class="line">            tx = session.beginTransaction();</span><br><span class="line">            tx.commit()</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tx != <span class="keyword">null</span>)&#123;</span><br><span class="line">                tx.rollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置文件中只需指定tx:annotation-driven元素并为其提供事务管理器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mySessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate4.LocalSessionFactoryBean"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"hibernate.cfg.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DiverManagerDataSource"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">class</span>=<span class="string">"org.apache.derby.jdbc.DlientDriver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:derby://localhost:1527/Sample"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"Sample"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passowrd"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.hibernate4.HibernaetTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span> <span class="attr">ref</span>=<span class="string">"mySessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transaction"</span> <span class="attr">class</span>=<span class="string">"test.BookingDAO"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionFactory"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mySessonFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/22/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B-L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B-L3-005-%E5%9E%83%E5%9C%BE%E7%AE%B1%E5%88%86%E5%B8%83/" class="post-title-link" itemprop="url">PTA (天梯赛) L3-005 垃圾箱分布</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 22:20:33" itemprop="dateCreated datePublished" datetime="2019-11-22T22:20:33+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="L3-005-垃圾箱分布-30-分"><a href="#L3-005-垃圾箱分布-30-分" class="headerlink" title="L3-005 垃圾箱分布 (30 分)"></a>L3-005 垃圾箱分布 (30 分)</h2><p>大家倒垃圾的时候，都希望垃圾箱距离自己比较近，但是谁都不愿意守着垃圾箱住。所以垃圾箱的位置必须选在到所有居民点的最短距离最长的地方，同时还要保证每个居民点都在距离它一个不太远的范围内。</p>
<p>现给定一个居民区的地图，以及若干垃圾箱的候选地点，请你推荐最合适的地点。如果解不唯一，则输出到所有居民点的平均距离最短的那个解。如果这样的解还是不唯一，则输出编号最小的地点。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出4个正整数：<em>N</em>（≤103）是居民点的个数；<em>M</em>（≤10）是垃圾箱候选地点的个数；<em>K</em>（≤104）是居民点和垃圾箱候选地点之间的道路的条数；<em>D**S</em>是居民点与垃圾箱之间不能超过的最大距离。所有的居民点从1到<em>N</em>编号，所有的垃圾箱候选地点从<em>G</em>1到<em>G**M</em>编号。</p>
<p>随后<em>K</em>行，每行按下列格式描述一条道路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P1 P2 Dist</span><br></pre></td></tr></table></figure>
<p>其中<code>P1</code>和<code>P2</code>是道路两端点的编号，端点可以是居民点，也可以是垃圾箱候选点。<code>Dist</code>是道路的长度，是一个正整数。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先在第一行输出最佳候选地点的编号。然后在第二行输出该地点到所有居民点的最小距离和平均距离。数字间以空格分隔，保留小数点后1位。如果解不存在，则输出<code>No Solution</code>。</p>
<h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 3 11 5</span><br><span class="line">1 2 2</span><br><span class="line">1 4 2</span><br><span class="line">1 G1 4</span><br><span class="line">1 G2 3</span><br><span class="line">2 3 2</span><br><span class="line">2 G2 1</span><br><span class="line">3 4 2</span><br><span class="line">3 G3 2</span><br><span class="line">4 G1 3</span><br><span class="line">G2 G1 1</span><br><span class="line">G3 G2 2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G1</span><br><span class="line">2.0 3.3</span><br></pre></td></tr></table></figure>
<h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1 2 10</span><br><span class="line">1 G1 9</span><br><span class="line">2 G1 20</span><br></pre></td></tr></table></figure>
<h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Solution</span><br></pre></td></tr></table></figure>
<p>作者: 陈越</p>
<p>单位: 浙江大学</p>
<p>时间限制: 200 ms</p>
<p>内存限制: 64 MB</p>
<p>代码长度限制: 16 KB</p>
<p>这是个中规中矩的最短路题目，没有要求记录路径，只是在最后结果判断时有些许繁琐。</p>
<p>输入时需要判断一下输入的时数字还是垃圾桶候选点，PTA是支持c11的，c11的string封装了stringToInt的函数std::stoi所以在输入时将P1与P2全部以string类型读入之后进行处理即可。</p>
<p>处理函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span> inp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inp[<span class="number">0</span>] != <span class="string">'G'</span>)</span><br><span class="line">        <span class="keyword">return</span> stoi(inp);</span><br><span class="line">    <span class="keyword">if</span>(inp.size() == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> inp[<span class="number">1</span>] - <span class="string">'0'</span> + n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里起点的个数最多只有10个，所以直接遍历起点执行dijkstra即可。</p>
<p>dijkstra</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> bg)</span></span>&#123;</span><br><span class="line">    fill(d, d +MAXN, INF);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    d[bg] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Node&gt; Q;</span><br><span class="line">    Q.push(Node&#123;bg, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        Node top = Q.top();</span><br><span class="line">        <span class="keyword">int</span> u = top.v;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i.v;</span><br><span class="line">            <span class="keyword">int</span> dis = i.dis;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; d[u] + dis &lt; d[v])&#123;</span><br><span class="line">                d[v] = d[u] + dis;</span><br><span class="line">                Q.push(Node&#123;v,d[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意最终要求中最优为存在最长最短距离最长的最短路，若有多个最长最短距离相等的答案则取其中到每个点平均值最小的，若依旧有多个解则取其中垃圾桶标号最小的。</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, k, ds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;tNode) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; tNode.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span> inp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inp[<span class="number">0</span>] != <span class="string">'G'</span>)</span><br><span class="line">        <span class="keyword">return</span> stoi(inp);</span><br><span class="line">    <span class="keyword">if</span>(inp.size() == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> inp[<span class="number">1</span>] - <span class="string">'0'</span> + n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> bg)</span></span>&#123;</span><br><span class="line">    fill(d, d +MAXN, INF);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    d[bg] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Node&gt; Q;</span><br><span class="line">    Q.push(Node&#123;bg, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        Node top = Q.top();</span><br><span class="line">        <span class="keyword">int</span> u = top.v;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i.v;</span><br><span class="line">            <span class="keyword">int</span> dis = i.dis;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; d[u] + dis &lt; d[v])&#123;</span><br><span class="line">                d[v] = d[u] + dis;</span><br><span class="line">                Q.push(Node&#123;v,d[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> p1, p2;</span><br><span class="line">    <span class="keyword">int</span> dis;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; ds;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dis;</span><br><span class="line">        Adj[toInt(p1)].push_back(Node&#123;toInt(p2), dis&#125;);</span><br><span class="line">        Adj[toInt(p2)].push_back(Node&#123;toInt(p1), dis&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>,ansMin = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> ansSum = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; n + m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dijkstra(i);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">double</span> nowSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nowMin = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; ds)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d[j] &lt; nowMin)&#123;</span><br><span class="line">                nowMin = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">            nowSum += d[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nowMin &gt; ansMin)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                ansMin = nowMin;</span><br><span class="line">                ansSum = nowSum;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nowMin == ansMin) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ansSum &gt; nowSum)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    ansSum = nowSum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'G'</span> &lt;&lt; ans-n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f %.1f\n"</span>, (<span class="keyword">double</span>)ansMin, ((ansSum / (<span class="keyword">double</span>)n) * <span class="number">100.0</span>+<span class="number">0.5</span>)/<span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Floyd原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 17:23:17" itemprop="dateCreated datePublished" datetime="2019-11-16T17:23:17+08:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Floyd（弗洛伊德算法）"><a href="#Floyd（弗洛伊德算法）" class="headerlink" title="Floyd（弗洛伊德算法）"></a>Floyd（弗洛伊德算法）</h2><h3 id="Floyd算法原理"><a href="#Floyd算法原理" class="headerlink" title="Floyd算法原理"></a>Floyd算法原理</h3><p>Floyd算法是用来解决全源最短路问题的算法，其原理支持便是如果给定的图中存在一个顶点k，使得以k点作为中介点时可以使图中另外两个顶点，顶点i与顶点j之间的最短距离缩短。假设以d[i][j]作为当前顶点i与顶点j之间的最短距离，则上述原理可以表示为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(d[i][k] + d[k][i] &lt; d[i][j]) &#123;</span><br><span class="line">	d[i][j] = d[i][k] + d[k][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd过程模拟"><a href="#Floyd过程模拟" class="headerlink" title="Floyd过程模拟"></a>Floyd过程模拟</h3><p>以下图为例，进行一次Floyd运行过程的模拟。</p>
<p><img src="/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/floyd1-1.svg" alt="img"></p>
<h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><p>初始将所有点之间的最短距离都记为无穷大，每个点到其本身距离为0，在输入时记录更新路径两端的点的最短距离。</p>
<p>初始最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第一个k（k为A点）"><a href="#第一个k（k为A点）" class="headerlink" title="第一个k（k为A点）"></a>第一个k（k为A点）</h4><p>遍历所有顶点，查看以A点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;B当前为无穷大 C-&gt;A当前为4 A-&gt;B当前为2 C-&gt;B被A优化为4+2&#x3D;6</span><br><span class="line">C-&gt;D当前为无穷大 C-&gt;A当前为4 A-&gt;D当前为1 C-&gt;D被A优化为4+1&#x3D;5</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td><code>6</code></td>
<td>0</td>
<td><code>5</code></td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第二个k（k为B点）"><a href="#第二个k（k为B点）" class="headerlink" title="第二个k（k为B点）"></a>第二个k（k为B点）</h4><p>遍历所有顶点，查看以B点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;E当前为无穷大 A-&gt;B当前为2 B-&gt;E当前为10 A-&gt;E被B优化为2+10&#x3D;12</span><br><span class="line">C-&gt;E当前为无穷大 C-&gt;B当前为6 B-&gt;E当前为10 C-&gt;E被B优化为6+10&#x3D;16</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td><code>12</code></td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td><code>16</code></td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第三个k（k为C点）"><a href="#第三个k（k为C点）" class="headerlink" title="第三个k（k为C点）"></a>第三个k（k为C点）</h4><p>遍历所有顶点，查看以C点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D-&gt;A当前为无穷大 D-&gt;C当前为2 C-&gt;A当前为4 D-&gt;A被C优化为2+4&#x3D;6</span><br><span class="line">D-&gt;B当前为无穷大 D-&gt;C当前为2 C-&gt;B当前为6 D-&gt;B被C优化为2+6&#x3D;8</span><br><span class="line">D-&gt;F当前为8 D-&gt;C当前为2 C-&gt;F当前为5 D-&gt;F被C优化为2+5&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>12</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>16</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td><code>6</code></td>
<td><code>8</code></td>
<td>2</td>
<td>0</td>
<td>2</td>
<td><code>7</code></td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第四个k（k为D点）"><a href="#第四个k（k为D点）" class="headerlink" title="第四个k（k为D点）"></a>第四个k（k为D点）</h4><p>遍历所有顶点，查看以D点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;C当前为无穷大 A-&gt;D当前为1 D-&gt;C当前为2 A-&gt;C被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;E当前为12 A-&gt;D当前为1 D-&gt;E当前为2 A-&gt;E被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;F当前为无穷大 A-&gt;D当前为1 D-&gt;F当前为7 A-&gt;F被D优化为1+7&#x3D;8</span><br><span class="line">A-&gt;G当前为无穷大 A-&gt;D当前为1 D-&gt;G当前为4 A-&gt;G被D优化为1+4&#x3D;5</span><br><span class="line">B-&gt;A当前为无穷大 B-&gt;D当前为3 D-&gt;A当前为6 B-&gt;A被D优化为3+6&#x3D;9</span><br><span class="line">B-&gt;C当前为无穷大 B-&gt;D当前为3 D-&gt;C当前为2 B-&gt;C被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;E当前为10 B-&gt;D当前为3 D-&gt;E当前为2 B-&gt;E被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;F当前为无穷大 B-&gt;D当前为3 D-&gt;F当前为7 B-&gt;F被D优化为3+7&#x3D;10</span><br><span class="line">B-&gt;G当前为无穷大 B-&gt;D当前为3 D-&gt;G当前为4 B-&gt;G被D优化为3+4&#x3D;7</span><br><span class="line">C-&gt;E当前为16 C-&gt;D当前为5 D-&gt;E当前为2 C-&gt;E被D优化为2+5&#x3D;7</span><br><span class="line">C-&gt;G当前为无穷大 C-&gt;D当前为5 D-&gt;G当前为4 C-&gt;G被D优化为5+4&#x3D;9</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td><code>3</code></td>
<td>1</td>
<td><code>3</code></td>
<td><code>8</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><strong>B</strong></td>
<td><code>9</code></td>
<td>0</td>
<td><code>5</code></td>
<td>3</td>
<td><code>5</code></td>
<td><code>10</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td><code>7</code></td>
<td>5</td>
<td><code>9</code></td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第五个k（k为E点）"><a href="#第五个k（k为E点）" class="headerlink" title="第五个k（k为E点）"></a>第五个k（k为E点）</h4><p>遍历所有顶点，查看以E点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>找不到可被优化的点。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第六个k（k为F点）"><a href="#第六个k（k为F点）" class="headerlink" title="第六个k（k为F点）"></a>第六个k（k为F点）</h4><p>遍历所有顶点，查看以F点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>找不到可被优化的点。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第七个k（k为G点）"><a href="#第七个k（k为G点）" class="headerlink" title="第七个k（k为G点）"></a>第七个k（k为G点）</h4><p>遍历所有顶点，查看以G点为中介时是否存在任意两点之间的最短距离可以被优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;F当前为8 A-&gt;G当前为5 G-&gt;F当前为1 A-&gt;F被G优化为5+1&#x3D;6</span><br><span class="line">B-&gt;F当前为10 B-&gt;G当前为7 G-&gt;F当前为1 B-&gt;F被G优化为7+1&#x3D;8</span><br><span class="line">D-&gt;F当前为7 D-&gt;G当前为4 G-&gt;F当前为1 D-&gt;F被G优化为4+1&#x3D;5</span><br><span class="line">E-&gt;F当前为无穷大 E-&gt;G当前为6 G-&gt;F当前为1 E-&gt;F被G优化为6+1&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td><code>6</code></td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td><code>8</code></td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td><code>5</code></td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td><code>7</code></td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>9</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k ++)&#123;    <span class="comment">//存在顶点k可以使得顶点i到顶点j的最小距离缩短</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span><br><span class="line">                    dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">                   <span class="comment">// printf("%c优化%c-&gt;%c:%7d\n",'A' + k ,'A'+i, 'A'+j,dis[i][j]);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 输出每次优化的数据</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; n; i ++)&#123;</span></span><br><span class="line"><span class="comment">            for( int j = 0; j &lt; n; j ++)&#123;</span></span><br><span class="line"><span class="comment">                printf("%c-&gt;%c:%7d ", 'A'+i, 'A'+j,dis[i][j]);</span></span><br><span class="line"><span class="comment">                // cout &lt;&lt; dis[i][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; i ++)&#123;    // 错误写法</span></span><br><span class="line"><span class="comment">        for(int j = 0; j &lt; n; j ++)&#123;</span></span><br><span class="line"><span class="comment">            for(int k = 0; k &lt; n; k ++)&#123;</span></span><br><span class="line"><span class="comment">                if(dis[i][k] != INF &amp;&amp; dis[k][j] != INF &amp;&amp; dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span></span><br><span class="line"><span class="comment">                    dis[i][j] = dis[i][k] + dis[k][j];</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边 (端点1 端点2 权值):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dis[u][v] = w;</span><br><span class="line">        <span class="comment">//dis[v][u] = dis;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i ++)&#123;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"初始状态："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c-&gt;%c:%7d "</span>, <span class="string">'A'</span>+i, <span class="string">'A'</span>+j,dis[i][j]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dis[i][j] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Floyd();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最终状态："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c-&gt;%c:%7d "</span>, <span class="string">'A'</span>+i, <span class="string">'A'</span>+j,dis[i][j]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dis[i][j] &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>对于Floyd算法来说，最外层循环的k不能放到内层，如果将k放到内层会导致最终结果出错，这是因为如果先对被优化的点进行遍历的话，当其遍历过去后相当于已经固定之后再也无法优化。</p>
<p>例如，如果当前有一条路径i-&gt;u-&gt;v-&gt;j若u &gt; i 在遍历到u时出现了点k可以将u-&gt;v的距离缩短，但这时却无法重新对i-&gt;j进行优化，这就导致了错误。</p>
<h3 id="错误模拟"><a href="#错误模拟" class="headerlink" title="错误模拟"></a>错误模拟</h3><p>以下图为例，进行一次Floyd错误运行的模拟。</p>
<p><img src="/2019/11/16/Floyd%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/floyd1-1.svg" alt="img"></p>
<h4 id="初始状态-1"><a href="#初始状态-1" class="headerlink" title="初始状态"></a>初始状态</h4><p>初始将所有点之间的最短距离都记为无穷大，每个点到其本身距离为0，在输入时记录更新路径两端的点的最短距离。</p>
<p>初始最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第一个i（i为A点）"><a href="#第一个i（i为A点）" class="headerlink" title="第一个i（i为A点）"></a>第一个i（i为A点）</h4><p>遍历所有顶点，查看以A点为起点时是否存在A到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;C当前为无穷大 A-&gt;D当前为1 D-&gt;C当前为2 A-&gt;C被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;E当前为无穷大 A-&gt;B当前为2 B-&gt;E当前为10 A-&gt;E被B优化为2+10&#x3D;12</span><br><span class="line">A-&gt;E当前为12 A-&gt;D当前为1 D-&gt;E当前为2 A-&gt;E被D优化为1+2&#x3D;3</span><br><span class="line">A-&gt;F当前为无穷大 A-&gt;C当前为3 C-&gt;F当前为5 A-&gt;F被C优化为3+5&#x3D;8</span><br><span class="line">A-&gt;G当前为无穷大 A-&gt;D当前为1 D-&gt;G当前为4 A-&gt;G被C优化为1+4&#x3D;5</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td><code>3</code></td>
<td>1</td>
<td><code>3</code></td>
<td><code>8</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>3</td>
<td>10</td>
<td>∞</td>
<td>∞</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第二个i（i为B点）"><a href="#第二个i（i为B点）" class="headerlink" title="第二个i（i为B点）"></a>第二个i（i为B点）</h4><p>遍历所有顶点，查看以B点为起点时是否存在B到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B-&gt;C当前为无穷大 B-&gt;D当前为3 D-&gt;C当前为2 B-&gt;C被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;E当前为10 B-&gt;D当前为3 D-&gt;E当前为2 B-&gt;E被D优化为3+2&#x3D;5</span><br><span class="line">B-&gt;F当前为无穷大 B-&gt;C当前为5 C-&gt;F当前为5 B-&gt;F被C优化为5+5&#x3D;10</span><br><span class="line">B-&gt;G当前为无穷大 B-&gt;D当前为3 D-&gt;G当前为4 B-&gt;G被D优化为3+4&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td><code>5</code></td>
<td>3</td>
<td><code>5</code></td>
<td><code>10</code></td>
<td><code>7</code></td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>∞</td>
<td>5</td>
<td>∞</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第三个i（i为C点）"><a href="#第三个i（i为C点）" class="headerlink" title="第三个i（i为C点）"></a>第三个i（i为C点）</h4><p>遍历所有顶点，查看以C点为起点时是否存在C到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;B当前为无穷大 C-&gt;A当前为4 A-&gt;B当前为2 C-&gt;B被A优化为4+2&#x3D;6</span><br><span class="line">C-&gt;D当前为无穷大 C-&gt;A当前为4 A-&gt;D当前为1 C-&gt;D被A优化为4+1&#x3D;5</span><br><span class="line">C-&gt;E当前为无穷大 C-&gt;A当前为4 A-&gt;E当前为3 C-&gt;E被A优化为4+3&#x3D;7</span><br><span class="line">C-&gt;G当前为无穷大 C-&gt;A当前为4 A-&gt;G当前为5 C-&gt;G被A优化为4+5&#x3D;9</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td><code>6</code></td>
<td>0</td>
<td><code>5</code></td>
<td><code>7</code></td>
<td>5</td>
<td><code>9</code></td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第四个i（i为D点）"><a href="#第四个i（i为D点）" class="headerlink" title="第四个i（i为D点）"></a>第四个i（i为D点）</h4><p>遍历所有顶点，查看以D点为起点时是否存在D到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D-&gt;A当前为无穷大 D-&gt;C当前为2 C-&gt;A当前为4 D-&gt;A被C优化为2+4&#x3D;6</span><br><span class="line">D-&gt;B当前为无穷大 D-&gt;A当前为6 A-&gt;B当前为2 D-&gt;B被A优化为6+2&#x3D;8</span><br><span class="line">D-&gt;F当前为8 D-&gt;C当前为2 C-&gt;F当前为5 D-&gt;F被C优化为2+5&#x3D;7</span><br><span class="line">D-&gt;F当前为7 D-&gt;G当前为4 G-&gt;F当前为1 D-&gt;F被G优化为4+1&#x3D;5</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td><code>6</code></td>
<td><code>8</code></td>
<td>2</td>
<td>0</td>
<td>2</td>
<td><code>5</code></td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第五个i（i为E点）"><a href="#第五个i（i为E点）" class="headerlink" title="第五个i（i为E点）"></a>第五个i（i为E点）</h4><p>遍历所有顶点，查看以E点为起点时是否存在E到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>可以找到如下可被优化的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E-&gt;F当前为无穷大 E-&gt;G当前为6 G-&gt;F当前为1 E-&gt;F被G优化为6+1&#x3D;7</span><br></pre></td></tr></table></figure>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td><code>7</code></td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第六个i（i为F点）"><a href="#第六个i（i为F点）" class="headerlink" title="第六个i（i为F点）"></a>第六个i（i为F点）</h4><p>遍历所有顶点，查看以F点为起点时是否存在F到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>没有可优化的情况。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第七个i（i为G点）"><a href="#第七个i（i为G点）" class="headerlink" title="第七个i（i为G点）"></a>第七个i（i为G点）</h4><p>遍历所有顶点，查看以G点为起点时是否存在G到任意其他一点之间的最短距离可以被另一点优化。</p>
<p>没有可优化的情况。</p>
<p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h4 id="错误结果"><a href="#错误结果" class="headerlink" title="错误结果"></a>错误结果</h4><p>当前最短距离表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>A</strong></td>
<td>0</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>5</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>∞</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>4</td>
<td>6</td>
<td>0</td>
<td>5</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>4</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>0</td>
<td>∞</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>明显与上方正确答案存在很大差异</p>
<p>所以对中介点k的遍历一定要放在最外层。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">SPFA原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-13 08:13:28" itemprop="dateCreated datePublished" datetime="2019-11-13T08:13:28+08:00">2019-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SPFA原理分析"><a href="#SPFA原理分析" class="headerlink" title="SPFA原理分析"></a>SPFA原理分析</h2><h3 id="贝尔曼-福特算法时间复杂度"><a href="#贝尔曼-福特算法时间复杂度" class="headerlink" title="贝尔曼 福特算法时间复杂度"></a>贝尔曼 福特算法时间复杂度</h3><p>针对N个顶点E条边的连通图，由于Bellman Ford算法需要对所有的边遍历N-1次后再添加一次额外的遍历(<a href="https://www.suvvm.work/2019/11/12/Bellman-Ford原理分析/">详见</a>)，其时间复杂度为 $ O(N\times E)$ 。这个复杂度依旧不尽人意，现在要对其进行优化，之前针对贝尔曼 福特算法的分析中指出，如果最短路存在，松弛操作的次数不会超过N-1，正因如此，每个点被优化的次数也不会超过N-1，且只有当某个顶点u到源点的最短距离发生改变，它所发出的边所指向的另外一点v到源点的最短路才有可能会发生改变。</p>
<h3 id="进行优化"><a href="#进行优化" class="headerlink" title="进行优化"></a>进行优化</h3><p>以上方思想为指导进行优化，初始将源点到所有顶点最短路距离视为无穷大，之后维护一个队列，每次将队首的顶点u取出，对从u出发的所有边进行遍历，如果u可以使边另一端的顶点v到达源点的最短距离缩短，则进行优化操作，如果当前v不在队列中则将v入队，这样一旦队列为空时证明所有的优化已经完成，便可以成功获得源点到所有点的最短路长度，而一旦某个点被优化的次数超过N-1则说明给出的图中有从源点可达的负环。</p>
<h3 id="模拟SPFA运行过程"><a href="#模拟SPFA运行过程" class="headerlink" title="模拟SPFA运行过程"></a>模拟SPFA运行过程</h3><p>以下图为例，进行一次SPFA运行过程的模拟。</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-1.svg" alt="img"></p>
<p>以A为起点，依旧用其他最短路算法一样，将初始状态的，源点到所有点之间的最短距离视为无穷大。</p>
<h4 id="优化源点"><a href="#优化源点" class="headerlink" title="优化源点"></a>优化源点</h4><p>记录源点到其本身的距离为0，并将其入队。</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-2.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h4><p>将队首的元素A出队，遍历所有以A为起点的边</p>
<p>以A为起点的边有权值为2的$A\rightarrow B$与权值为3的$A\rightarrow C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边A(0)	2	B(∞)	将B点到源点的最短距离由无穷大优化为0+2&#x3D;2</span><br><span class="line">边A(0)	3	C(∞)	将C点到源点的最短距离由无穷大优化为0+2&#x3D;3</span><br></pre></td></tr></table></figure>
<p>将被优化的B点和C点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-3.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h4><p>将队首的元素B出队，遍历所有以B为起点的边</p>
<p>以B为起点的边有权值为6的$B\rightarrow E$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边B(2)	6	E(∞)	将E点到源点的最短距离由无穷大优化为2+6&#x3D;8</span><br></pre></td></tr></table></figure>
<p>将被优化的E点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-4.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>C</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">8</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第三次优化"><a href="#第三次优化" class="headerlink" title="第三次优化"></a>第三次优化</h4><p>将队首的元素C出队，遍历所有以C为起点的边</p>
<p>以B为起点的边有权值为-2的$C\rightarrow B$与权值为5的$C\rightarrow E$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边C(3)	-2	B(2)	将B点到源点的最短距离由无穷大优化为3-2&#x3D;1</span><br><span class="line">边C(3)	5	E(8)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>将被优化的B点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-5.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>E</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">∞</td>
<td style="text-align:left">8</td>
<td style="text-align:left">∞</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第四次优化"><a href="#第四次优化" class="headerlink" title="第四次优化"></a>第四次优化</h4><p>将队首的元素E出队，遍历所有以E为起点的边</p>
<p>以E为起点的边有权值为-5的$E\rightarrow D$与权值为8的$E\rightarrow F$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边E(8)	-5	D(∞)	将D点到源点的最短距离由无穷大优化为8-5&#x3D;3</span><br><span class="line">边E(8)	8	F(∞)	将F点到源点的最短距离由无穷大优化为8+8&#x3D;16</span><br></pre></td></tr></table></figure>
<p>将被优化的点D点F入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-6.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>B</th>
<th>D</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3</td>
<td>16</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">8</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第五次优化"><a href="#第五次优化" class="headerlink" title="第五次优化"></a>第五次优化</h4><p>将队首的元素B出队，遍历所有以B为起点的边</p>
<p>以B为起点的边有权值为6的$B\rightarrow E$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边B(1)	4	E(8)	将E点到源点的最短距离由8优化为1+6&#x3D;7</span><br></pre></td></tr></table></figure>
<p>将被优化的E点入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-7.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>D</th>
<th>F</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>16</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第六次优化"><a href="#第六次优化" class="headerlink" title="第六次优化"></a>第六次优化</h4><p>将队首的元素D出队，遍历所有以D为起点的边</p>
<p>以D为起点的边有权值为4的$D\rightarrow B$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边D(3)	6	B(1)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-8.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>F</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第七次优化"><a href="#第七次优化" class="headerlink" title="第七次优化"></a>第七次优化</h4><p>将队首的元素F出队，遍历所有以F为起点的边</p>
<p>以F为起点的边有权值为3的$F\rightarrow C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边F(16)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-9.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left">7</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第八次优化"><a href="#第八次优化" class="headerlink" title="第八次优化"></a>第八次优化</h4><p>将队首的元素E出队，遍历所有以E为起点的边</p>
<p>以E为起点的边有权值为-5的$E\rightarrow D$与权值为8的$E\rightarrow F$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">边E(7)	-5	D(3)	将D点到源点的最短距离由无穷大优化为7-5&#x3D;2</span><br><span class="line">边E(7)	8	F(16)	将F点到源点的最短距离由无穷大优化为7+8&#x3D;15</span><br></pre></td></tr></table></figure>
<p>将被优化的点D点F入队</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-10.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>D</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第九次优化"><a href="#第九次优化" class="headerlink" title="第九次优化"></a>第九次优化</h4><p>将队首的元素D出队，遍历所有以D为起点的边</p>
<p>以D为起点的边有权值为4的$D\rightarrow B$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边D(2)	4	B(1)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-11.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<h4 id="第十次优化"><a href="#第十次优化" class="headerlink" title="第十次优化"></a>第十次优化</h4><p>将队首的元素F出队，遍历所有以F为起点的边</p>
<p>以F为起点的边有权值为3的$F\rightarrow C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边F(15)	3	C(3)	并不能进行优化</span><br></pre></td></tr></table></figure>
<p>没有要入队的点</p>
<p><img src="/2019/11/13/SPFA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/spfa1-12.svg" alt="img"></p>
<p>此时队列中的点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>没啦！</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>当前A点到所有点的最短路长度表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">A</th>
<th style="text-align:left">B</th>
<th style="text-align:left">C</th>
<th style="text-align:left">D</th>
<th style="text-align:left">E</th>
<th style="text-align:left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">15</td>
</tr>
</tbody>
</table>
</div>
<p>到此为止所有的优化都完成了，虽然比较原生的Bellman-Ford要多了五次优化，但SPFA的每次优化并不需要遍历所有边，只需要遍历以出队点为源点的边即可，这就将SPFA的时间复杂度大大降低，降为了$O(M\times E)$而且通常情况下M不会超过2，这使得SPFA再处理没有负环的情况下的速度往往要优于堆优化的dijkstra，但是不要太寄希望于SPFA，都知道它快，所以有很多题目都会有专门的一组数据来卡SPFA（具体请随便找一个搜索引擎搜索卡SPFA），而且SPFA在有负环时时间复杂度会退化为$O(N\times E)$ 我比较懒，就不模拟负环运行了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN];</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d, d + MAXN, INF); <span class="comment">//初始化起点到所有点的最短路长度为无穷大</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; Q;</span><br><span class="line">    d[s] = <span class="number">0</span>;   <span class="comment">//起点至本身的距离为0</span></span><br><span class="line">    Q.push(Node&#123;s, <span class="number">0</span>&#125;); <span class="comment">//这里队列中Node.v为当前点 Node.dis为当前点至起点的距离</span></span><br><span class="line">    inq[s] = <span class="literal">true</span>;  <span class="comment">//将s标记为已入队</span></span><br><span class="line">    num[s]++;   <span class="comment">//s入队次数加一</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        Node f = Q.front();   <span class="comment">//获取队首元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" 出队点："</span> &lt;&lt; f.v;</span><br><span class="line">        Q.pop();    <span class="comment">//出队</span></span><br><span class="line">        inq[f.v] = <span class="literal">false</span>; <span class="comment">//将队首对应的点标记为未入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : Adj[f.v])&#123; <span class="comment">//遍历所有该点的相邻点</span></span><br><span class="line">            <span class="keyword">int</span> v = i.v;</span><br><span class="line">            <span class="keyword">int</span> dis = i.dis;</span><br><span class="line">            <span class="keyword">if</span>(d[f.v] + i.dis &lt; d[i.v])&#123;    <span class="comment">//判断是否可以优化</span></span><br><span class="line">                d[i.v] = d[f.v] + i.dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[i.v])&#123;  <span class="comment">//优化并入队</span></span><br><span class="line">                    Q.push(Node&#123;i.v, d[i.v]&#125;);</span><br><span class="line">                    inq[i.v] = <span class="literal">true</span>;</span><br><span class="line">                    num[i.v] ++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v] &gt;= n) <span class="comment">//入队次数超过n-1则有负环</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边数"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入边 (端点1 端点2 权值):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> u, v, dis;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; dis;</span><br><span class="line">        Adj[u].push_back(Node&#123;v, dis&#125;);</span><br><span class="line">        <span class="comment">//Adj[v].push_back(Node&#123;u, dis&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入起点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入终点:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    <span class="keyword">if</span>(SPFA(s))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"起点到终点最短路长度:"</span> &lt;&lt; d[e] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" : "</span> &lt;&lt; d[i] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路不存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SUVVM"
      src="/images/ortrait.jpg">
  <p class="site-author-name" itemprop="name">SUVVM</p>
  <div class="site-description" itemprop="description">SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suvvm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suvvm" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/suvvm@foxmail.com" title="E-Mail → suvvm@foxmail.com"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SUVVM</span>
	<a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">鲁ICP备19040043号-2</a>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
