<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/ortrait.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.suvvm.work","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:type" content="website">
<meta property="og:title" content="SUVVM">
<meta property="og:url" content="https://www.suvvm.work/page/15/index.html">
<meta property="og:site_name" content="SUVVM">
<meta property="og:description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SUVVM">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.suvvm.work/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SUVVM</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e5190116d64be66cac29daef18c94ac0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SUVVM</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">呜嗷SUVVM</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/11/HDU-2955-Robberies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/11/HDU-2955-Robberies/" class="post-title-link" itemprop="url">HDU 2955 Robberies</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-11 23:55:21" itemprop="dateCreated datePublished" datetime="2018-11-11T23:55:21+08:00">2018-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>　　The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university. </p>
<p> <img src="http://acm.hdu.edu.cn/data/images/con211-1010-1.jpg" alt="img"><br>　　For a few months now, Roy has been assessing the security of various banks and the amount of cash they hold. He wants to make a calculated risk, and grab as much money as possible. </p>
<p>　　His mother, Ola, has decided upon a tolerable probability of getting caught. She feels that he is safe enough if the banks he robs together give a probability less than this.</p>
<p>Input</p>
<p>　　The first line of input gives T, the number of cases. For each scenario, the first line of input gives a floating point number P, the probability Roy needs to be below, and an integer N, the number of banks he has plans for. Then follow N lines, where line j gives an integer Mj and a floating point number Pj .<br>Bank j contains Mj millions, and the probability of getting caught from robbing it is Pj .</p>
<p>Output</p>
<p>　　For each test case, output a line with the maximum number of millions he can expect to get while the probability of getting caught is less than the limit set. </p>
<p>Notes and Constraints<br>0 &lt; T &lt;= 100<br>0.0 &lt;= P &lt;= 1.0<br>0 &lt; N &lt;= 100<br>0 &lt; Mj &lt;= 100<br>0.0 &lt;= Pj &lt;= 1.0 </p>
<p>　　A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds.</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0.04 3</span><br><span class="line">1 0.02</span><br><span class="line">2 0.03</span><br><span class="line">3 0.05</span><br><span class="line">0.06 3</span><br><span class="line">2 0.03</span><br><span class="line">2 0.03</span><br><span class="line">3 0.05</span><br><span class="line">0.10 3</span><br><span class="line">1 0.03</span><br><span class="line">2 0.02</span><br><span class="line">3 0.05</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题是讲抢劫犯母亲帮助抢劫犯计算抢银行，题目给出一个数字T为测试数量，之后给出一行包括两个数字P与N，P为抢劫犯母亲认为安全的最大被抓概率，N为银行数量，之后N行跟随，每行包括两个数字，Mj抢劫这家银行可以获得的钱财，Pj抢劫这家银行被抓的概率，每家银行只能抢一次。要求输出低于抢劫犯母亲预计被抓几率所能获得的最大收益。</p>
<p>　　我们可以计算出抢劫银行的所有获利情况所对应的最大逃脱率，1 - 最大逃脱率便是当前获利对应最低被抓率。与抢劫犯母亲的预期进行比较便可以获得最大收益。</p>
<p>　　基本思路是动态规划01背包问题背包最大容量为抢劫所有银行可以获得的收益，背包内容物价值为逃脱率。</p>
<p>　　用dp[ j ]记录收益为 j 时的最大逃脱率，这样就可以写出动态转移方程：</p>
<p>　　　　dp[ j ] = max(dp[ j ], dp[ j - p[ i ] ] * (1 - m[ i ])</p>
<p>　　之后遍历dp找到被抓率低于抢劫犯母亲预计的最大收益即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>  * <span class="number">100</span>;    </span><br><span class="line"><span class="comment">//整个程序中最大的数组为dp其元素个数最多为最多银行个数乘以最大获益金额</span></span><br><span class="line"><span class="keyword">int</span> money[maxn];    <span class="comment">//money保存抢劫每个银行的收益</span></span><br><span class="line"><span class="keyword">double</span> probability[maxn];   <span class="comment">//probability保存抢劫每个银行被抓概率</span></span><br><span class="line"><span class="keyword">double</span> dp[maxn];    <span class="comment">//dp保存每个获益金额对应的最高逃脱率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t) != EOF)&#123;  <span class="comment">//输入测试数量</span></span><br><span class="line">        <span class="keyword">double</span> p;</span><br><span class="line">        <span class="keyword">int</span> n, maxMoney = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;p, &amp;n); <span class="comment">//输入母亲预计值与银行数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;money[i], &amp;probability[i]);</span><br><span class="line">            maxMoney += money[i];   <span class="comment">//记录最大获益金额</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxMoney; i++)&#123; <span class="comment">//初始化dp为0</span></span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//不抢银行不会被警察叔叔抓</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;    <span class="comment">//遍历银行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = maxMoney; j &gt;= money[i]; j--)&#123;  <span class="comment">//01背包逆序遍历背包容量</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - money[i]] *(<span class="number">1</span> - probability[i]));</span><br><span class="line">                <span class="comment">//动态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxMoney; i++)&#123; </span><br><span class="line">            <span class="comment">//遍历dp找到低于母亲预计值的最大收益</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; <span class="number">1</span> - p)</span><br><span class="line">                ans = max(ans, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/10/PTA-Advanced-Level-1040-Longest-Symmetric-String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/10/PTA-Advanced-Level-1040-Longest-Symmetric-String/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1040 Longest Symmetric String</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-10 20:57:01" itemprop="dateCreated datePublished" datetime="2018-11-10T20:57:01+08:00">2018-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given <code>Is PAT&amp;TAP symmetric?</code>, the longest symmetric sub-string is <code>s PAT&amp;TAP s</code>, hence you must output <code>11</code>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>　　Each input file contains one test case which gives a non-empty string of length no more than 1000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>　　For each test case, simply print the maximum length in a line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Is PAT&amp;TAP symmetric?</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出一行字符这里记为text，要求输出改行字符中最大回文串的长度。这里采用动态规划做法，用布尔数组dp[ bg ][ ed ]记录下标 bg ~ ed 组成的子串是否为回文串。设长度为1的字符串为回文串，在初始化dp数组是可以将长度为1与长度为2的字符串是否为回文串都标记完成。</p>
<p>　　对任意一个字符串都有两种情况：</p>
<p>　　1、是回文串,其对应dp为true;</p>
<p>　　2、不是回文串，其对应dp为false;</p>
<p>　　判断一个字符串是否为回文串只需要判断其首尾字符是否相等与其除首尾字符外的子串是否为回文串即可，这就转化为了求dp[bg + 1][ ed - 1]，和判断text[ bg ]与text[ ed ]是否相等的问题。</p>
<p>　　动态转移方程：dp[bg][ed] = 1（text[ bg ] == text[ ed ]，dp[bg + 1][ ed - 1 ] == true）</p>
<p>之后只要遍历所有子串长度，遍历所有起始下标，并计根据其实下标与子串长度计算出末尾下标，根据动态转移方程即可求出答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn][maxn] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">//默认所有字符串都不是回文</span></span><br><span class="line"><span class="built_in">string</span> text;    <span class="comment">//text为出入的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>, text);</span><br><span class="line">    <span class="keyword">int</span> len = text.size();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;    <span class="comment">//标记长度为1的字符串为回文串</span></span><br><span class="line">        ans = <span class="number">1</span>;    <span class="comment">//最大回文串长度为1</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; text[i] == text[i + <span class="number">1</span>])&#123;  <span class="comment">//如果有两个连续字符</span></span><br><span class="line">            <span class="comment">//（长度为2的回文串只有两个连续字符这种情况）</span></span><br><span class="line">            dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">//标记其组成的字符串为回文串</span></span><br><span class="line">            ans = <span class="number">2</span>;    <span class="comment">//最大回文串长度为2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> tempLen = <span class="number">3</span>; tempLen &lt;= len; tempLen++)&#123;    <span class="comment">//遍历子串长度长度从3 ~ len的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> bg = <span class="number">0</span>; bg + tempLen - <span class="number">1</span> &lt; len; bg++)&#123;  </span><br><span class="line">        <span class="comment">//遍历起始位置，末尾下标为起始位置+当前子串长度-1，末尾下标不能达到给定字符串末位</span></span><br><span class="line">            <span class="keyword">int</span> ed = bg + tempLen - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(text[bg] == text[ed] &amp;&amp; dp[bg + <span class="number">1</span>][ed - <span class="number">1</span>] == <span class="literal">true</span>)&#123; <span class="comment">//动态转移方程</span></span><br><span class="line">                dp[bg][ed] = <span class="number">1</span>;</span><br><span class="line">                ans = tempLen;  <span class="comment">//记录答案</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/09/POJ-1276-Cash-Machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/09/POJ-1276-Cash-Machine/" class="post-title-link" itemprop="url">POJ 1276 Cash Machine</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-09 20:15:53" itemprop="dateCreated datePublished" datetime="2018-11-09T20:15:53+08:00">2018-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>A Bank plans to install a machine for cash withdrawal. The machine is able to deliver appropriate @ bills for a requested cash amount. The machine uses exactly N distinct bill denominations, say Dk, k=1,N, and for each denomination Dk the machine has a supply of nk bills. For example, </p>
<p>　　N=3, n1=10, D1=100, n2=4, D2=50, n3=5, D3=10 </p>
<p>　　means the machine has a supply of 10 bills of @100 each, 4 bills of @50 each, and 5 bills of @10 each. </p>
<p>　　Call cash the requested amount of cash the machine should deliver and write a program that computes the maximum amount of cash less than or equal to cash that can be effectively delivered according to the available bill supply of the machine. </p>
<p>Notes:<br>　　@ is the symbol of the currency delivered by the machine. For instance, @ may stand for dollar, euro, pound etc. </p>
<p>Input</p>
<p>　　The program input is from standard input. Each data set in the input stands for a particular transaction and has the format: </p>
<p>　　cash N n1 D1 n2 D2 … nN DN </p>
<p>　　where 0 &lt;= cash &lt;= 100000 is the amount of cash requested, 0 &lt;=N &lt;= 10 is the number of bill denominations and 0 &lt;= nk &lt;= 1000 is the number of available bills for the Dk denomination, 1 &lt;= Dk &lt;= 1000, k=1,N. White spaces can occur freely between the numbers in the input. The input data are correct. </p>
<p>Output</p>
<p>　　For each set of data the program prints the result to the standard output on a separate line as shown in the examples below. </p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">735 3  4 125  6 5  3 350</span><br><span class="line">633 4  500 30  6 100  1 5  0 1</span><br><span class="line">735 0</span><br><span class="line">0 3  10 100  10 50  10 10</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">735</span><br><span class="line">630</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>Hint</p>
<p>　　The first data set designates a transaction where the amount of cash requested is @735. The machine contains 3 bill denominations: 4 bills of @125, 6 bills of @5, and 3 bills of @350. The machine can deliver the exact amount of requested cash. </p>
<p>　　In the second case the bill supply of the machine does not fit the exact amount of cash requested. The maximum cash that can be delivered is @630. Notice that there can be several possibilities to combine the bills in the machine for matching the delivered cash. </p>
<p>　　In the third case the machine is empty and no cash is delivered. In the fourth case the amount of cash requested is @0 and, therefore, the machine delivers no cash.</p>
<p>解题思路：<br>　　本题有多组测试数据，每组数据占一行，包括现金cash, 票据种类n，之后跟随n组数据每组包括票据数量，票据金额。要求输出小于等于现金的票据最大金额。</p>
<p>　　可以将本题转化为0 1背包问题，背包容量为现金数cash，背包内容物价值与占空间数都为票据面值。</p>
<p>　　基本思路是将每个面值的票据拆分，由于票据数量较大，直接拆分运算时会超时，所以我们对拆分进行优化。</p>
<p>二进制优化：</p>
<p>　　假设某一面值的票据有100张，我们并不需要将100张票据全部加入运算数组，我们将100拆分为数个小于100的数字，使这些数字可以构成1 ~ 100中任意一个数字。这里用到了一个数论的小知识：1，2，4 ~ 2^n 可以组成1 ~ 2^(n + 1) - 1之间的任意数，100便可分解为1，2，4，8，16，32，（取2的n次幂（二进制数），不能取到64，因为拆分100的话所有分解的数加起来不能超过100） 37（前面取到的1 ~ 32已经可以表示63以内所有的数了，那么再补上100 - 63 = 37这个数后就可以取到所有1 ~ 100的数了）。继续分析，假设这100张票据面值都为2，那我们就可用到我们分解出来的数字，根据这些数字我们把100张票分解1张，2张，4张，8张，16张，32张，37张这7组，这样我们便可以把100张面值为2的票据看成面值为2，4，8，16，32，64，74的7张票据。将这7张票据加入运算数组在运算时比起100张票据就要节约很多时间。</p>
<p>　　至于为什么1，2，4，8，16，32，37可以代替100，这很简单，之前已经写过了新的数组可以表示1 ~ 100所有数组，那么在运算中，我们如果需要拿5张面值1，在这里就和拿一张面值1一张面值4有同样效果拿其他所有1 ~ 100的数皆是这个道理。</p>
<p>背包思路：</p>
<p>　　动态规划，令dp[ j ]表示chsh为 j 时能得到的票据的最大金额。</p>
<p>　　对于第 i 张票据，有用或不用两种方案。</p>
<p>　　1、用第 i 块票据，问题转化为计算背包容量为 j - value[ i ] 在前i - 1张票据中取得最大金额问题dp[ j ]的值为前i - 1张票据中取得的最大金额 + 第 i 张票据的金额。</p>
<p>　　2、不用第 i 张票据，问题转化为背包容量为 j 时在前i - 1张票据中取得最大金额问题，dp[ j ]的值为前i - 1张票据中取得的最大金额。</p>
<p>　　动态转移方程：dp[ j ] = max(dp[ j ], dp[ j - value[ i ] ] + value[ i ])</p>
<p>　　边界为用前0张票据，最大金额为0，枚举所有票据，每次从最大背包容量开始逆序枚举便可获得答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> value[maxn];</span><br><span class="line"><span class="comment">//value记录票据面值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cash;   <span class="comment">//cash为现金金额（即背包容量）</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cash) != EOF)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(value));</span><br><span class="line">        <span class="comment">//初始化票据面值数组都为0</span></span><br><span class="line">        <span class="keyword">int</span> n, cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);    <span class="comment">//输入票据种类数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num, denomination;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;num, &amp;denomination);</span><br><span class="line">            <span class="comment">//输入每种票据的数量与面值</span></span><br><span class="line">            <span class="comment">//二进制拆分num</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">1</span>;  <span class="comment">//拆分的第一个数字为1</span></span><br><span class="line">            <span class="keyword">while</span>(num &gt;= j)&#123;    </span><br><span class="line">            <span class="comment">//所有拆分后数字的和不超过num</span></span><br><span class="line">            <span class="comment">//我们可以每拆分一个数就用num减去它直到num小于想要拆分的下一个数</span></span><br><span class="line">                value[cnt++] = j * denomination;    <span class="comment">//将拆分后的面值计入value</span></span><br><span class="line">                num -= j;   <span class="comment">//num减去当前拆分的数字</span></span><br><span class="line">                j *= <span class="number">2</span>; <span class="comment">//下一个要拆分的数字为当前数字的两倍</span></span><br><span class="line">            &#125;</span><br><span class="line">            value[cnt++] = num * denomination;  </span><br><span class="line">            <span class="comment">//最后补上差的数字，并记录其组成的面值</span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="comment">//初始化边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;  <span class="comment">//枚举票据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = cash; j &gt;= value[i]; j--)&#123;  <span class="comment">//逆序枚举背包容量</span></span><br><span class="line">                dp[j] = max(dp[j], dp[j - value[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cash; i++)&#123; <span class="comment">//找到最大值</span></span><br><span class="line">            ans = max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/08/HDU-2602-Bone-Collector%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/08/HDU-2602-Bone-Collector%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%89/" class="post-title-link" itemprop="url">HDU 2602 Bone Collector（01背包）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-08 21:52:33" itemprop="dateCreated datePublished" datetime="2018-11-08T21:52:33+08:00">2018-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?</p>
<p> <img src="http://acm.hdu.edu.cn/data/images/C154-1003-1.jpg" alt="img"></p>
<p>Input</p>
<p>　　The first line contain a integer T , the number of cases.<br>　　Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.</p>
<p>Output</p>
<p>　　One integer per line representing the maximum of the total value (this number will be less than 231).</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 10</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出测试数量，每组测试给出骨骼数量n与背包体积v，之后跟随两行，第一行为骨骼的价值，第二行为骨骼的体积。要求输出背包所能装下骨骼的最大价值。</p>
<p>　　本题是标准的0 1背包问题。基本思路是动态规划，令dp[ j ]表示背包容量为j时能装下骨骼的最大价值。</p>
<p>　　对于第i块骨骼，有拿或不拿两种方案。</p>
<p>　　1、拿第 i 块骨骼，问题转化为计算背包容量为j - volume[ i ] 在前i - 1块骨骼中取得最大价值问题dp[ j ]的值为前i - 1块骨骼中取得的最大价值 + 第i块骨骼的价值。</p>
<p>　　2、不拿第i块骨骼，问题转化为背包容量为 j 时在前i - 1块骨骼中取得最大价值问题，dp[ j ]的值为前i - 1块骨骼中取得的最大价值。</p>
<p>　　可以写出状态转移方程：dp[ j ] = max(dp[ j ], dp[ j - volume[ i ] ] + value[ i ])</p>
<p>　　边界为拿前0块骨骼，最大价值为0，枚举所有骨骼，每次从最大背包容量开始逆序枚举便可获得答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> value[maxn], volume[maxn];</span><br><span class="line"><span class="comment">//value记录骨骼价值volume记录骨骼体积</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;  <span class="comment">//测试数量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, v;   <span class="comment">//n为骨骼数量 v背包容量</span></span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;v);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;value[i]); <span class="comment">//输入骨骼价值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;volume[i]);    <span class="comment">//输入骨骼体积</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));  <span class="comment">//初始化边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;    <span class="comment">//枚举骨骼</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = v; j &gt;= volume[i]; j--)&#123;  <span class="comment">//逆序枚举体积  </span></span><br><span class="line">                    dp[j] = max(dp[j], dp[j - volume[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v; i++)&#123;    <span class="comment">//找到最大值</span></span><br><span class="line">                ans = max(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/08/HDU-1159-Common-Subsequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/08/HDU-1159-Common-Subsequence/" class="post-title-link" itemprop="url">HDU 1159 Common Subsequence</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-08 19:03:47" itemprop="dateCreated datePublished" datetime="2018-11-08T19:03:47+08:00">2018-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, x ij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.Input<br>　　The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.<br>Output<br>　　For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.<br>Sample Input<br>abcfbc abfcab<br>programming contest<br>abcd mnp<br>Sample Output<br>　　4<br>　　2<br>　　0</p>
<p>解题思路：<br>　　本题有多组测试数据，每组数据给出两个字符串要求求出两个字符串的最长公共子序列长度如样例abcfbc abfcab 最长公共子串abfb长度为4。</p>
<p>　　用一个数组dp[ i ][ j ]记录以第一个字符串第 i 位结尾的字符串与以第二个字符串第 j 位为结尾的字符串的最长公共子串长度。根据动态规划思想对于每个dp[ i ][ j ]可以分成两种情况。</p>
<p>　　1、若 i j 所对应的字符相等，则该问题可以转化为求在第一个字符串中以 i 的前一个字符为结尾， 在第二个字符串中以 j 的前一个字符为结尾的最长公共子串 + 1。</p>
<p>　　2、若 i j 所对应的字符不等，则该问题转化为求在第一个字符串中以 i 的前一个字符为结尾， 在第二个字符串中以 j 为结尾的最长公共子串，与在第一个字符串中以 i 为结尾， 在第二个字符串中以 j 的前一个字符为结尾的最长公共子串两者的最大值问题。</p>
<p>动态转移方程：</p>
<script type="math/tex; mode=display">
1、dp[ i ][ j ] = d[ i - 1][ j - 1] + 1　　(str1[ i ] == str2[ j ]) \\

　　2、dp[ i ][ j ] = max(dp[ i - 1][ j ] , dp[ i ][ j - 1][ i ])　　(str1[ i ] != str2[ j ])</script><p>　　在运算中只要有一个数组结尾位下标为0那么无论谁与它的最长公共子串长度都为0，这便是边界条件，即所有的dp[][0],dp[0][]为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;  编译错误</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> tstr1, tstr2, str1, str2;    </span><br><span class="line"><span class="comment">//我们需要的字符串下标从1开始，所以先用tstr1 与 tstr2记录用户输入</span></span><br><span class="line"><span class="comment">//str1 str2为需要参与运算的字符串</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; tstr1)&#123;</span><br><span class="line">        str1 = str2 = <span class="string">""</span>;   <span class="comment">//每次计算开始前使str1 str2为空</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tstr2;</span><br><span class="line">        str1 += <span class="string">"*"</span>;    <span class="comment">//为了方便运算str1首位随便加一个字符</span></span><br><span class="line">        str1 += tstr1;  <span class="comment">//将先前记录的tstr1加入str1末尾</span></span><br><span class="line">        str2 += <span class="string">"0"</span>;    <span class="comment">//str2与str1操作相同</span></span><br><span class="line">        str2 += tstr2;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.size() - <span class="number">1</span>; <span class="comment">//获取str1有效位长度（第一位没用）</span></span><br><span class="line">        <span class="keyword">int</span> len2 = str2.size() - <span class="number">1</span>; <span class="comment">//获取str2有效位长度（第一位没用）</span></span><br><span class="line">        <span class="comment">//初始化dp数组的边界值</span></span><br><span class="line">        <span class="comment">//这里不能用memset，如果使用的话会超内存</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str1[i] != str2[j])&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[len1][len2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/07/HDU-2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87%E9%81%87%E9%9A%BE%E5%90%8C%E8%83%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/07/HDU-2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87%E9%81%87%E9%9A%BE%E5%90%8C%E8%83%9E/" class="post-title-link" itemprop="url">HDU 2191 悼念512汶川大地震遇难同胞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-07 23:50:28" itemprop="dateCreated datePublished" datetime="2018-11-07T23:50:28+08:00">2018-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>急！灾区的食物依然短缺！<br>　　为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。<br>请问：你用有限的资金最多能采购多少公斤粮食呢？ </p>
<p>后记：<br>　　人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。<br>　　月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——<br>　　感谢父母，他们给予我们生命，抚养我们成人；<br>　　感谢老师，他们授给我们知识，教我们做人<br>　　感谢朋友，他们让我们感受到世界的温暖；<br>　　感谢对手，他们令我们不断进取、努力。<br>　　同样，我们也要感谢痛苦与艰辛带给我们的财富～ </p>
<p> <img src="http://acm.hdu.edu.cn/data/images/C132-1006-2.JPG" alt="img"> </p>
<p>Input</p>
<p>　　输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。Output对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8 2</span><br><span class="line">2 100 4</span><br><span class="line">4 100 2</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出测试数量，每组测试给出现有资金数n，大米种类m，之后跟随m行为每种大米的具体信息，包括大米价格，每袋重量，库存袋数。只能购买整袋，可以购买的最大重量。</p>
<p>　　本题是标准的多重背包问题，背包的容量位资金数量，背包内容物价值为大米的重量，本题数据范围比较小，可以直接将多重背包问题转化为0 - 1背包问题（无需优化即可AC）。</p>
<p>　　基本思路便是将每种大米拆分为单袋大米。令dp[i][j]表示如果手中资金为 j 则恰好购买前i袋大米能获得最大重量。</p>
<p>　　对于第i袋大米，有买或不买两种选择方案。</p>
<p>　　1、买第i袋大米，问题转化为求手中资金为（ j - 第 i 件大米价格 ）在之前i - 1袋大米中购买最大重量的问题。</p>
<p>　　2、不买第i袋大米，问题转化为手中资金为 j 时在之前i - 1袋大米中购买最大重量的问题。</p>
<p>　　只需要在这两种情况中选择重量最大的情况即可。</p>
<p>　　状态转移方程：dp[ i ][ j ] = max( dp[ i - 1 ][ j ] , dp[ i - 1 ][ j - price[ i ] ] + weight[ i ] )可以发现每个新的i都只用了dp[ i - 1 ]的 第0 ~ n位，dp[i - 1]之前的全部没用了，索性这里只开一个一维数组dp[j]每次取dp[0] ~ dp[n]的值运算并覆盖先前的值。</p>
<p>　　新的状态转移方程：dp[ j ] = max(dp[ j ], dp[ j -  price[[ i ] ] + weight[[ i ])</p>
<p>　　初始话边界状态为购买前0袋大米，重量为0，之后枚举所有大米种类，并逆序枚举资金之后寻找其最大值便可以得到答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> * <span class="number">21</span>;</span><br><span class="line"><span class="keyword">int</span> price[maxn];</span><br><span class="line"><span class="keyword">int</span> weight[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;    <span class="comment">//d为测试组数 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d) != EOF)&#123;</span><br><span class="line">        <span class="keyword">while</span>(d--)&#123;</span><br><span class="line">            <span class="keyword">int</span> n, m;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);    <span class="comment">//输入资金数量与大米种类 </span></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> mey, wit, num;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;mey, &amp;wit, &amp;num);</span><br><span class="line">                <span class="comment">//输入每种大米的价格质量库存 </span></span><br><span class="line">                <span class="keyword">while</span>(num--)&#123;    <span class="comment">//拆分大米为单袋 </span></span><br><span class="line">                    weight[cnt] = wit;</span><br><span class="line">                    price[cnt] = mey;</span><br><span class="line">                    cnt++;    <span class="comment">//j记录总袋数 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));<span class="comment">//初始化所有情况最大重量为0 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;    <span class="comment">//遍历所有大米 </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= price[i]; j--)&#123;    <span class="comment">//逆序遍历所有资金的情况 </span></span><br><span class="line">                    dp[j] = max(dp[j], dp[j - price[i]] + weight[i]);</span><br><span class="line">                    <span class="comment">//状态转移方程 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                ans = max(ans, dp[i]);    <span class="comment">//找到最大值 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/06/HDU-1087-Super-Jumping-Jumping-Jumping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/06/HDU-1087-Super-Jumping-Jumping-Jumping/" class="post-title-link" itemprop="url">HDU 1087 Super Jumping! Jumping! Jumping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-06 23:19:32" itemprop="dateCreated datePublished" datetime="2018-11-06T23:19:32+08:00">2018-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>Nowadays, a kind of chess game called “Super Jumping! Jumping! Jumping!” is very popular in HDU. Maybe you are a good boy, and know little about this game, so I introduce it to you now. </p>
<p><img src="http://acm.hdu.edu.cn/data/images/1087-1.jpg" alt="img"> </p>
<p>　　The game can be played by two or more than two players. It consists of a chessboard（棋盘）and some chessmen（棋子）, and all chessmen are marked by a positive integer or “start” or “end”. The player starts from start-point and must jumps into end-point finally. In the course of jumping, the player will visit the chessmen in the path, but everyone must jumps from one chessman to another absolutely bigger (you can assume start-point is a minimum and end-point is a maximum.). And all players cannot go backwards. One jumping can go from a chessman to next, also can go across many chessmen, and even you can straightly get to end-point from start-point. Of course you get zero point in this situation. A player is a winner if and only if he can get a bigger score according to his jumping solution. Note that your score comes from the sum of value on the chessmen in you jumping path.<br>Your task is to output the maximum value according to the given chessmen list. </p>
<p>Input</p>
<p>　　Input contains multiple test cases. Each test case is described in a line as follow:<br>　　N value_1 value_2 …value_N<br>　　It is guarantied that N is not more than 1000 and all value_i are in the range of 32-int.<br>　　A test case starting with 0 terminates the input and this test case is not to be processed.<br>Output</p>
<p>　　For each case, print the maximum according to rules, and one line one case.<br>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 1 3 2</span><br><span class="line">4 1 2 3 4</span><br><span class="line">4 3 3 2 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题有多组数据，每组数据给出棋子数量，棋子权值，玩家从起始位置上跳到棋子上，每次只能向后跳，且只能跳到比当前棋子权值大的棋子上。要求输出玩家跳过棋子的权值之和的最大值。</p>
<p>　　这其实就是一个给定数组求最大升序子串权值和（最大升序子串在原数组中不一定连续）的问题。可以用数组dp保存以每个点为结尾的数组的最大升序子串权值和（dp[i]为以原数组中以第i个数为结尾的最大升序子串权值和）这样对每个i都会出现两种情况。</p>
<p>　　1、第 i 号元素之前所有元素的权值都比第 i 号元素大，那么以第 i 号元素为结尾的最大升序子串权值和就为第 i 号元素自己的权值。</p>
<p>　　2、第 i 号元素之前存在比其权值小的元素（设其为 j ）则第 i 号元素的最大升序子串权值和为第 j 号元素的最大升序子串权值和再加上第 i 号元素的权值。</p>
<p>知道这两种情况后便可以写出动态规划状态转移方程 dp[i] = max{1, dp[j] + 1}  (j : 1 ~ i - 1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> arrays[maxn];   <span class="comment">//棋子数组</span></span><br><span class="line"><span class="keyword">int</span> dp[maxn];   <span class="comment">//以每个棋子为结尾的最大升序子串权值和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">//输入棋子数量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="comment">//棋子数为0结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arrays[i]);    <span class="comment">//输入棋子权值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;   <span class="comment">//ans记录整个数组最大升序子串权值和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = arrays[i];  </span><br><span class="line">            <span class="comment">//初始化第 i 号元素为结尾的最大升序子串权值和就为第 i 号元素自己的权值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;  j &lt; i; j++)&#123;    <span class="comment">//遍历起始位置到i</span></span><br><span class="line">                <span class="keyword">if</span>(arrays[i] &gt; arrays[j] &amp;&amp; dp[j] + arrays[i] &gt; dp[i])&#123;</span><br><span class="line">                <span class="comment">//如果找到j权值小于i且以j元素结尾的最大升序子串权值和 加上i的权值 大于当前记录的权值和</span></span><br><span class="line">                    dp[i] = dp[j] + arrays[i];<span class="comment">//更新当前记录</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans, dp[i]);  <span class="comment">//始终保持ans为dp中最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/04/HDU-1710-Binary-Tree-Traversals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/04/HDU-1710-Binary-Tree-Traversals/" class="post-title-link" itemprop="url">HDU 1710 Binary Tree Traversals</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-04 22:17:26" itemprop="dateCreated datePublished" datetime="2018-11-04T22:17:26+08:00">2018-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>A binary tree is a finite set of vertices that is either empty or consists of a root r and two disjoint binary trees called the left and right subtrees. There are three most important ways in which the vertices of a binary tree can be systematically traversed or ordered. They are preorder, inorder and postorder. Let T be a binary tree with root r and subtrees T1,T2. </p>
<p>　　In a preorder traversal of the vertices of T, we visit the root r followed by visiting the vertices of T1 in preorder, then the vertices of T2 in preorder. </p>
<p>　　In an inorder traversal of the vertices of T, we visit the vertices of T1 in inorder, then the root r, followed by the vertices of T2 in inorder. </p>
<p>　　In a postorder traversal of the vertices of T, we visit the vertices of T1 in postorder, then the vertices of T2 in postorder and finally we visit r. </p>
<p>　　Now you are given the preorder sequence and inorder sequence of a certain binary tree. Try to find out its postorder sequence.<br> <img src="http://acm.hdu.edu.cn/data/images/C57-1005-1.jpg" alt="img"> </p>
<p>Input</p>
<p>　　The input contains several test cases. The first line of each test case contains a single integer n (1&lt;=n&lt;=1000), the number of vertices of the binary tree. Followed by two lines, respectively indicating the preorder sequence and inorder sequence. You can assume they are always correspond to a exclusive binary tree.<br>Output</p>
<p>　　For each test case print a single line specifying the corresponding postorder sequence.<br>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1 2 4 7 3 5 8 9 6</span><br><span class="line">4 7 2 1 8 5 9 3 6</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 4 2 8 9 5 6 3 1</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给二叉树的结点数量，之后第一行给出二叉树的先序遍历，第二行给出二叉树的中序遍历，根据前序遍历的性质，先序遍历的首位为根结点，以该点为根结点建树，从中序遍历中寻找该点，假设找到新的位置为k，则从中序遍历首位到k-1，为左子树中序遍历的范围，从k+1到中序遍历末位为右子树中序范围，，这样我们就可以得知左子树长度，右子树长度，进而获得左子树与右子树的前序遍历。对获得的左子树右子树的前序遍历中序遍历进行同样的操作，便可以建立该树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> typeData;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];  <span class="comment">//记录前序遍历</span></span><br><span class="line"><span class="keyword">int</span> in[maxn];   <span class="comment">//记录中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    typeData data; </span><br><span class="line">    node* leftChild;</span><br><span class="line">    node* rightChild;</span><br><span class="line">    node()&#123;</span><br><span class="line">        leftChild = <span class="literal">NULL</span>;</span><br><span class="line">        rightChild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node *root, node *flag)</span></span>&#123; <span class="comment">//输出后序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postorder(root-&gt;leftChild, flag);</span><br><span class="line">    postorder(root-&gt;rightChild, flag);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">if</span>(root != flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入先序遍历起始位置，中序遍历起始位置</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR) <span class="comment">//如果前序遍历中没有数值返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node* root = <span class="keyword">new</span> node();    <span class="comment">//建立新结点，其权值为，当前先序遍历的首位，即当前树根结点</span></span><br><span class="line">    root-&gt;data = pre[preL];</span><br><span class="line">    <span class="keyword">int</span> k;  <span class="comment">//k记录根结点在中序遍历中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(k = inL; k &lt; inR; k++)&#123; <span class="comment">//在中序遍历中寻找根结点位置</span></span><br><span class="line">        <span class="keyword">if</span>(pre[preL] == in[k])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inL;  <span class="comment">//计算左子树长度</span></span><br><span class="line">    root-&gt;leftChild = create(preL + <span class="number">1</span>, preL + numLeft, inL, k - <span class="number">1</span>); <span class="comment">//递归建立左子树</span></span><br><span class="line">    <span class="comment">//先序遍历中左子树区域为根结点的下一位到左子树起始点加左子树长度</span></span><br><span class="line">    <span class="comment">//中序遍历中左子树区域为中序遍历首位到根结点之前</span></span><br><span class="line">    root-&gt;rightChild = create(preL + numLeft + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);    <span class="comment">//递归建立右子树</span></span><br><span class="line">    <span class="comment">//先序遍历中右子树区域为左子树末尾的下一位到先序遍历末位</span></span><br><span class="line">    <span class="comment">//中序遍历中右子树区域为根结点后一位到中序遍历末位</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);   <span class="comment">//输入先序遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//输入中序遍历</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        node* root = create(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);    <span class="comment">//建树</span></span><br><span class="line">        postorder(root, root);  <span class="comment">//输出后序遍历</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/03/POJ3253-Fence-Repair/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/03/POJ3253-Fence-Repair/" class="post-title-link" itemprop="url">POJ3253-Fence Repair</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-03 21:26:01" itemprop="dateCreated datePublished" datetime="2018-11-03T21:26:01+08:00">2018-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs <em>N</em> (1 ≤ <em>N</em> ≤ 20,000) planks of wood, each having some integer length <em>Li</em> (1 ≤ <em>Li</em> ≤ 50,000) units. He then purchases a single long board just long enough to saw into the <em>N</em> planks (i.e., whose length is the sum of the lengths <em>Li</em>). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.</p>
<p>　　FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.</p>
<p>　　Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the <em>N</em>-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.</p>
<p>　　Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the <em>N</em> planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.</p>
<p>Input</p>
<p>　　Line 1: One integer <em>N</em>, the number of planks<br>　　Lines 2.. <em>N</em>+1: Each line contains a single integer describing the length of a needed plank</p>
<p>Output</p>
<p>　　Line 1: One integer: the minimum amount of money he must spend to make <em>N</em>-1 cuts</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34</span><br></pre></td></tr></table></figure>
<p>Hint</p>
<p>　　He wants to cut a board of length 21 into pieces of lengths 8, 5, and 8.<br>　　The original board measures 8+5+8=21. The first cut will cost 21, and should be used to cut the board into pieces measuring 13 and 8. The second cut will cost 13, and should be used to cut the 13 into 8 and 5. This would cost 21+13=34. If the 21 was cut into 16 and 5 instead, the second cut would cost 16 for a total of 37 (which is more than 34).</p>
<p>解题思路：<br>　　本题意思是一名农民需要在邪恶的资本家那里从一块足够长度的木板上锯下一些给定长度的木板，每锯下一块就要支付和被锯的原木板长度相同的钱财，题目每组测试给定一个数组n为需要的木板数量，之后n行每行一个数为木板的长度。既然初始木板长度足够，那我们便可将它视为一块正合适的木板，从这块木板正好可以锯下所以需要的长度零浪费，既然想要耗费最少的钱财，我们可以将切割问题转化为拼接问题，我们在所有需要锯下的长度中挑选两个最小的长度，将它们拼接成一块，可以得知锯开我们刚刚拼接的这一块木板需要考费的钱财就等于它的长度，记录下这个数字，之后从我们需要没有锯的木板中以刚刚拼接好的这一块代替拼接它的两块木板，在选两块最小的拼接，以此类推，我们最终可以把所有需要的长度拼成一块木板，就是我们要锯的初始木板，锯开它所耗费的钱财为我们在拼接过程中记录的数字之和。这就完美的转化为一个哈夫曼树问题。</p>
<p>　　我们用优先队列来记录输入的所有需要锯下木板的长度，每次取出两个最小的进行加和成为一段新长度，将这段长度数值加入需要耗费的钱财后，入队这段新长度，重复操作直到只剩一块木板。</p>
<p>样例解析:</p>
<p>　　3　　//木板数量</p>
<p>　　8　　//长度1</p>
<p>　　5　　//长度2</p>
<p>　　8　　//长度3</p>
<p>　　入队结束后队中有 8 8 5 ， 5出队 8出队，拼接为13，耗费13钱财，13入队。 队中现有 13 8，8出队，13出队，拼接为21，耗费现为之前的13 + 21 = 34钱财，21入队，队中只剩一块木板，输出钱财为34。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// bits/stdc++.h编译错误</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; value;</span><br><span class="line"><span class="comment">//优先队列设定数值小的先出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;  <span class="comment">//ans记录耗费的钱财</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;  <span class="comment">//输入木板数量</span></span><br><span class="line">        ans = <span class="number">0</span>;    <span class="comment">//没有切割是耗费钱财为0</span></span><br><span class="line">        <span class="keyword">while</span>(!value.empty())&#123;  <span class="comment">//清空队列</span></span><br><span class="line">            value.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//输入并入队所有长度</span></span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            value.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(value.size() &gt; <span class="number">1</span>)&#123;    <span class="comment">//如果队中所剩木板数量大于则1进行拼接</span></span><br><span class="line">            <span class="keyword">int</span> len1 = value.top();</span><br><span class="line">            value.pop();</span><br><span class="line">            <span class="keyword">int</span> len2 = value.top();</span><br><span class="line">            value.pop();</span><br><span class="line">            <span class="comment">//出队两个最小长度进行拼接操作</span></span><br><span class="line">            ans += len1 + len2; <span class="comment">//记录消耗的钱财</span></span><br><span class="line">            value.push(len2 + len1);    <span class="comment">//新长度入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);  <span class="comment">//输出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/01/PTA-Advanced-Level-1066-Root-of-AVL-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/01/PTA-Advanced-Level-1066-Root-of-AVL-Tree/" class="post-title-link" itemprop="url">PTA (Advanced Level) 1066 Root of AVL Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-01 23:18:37" itemprop="dateCreated datePublished" datetime="2018-11-01T23:18:37+08:00">2018-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<p><img src="https://images.ptausercontent.com/31" alt="img"><img src="https://images.ptausercontent.com/32" alt="img"></p>
<p><img src="https://images.ptausercontent.com/33" alt="img"> <img src="https://images.ptausercontent.com/34" alt="img"></p>
<p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤) which is the total number of keys to be inserted. Then Ndistinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure>
<p>AVL树作用：<br>　　对于正常二叉搜索树建立过程，以第一个结点为根结点，若输入的结点权值大于第一个结点则插入右子树，小于第一个结点则插入左子树。若遇到出入数据为有序的情况，普通二叉搜索树就会建立一个长链式的树，其查询复杂度就会达到O(n)，如以{1， 2， 3， 4 ，5 ，6， 7， 8， 9， 10}建立的二叉搜索树：</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201811/1447131-20181102213013498-1251399768.png" alt="img"></p>
<p>若要保持查询复杂度为O(logn)则需要建立AVL树，只需在插入过程中通过左旋右旋操作保证叶子结点的最大高度差不超过1，以{1， 2， 3， 4 ，5 ，6， 7， 8， 9， 10}建立AVL树：</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201811/1447131-20181102213306307-2093137586.png" alt="img"><br>解题思路：<br>　　AVL树模板题要求按输入建立AVL树即在二叉搜索树叶子结点最大高度差大于等于二的时候进行左旋或右旋进行结构优化使结点深度保持在O(logn)的级别,输出AVL树根结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> dataType;</span><br><span class="line"><span class="built_in">vector</span>&lt;dataType&gt; data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    dataType data;</span><br><span class="line">    <span class="keyword">int</span> height; <span class="comment">//AVL树结点比起普通二叉搜索树需要记录height</span></span><br><span class="line">    node *leftChild;</span><br><span class="line">    node * rightChild;</span><br><span class="line">    node()&#123;</span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">        leftChild = <span class="literal">NULL</span>;</span><br><span class="line">        rightChild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node *root)</span></span>&#123;  <span class="comment">//获取高度</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node *root)</span></span>&#123;   <span class="comment">//获取树的叶子结点高度差左高为正右高为负</span></span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;leftChild) - getHeight(root-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateHeight</span><span class="params">(node *root)</span></span>&#123;   <span class="comment">//更新高度</span></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;leftChild),getHeight(root-&gt;rightChild)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftRotation</span><span class="params">(node *&amp;root)</span></span>&#123; <span class="comment">//左旋</span></span><br><span class="line">    node *temp = root-&gt;rightChild;      <span class="comment">//root指向先前根结点temp指向右子树根结点</span></span><br><span class="line">    root-&gt;rightChild = temp-&gt;leftChild; <span class="comment">//temp指向根结点的右子树，所以其所有结点都大于根结点</span></span><br><span class="line">    <span class="comment">//由于在左旋中需要使temp成为新的根结点，所以将root右子树指向temp左子树，再让temp左子树指向root</span></span><br><span class="line">    temp-&gt;leftChild = root;</span><br><span class="line">    <span class="comment">//更新root与temp的树高</span></span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;    <span class="comment">//temp成为新的根结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightRotation</span><span class="params">(node *&amp;root)</span></span>&#123;    <span class="comment">//右旋思路同左旋</span></span><br><span class="line">    node *temp = root-&gt;leftChild;</span><br><span class="line">    root-&gt;leftChild = temp-&gt;rightChild;</span><br><span class="line">    temp-&gt;rightChild = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertAVLTree</span><span class="params">(node *&amp;root, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//插入结点</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;   <span class="comment">//找到插入位置</span></span><br><span class="line">        root = <span class="keyword">new</span> node();</span><br><span class="line">        root-&gt;data = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == x)&#123;    <span class="comment">//结点已存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; x)&#123;   <span class="comment">//要插入的数据比根结点权值小</span></span><br><span class="line">        insertAVLTree(root-&gt;leftChild, x);  <span class="comment">//插入左子树</span></span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">2</span>)&#123;　　<span class="comment">//插入左子树时只可能出现左子树比右子树高的情况</span></span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;leftChild) == <span class="number">1</span>)&#123;　　<span class="comment">//若左子树的左子树较高直接右旋</span></span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;leftChild) == <span class="number">-1</span>)&#123;　　<span class="comment">//若左子树中右子树较高则将其通过右旋转化为左子树高的情况　　种情况详见下图</span></span><br><span class="line">                leftRotation(root-&gt;leftChild);</span><br><span class="line">                rightRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &lt; x)&#123;   <span class="comment">//要插入的数据比根结点权值大</span></span><br><span class="line">        insertAVLTree(root-&gt;rightChild, x); <span class="comment">//插入右子树</span></span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;rightChild) == <span class="number">-1</span>)&#123;</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rightChild) == <span class="number">1</span>)&#123;</span><br><span class="line">                rightRotation(root-&gt;rightChild);</span><br><span class="line">                leftRotation(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node *<span class="title">createAVLTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;dataType&gt;::iterator it = data.begin(); it != data.end(); it++)&#123;</span><br><span class="line">        insertAVLTree(root, *it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void preorder(node *root)&#123;</span></span><br><span class="line"><span class="comment">    if(root == NULL)</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; root -&gt; data &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">    preorder(root -&gt; leftChild);</span></span><br><span class="line"><span class="comment">    preorder(root -&gt; rightChild);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        data.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dataType temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            data.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        node *root = createAVLTree();</span><br><span class="line">        <span class="comment">//preorder(root);</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左子树的左子树较高</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201811/1447131-20181102214830714-561437459.png" alt="img"></p>
<p>左子树的右子树较高</p>
<p> <img src="https://img2018.cnblogs.com/blog/1447131/201811/1447131-20181102215548311-750974049.png" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SUVVM"
      src="/images/ortrait.jpg">
  <p class="site-author-name" itemprop="name">SUVVM</p>
  <div class="site-description" itemprop="description">SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">157</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">85</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suvvm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suvvm" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/suvvm@foxmail.com" title="E-Mail → suvvm@foxmail.com"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SUVVM</span>
	<a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">鲁ICP备19040043号-2</a>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  

</body>
</html>
