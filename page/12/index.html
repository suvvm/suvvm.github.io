<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/ortrait.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/ortrait.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.suvvm.work","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:type" content="website">
<meta property="og:title" content="SUVVM">
<meta property="og:url" content="https://www.suvvm.work/page/12/index.html">
<meta property="og:site_name" content="SUVVM">
<meta property="og:description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SUVVM">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.suvvm.work/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SUVVM</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e5190116d64be66cac29daef18c94ac0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SUVVM</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">呜嗷SUVVM</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/08/HDU-1074-Doing-Homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/08/HDU-1074-Doing-Homework/" class="post-title-link" itemprop="url">HDU 1074 Doing Homework</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-08 16:07:30" itemprop="dateCreated datePublished" datetime="2018-12-08T16:07:30+08:00">2018-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　Ignatius has just come back school from the 30th ACM/ICPC. Now he has a lot of homework to do. Every teacher gives him a deadline of handing in the homework. If Ignatius hands in the homework after the deadline, the teacher will reduce his score of the final test, 1 day for 1 point. And as you know, doing homework always takes a long time. So Ignatius wants you to help him to arrange the order of doing homework to minimize the reduced score.</p>
<p>Input</p>
<p>　　The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case start with a positive integer N(1&lt;=N&lt;=15) which indicate the number of homework. Then N lines follow. Each line contains a string S(the subject’s name, each string will at most has 100 characters) and two integers D(the deadline of the subject), C(how many days will it take Ignatius to finish this subject’s homework). </p>
<p>　　Note: All the subject names are given in the alphabet increasing order. So you may process the problem much easier.<br>Output</p>
<p>　　For each test case, you should output the smallest total reduced score, then give out the order of the subjects, one subject in a line. If there are more than one orders, you should output the alphabet smallest one.<br>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">Computer 3 3</span><br><span class="line">English 20 1</span><br><span class="line">Math 3 2</span><br><span class="line">3</span><br><span class="line">Computer 3 3</span><br><span class="line">English 6 3</span><br><span class="line">Math 6 3</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">Computer</span><br><span class="line">Math</span><br><span class="line">English</span><br><span class="line">3</span><br><span class="line">Computer</span><br><span class="line">English</span><br><span class="line">Math</span><br></pre></td></tr></table></figure>
<p>Hint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In the second test case, both Computer-&gt;English-&gt;Math and Computer-&gt;Math-&gt;English leads to reduce 3 points, but the </span><br><span class="line">word &quot;English&quot; appears earlier than the word &quot;Math&quot;, so we choose the first order. That is so-called alphabet order.</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出多组数据，每组数据给出一个整数t为测试数量，给出一个整数n代表项目数量，之后n行跟随每行给出一个项目信息，包括项目名name 最晚上交时间deadline 完成该项目需要的时间costDays。每个项目只要晚于deadline所规定的时间上交，每晚一天扣一分。对于每组测试要求输出最少的扣分数之后按提交顺序输出项目名。</p>
<p>　　本题限定了项目的数量n &lt;= 15。假设有A、B、C、D四个项目，每个项目有已上交和未上交两种状态，我们可以用一个四位二进制表示这四个项目的所有状态，例如0001表示A上交其他所有项目未上交，0011表示AB项目上交CD项目未上交，1111表示所有项目都上交，以此类推，若想n取到最大15，需要15位2进制数表示所有情况，表示15个项目全部提交的二进制数最大，为111111111111111，其所代表的10进制整数为32767，其大小远小于int上限，那么我们只需要令maxn = 1 &lt;&lt; 15 即32768 就可以表示本题中所有可能出现的状态，</p>
<p>　　既然所有状态都已经可以表示出来，现在就可以考虑一下如何获得状态，例如AB项目上交CD项目未上交的状态0011，可以由A上交其他都没上交的状态0001提交B（0010）获得，也可以由状态B上交其他都没上交的状态0010提交A（0001）获得，那么我们如果想要算出获得当前状态的最小扣分值，只需要遍历所有只需一次提交便可以得到当前状态的状态（以后称为前状态）找到前状态的扣分加上本次提交项目所需的扣分的最小值即可，这就是本题的解题思想——状态压缩dp。</p>
<p>　　状态压缩dp也是dp，这里用一个结构体subject型的数组Subject[16]储存所有项目信息subject中包括项目名，最晚提交日期与消耗时间；用一个结构体nodeInformation型的数组dp[maxn]保存每个状态的信息，nodeInformation包括现在状态已经使用的天数，现在状态的前状态，前状态到现在状态所需提交的项目，现在状态的最少扣分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subject</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">//项目名</span></span><br><span class="line">    <span class="keyword">int</span> deadline;   <span class="comment">//最后期限</span></span><br><span class="line">    <span class="keyword">int</span> costDays;   <span class="comment">//耗费时间</span></span><br><span class="line">&#125;Subject[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodeInformation</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> costNow;    <span class="comment">//现在状态做项目已经使用的天数</span></span><br><span class="line">    <span class="keyword">int</span> now;    <span class="comment">//前状态到现在状态所需提交的项目</span></span><br><span class="line">    <span class="keyword">int</span> pre;    <span class="comment">//现在状态的前状态</span></span><br><span class="line">    <span class="keyword">int</span> subScore;   <span class="comment">//现在状态的最少扣分</span></span><br><span class="line">&#125;dp[maxn];</span><br></pre></td></tr></table></figure>
<p> 　　之后遍历所有状态，开始时假设现在状态疯狂扣分扣无限分，之后遍历所有项目作为前项目到现在状态所提交的项目，每次遍历看看能不能减少现在状态的扣分，能的话就跟新dp数组信息。遍历结束后用一个栈后进先出的特性从所有项目都提交的状态向前寻找前状态并入栈。之后出栈输出项目名即可获得提交的顺序。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lastSubNow = endn;  <span class="comment">//全部提交状态</span></span><br><span class="line"><span class="keyword">while</span>(lastSubNow)&#123;  <span class="comment">//到全部未提交为止</span></span><br><span class="line">    subName.push(dp[lastSubNow].now);   <span class="comment">//入站前状态</span></span><br><span class="line">    lastSubNow = dp[lastSubNow].pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!subName.empty())&#123;    <span class="comment">//输出提交顺序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Subject[subName.top()].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    subName.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> AC代码 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subject</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;    <span class="comment">//项目名</span></span><br><span class="line">    <span class="keyword">int</span> deadline;   <span class="comment">//最后期限</span></span><br><span class="line">    <span class="keyword">int</span> costDays;   <span class="comment">//耗费时间</span></span><br><span class="line">&#125;Subject[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodeInformation</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> costNow;    <span class="comment">//现在状态做项目已经使用的天数</span></span><br><span class="line">    <span class="keyword">int</span> now;    <span class="comment">//前状态到现在状态所需提交的项目</span></span><br><span class="line">    <span class="keyword">int</span> pre;    <span class="comment">//现在状态的前状态</span></span><br><span class="line">    <span class="keyword">int</span> subScore;   <span class="comment">//现在状态的最少扣分</span></span><br><span class="line">&#125;dp[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; subName; <span class="comment">//记录路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;  <span class="comment">//测试数量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t) != EOF)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);    <span class="comment">//输入项目数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//输入每个项目</span></span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; Subject[i].name &gt;&gt; Subject[i].deadline &gt;&gt; Subject[i].costDays;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> endn = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;  <span class="comment">//所有项目都提交</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= endn; i++)&#123;   <span class="comment">//i所对应的2进制数代表每一个项目的完成情况，即i对应的二进制就是当前状态</span></span><br><span class="line">                dp[i].subScore = inf;   <span class="comment">//初始化完成这种情况疯狂扣分减无限分</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                    <span class="comment">//遍历所有项目，j为当前选择作为前状态提交项目的项目</span></span><br><span class="line">                    <span class="keyword">int</span> nowSubj = <span class="number">1</span> &lt;&lt; j;   <span class="comment">//nowSubj代表只提交下标为j的项目的状态</span></span><br><span class="line">                    <span class="keyword">if</span>(i &amp; nowSubj)&#123;    <span class="comment">//判断i情况中下标为j的项目是否提交</span></span><br><span class="line">                        <span class="comment">//若已经提交进行如下操作</span></span><br><span class="line">                        <span class="keyword">int</span> past = i - nowSubj;<span class="comment">//把i状态的中代表j号项目的状态改为没有提交，就可以获得i状态提交j的前状态past</span></span><br><span class="line">                        <span class="keyword">int</span> subScorej;</span><br><span class="line">                        <span class="comment">//subScorej代表past状态提交j号项目的扣分</span></span><br><span class="line">                        <span class="comment">//它就等于past状态已经消耗的天数加上j项目需要消耗的天数减去j号项目的要求的最晚提交日期。</span></span><br><span class="line">                        subScorej = dp[past].costNow + Subject[j].costDays - Subject[j].deadline;</span><br><span class="line">                        <span class="keyword">if</span>(subScorej &lt; <span class="number">0</span>)&#123;  <span class="comment">//扣分不可能小于0，如果小于0就证明时间充足，扣分为0</span></span><br><span class="line">                            subScorej = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(subScorej + dp[past].subScore &lt; dp[i].subScore)&#123; <span class="comment">//如果从past状态到现在状态可以使i状态当前的扣分减小</span></span><br><span class="line">                            dp[i].subScore = subScorej + dp[past].subScore;</span><br><span class="line">                            <span class="comment">//更新i状态的扣分</span></span><br><span class="line">                            dp[i].costNow = dp[past].costNow + Subject[j].costDays;</span><br><span class="line">                            <span class="comment">//记录以past为前状态的i状态消耗的天数</span></span><br><span class="line">                            dp[i].now = j;</span><br><span class="line">                            <span class="comment">//前状态past到现在状态i并使其扣分最少所提交的项目为j项目</span></span><br><span class="line">                            dp[i].pre = past;</span><br><span class="line">                            <span class="comment">//记录i的前状态为past</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[endn].subScore);</span><br><span class="line">            <span class="comment">//输出提交全部项目的最少扣分（所有的项目都提交状态最少扣分）</span></span><br><span class="line">            <span class="keyword">int</span> lastSubNow = endn;  <span class="comment">//全部提交状态</span></span><br><span class="line">            <span class="keyword">while</span>(lastSubNow)&#123;  <span class="comment">//到全部未提交为止</span></span><br><span class="line">                subName.push(dp[lastSubNow].now);   <span class="comment">//入站前状态</span></span><br><span class="line">                lastSubNow = dp[lastSubNow].pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!subName.empty())&#123;    <span class="comment">//输出提交顺序</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; Subject[subName.top()].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                subName.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/07/HDU-1029-Ignatius-and-the-Princess-IV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/07/HDU-1029-Ignatius-and-the-Princess-IV/" class="post-title-link" itemprop="url">HDU 1029 Ignatius and the Princess IV</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-07 15:18:04" itemprop="dateCreated datePublished" datetime="2018-12-07T15:18:04+08:00">2018-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　“OK, you are not too bad, em… But you can never pass the next test.” feng5166 says. </p>
<p>　　“I will tell you an odd number N, and then N integers. There will be a special integer among them, you have to tell me which integer is the special one after I tell you all the integers.” feng5166 says. </p>
<p>　　“But what is the characteristic of the special integer?” Ignatius asks. </p>
<p>　　“The integer will appear at least (N+1)/2 times. If you can’t find the right integer, I will kill the Princess, and you will be my dinner, too. Hahahaha…..” feng5166 says. </p>
<p>　　Can you find the special integer for Ignatius? </p>
<p>Input</p>
<p>　　The input contains several test cases. Each test case contains two lines. The first line consists of an odd integer N(1&lt;=N&lt;=999999) which indicate the number of the integers feng5166 will tell our hero. The second line contains the N integers. The input is terminated by the end of file.<br>Output</p>
<p>　　For each test case, you have to output only one line which contains the special number you have found.<br>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 2 3 3</span><br><span class="line">11</span><br><span class="line">1 1 1 1 1 5 5 5 5 5 5</span><br><span class="line">7</span><br><span class="line">1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出多组数据每组数据给出一个数n，下一行给出n个数，要求找出出现次数超过一半的数字。</p>
<p>试想一个数的数量超过总数的一半其出现次数一定是所有的数中出现最多的那个数，我们就可以在输入时用一个ans记录当前出现次数最多的数，cnt记录ans比其他数的出现次数多多少。每当cnt等于0时便说明在当前输入已经输入完的数中ans所代表的数出现的次数不足一半，则cnt重新记录一个数，输入结束后获得的ans即为所取数。</p>
<p>　　AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans, cnt = <span class="number">0</span>, temp;</span><br><span class="line">        <span class="comment">//ans记录当前出现次数最多的数，cnt记录ans比其他数的出现次数多多少</span></span><br><span class="line">        <span class="comment">//temp记录当前输入的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;<span class="comment">//cnt等于0重新记录一个数</span></span><br><span class="line">                ans = temp;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans == temp)&#123;</span><br><span class="line">                cnt++;  <span class="comment">//输入的数等于ans cnt++</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);    <span class="comment">//输出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/07/HDU-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/07/HDU-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90/" class="post-title-link" itemprop="url">HDU 1495 非常可乐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-07 14:57:01" itemprop="dateCreated datePublished" datetime="2018-12-07T14:57:01+08:00">2018-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。</p>
<p>Input</p>
<p>　　三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。Output如果能平分的话请输出最少要倒的次数，否则输出”NO”。</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7 4 3</span><br><span class="line">4 1 3</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出多组数据，每组数据包括3个整数可乐体积s，第一个杯子容量n， 另一个杯子容量m。s == n + m 要求输出想要平分可乐最少倒的次数。</p>
<p>　　这里本题使用BFS，广搜的基本思路是，用一个队列，搜索下一步可以抵达的所有状态加入队列，直到符合条件或队列为空为止。</p>
<p>　　记录初始状态为可乐瓶中可乐体积为s， 两个杯中的可乐体积都为0， 当前状态若想抵达下一个状态有s向n倒水、s向m倒水、n向s倒水、n向m倒水、m向s倒水、m向n倒水这6种方法，执行完这6种方法后得到的6种状态即为当前状态的下一状态。将当前状态出队寻找下一状态，取所有合法状态加入队列，继续向下搜索即可。</p>
<p>　　结束条件，由于s == n + m所以若想将可乐分为两相等份，最终的情况一定是，可乐瓶与较大的杯中各有一半可乐，较小的杯中没有可乐。这里可以使用一个数组v[3]，v[0] v[1] v[2]分别记录可乐瓶， 较大的杯子，与较小的杯子的容积。用一个结构体node记录每个状态各容器内的可乐体积与当前状态的倒水次数，布尔数组vis记录状态是否出现过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">3</span>];   </span><br><span class="line">    <span class="comment">//v[]0 v[1] v[2] 分别为当前状态可乐瓶、大杯、小杯之内的可乐体积</span></span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="comment">//step记录倒水次数</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//记录状态是否出现过</span></span><br></pre></td></tr></table></figure>
<p> 　　倒水，可以写一个判断倒水函数，传入对应容器x与y，执行x向y倒水，如果被倒入容器y的容积小于两个容器中可乐总体积，就将容器y倒满，如果y的容积大于两容器中的可乐总体积 ，就将所有可乐倒入y容器，两容器中可乐总体积减去y中的可乐体积就是x中剩余的可乐体积。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;   <span class="comment">//传入容器x y</span></span><br><span class="line">    <span class="keyword">int</span> sum = Node.v[x] + Node.v[y];<span class="comment">//记录两容器中的可乐总体积</span></span><br><span class="line">    <span class="keyword">if</span>(v[y] &lt;= sum)&#123;    <span class="comment">//y的容积小于两个容器中可乐总体积</span></span><br><span class="line">        Node.v[y] = v[y];   <span class="comment">//将容器y倒满</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//y的容积大于两容器中的可乐总体积</span></span><br><span class="line">        Node.v[y] = sum;    <span class="comment">//将所有可乐倒入y</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node.v[x] = sum - Node.v[y];    </span><br><span class="line">    <span class="comment">//两容器中可乐总体积减去y中的可乐体积，x中剩余的可乐体积</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> AC代码 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">3</span>];   </span><br><span class="line">    <span class="comment">//v[]0 v[1] v[2] 分别为当前状态可乐瓶、大杯、小杯之内的可乐体积</span></span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">    <span class="comment">//step记录倒水次数</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//记录状态是否出现过</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;   <span class="comment">//传入容器x y</span></span><br><span class="line">    <span class="keyword">int</span> sum = Node.v[x] + Node.v[y];<span class="comment">//记录两容器中的可乐总体积</span></span><br><span class="line">    <span class="keyword">if</span>(v[y] &lt;= sum)&#123;    <span class="comment">//y的容积小于两个容器中可乐总体积</span></span><br><span class="line">        Node.v[y] = v[y];   <span class="comment">//将容器y倒满</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//y的容积大于两容器中的可乐总体积</span></span><br><span class="line">        Node.v[y] = sum;    <span class="comment">//将所有可乐倒入y</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node.v[x] = sum - Node.v[y];    </span><br><span class="line">    <span class="comment">//两容器中可乐总体积减去y中的可乐体积，x中剩余的可乐体积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node.v[<span class="number">0</span>] = v[<span class="number">0</span>];   </span><br><span class="line">    Node.v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Node.v[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    Node.step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录初始状态，可乐瓶中体积为s，两个杯中的可乐体积都为0</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="comment">//初始化所有状态为未出现过</span></span><br><span class="line">    vis[Node.v[<span class="number">0</span>]][Node.v[<span class="number">1</span>]][Node.v[<span class="number">2</span>]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//标记当前状态为已出现</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; Q;</span><br><span class="line">    <span class="comment">//队列Q记录当前可操作状态</span></span><br><span class="line">    Q.push(Node);</span><br><span class="line">    <span class="comment">//当前状态入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;  </span><br><span class="line">        node top = Q.front();</span><br><span class="line">        <span class="comment">//取出队首元素</span></span><br><span class="line">        <span class="keyword">if</span>(top.v[<span class="number">0</span>] == top.v[<span class="number">1</span>] &amp;&amp; top.v[<span class="number">2</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//可乐瓶与较大的杯中各有一半可乐，较小的杯中没有可乐</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, top.step);<span class="comment">//输出次数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123; <span class="comment">//搜索所有6种状态</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j)&#123; <span class="comment">//自己不能向自己倒水</span></span><br><span class="line">                    Node = top;</span><br><span class="line">                    judge(i , j);   <span class="comment">//执行i向j倒水</span></span><br><span class="line">                    <span class="keyword">if</span>(!vis[Node.v[<span class="number">0</span>]][Node.v[<span class="number">1</span>]][Node.v[<span class="number">2</span>]])&#123;  <span class="comment">//若新状态之前没有出现过</span></span><br><span class="line">                        Node.step++;</span><br><span class="line">                        <span class="comment">//倒水次数加一</span></span><br><span class="line">                        vis[Node.v[<span class="number">0</span>]][Node.v[<span class="number">1</span>]][Node.v[<span class="number">2</span>]] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">//标记新状态为已出现</span></span><br><span class="line">                        Q.push(Node);</span><br><span class="line">                        <span class="comment">//新状态入队 </span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO\n"</span>); <span class="comment">//若不能分成两份输出NO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;s, &amp;n, &amp;m) != EOF &amp;&amp; s || n || m)&#123;   <span class="comment">//输入s n m 以0为结束标志</span></span><br><span class="line">        v[<span class="number">0</span>] = s;</span><br><span class="line">        <span class="comment">//获得大杯与小杯的容积</span></span><br><span class="line">        <span class="keyword">if</span>(n &gt; m)&#123;</span><br><span class="line">            v[<span class="number">1</span>] = n;</span><br><span class="line">            v[<span class="number">2</span>] = m;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            v[<span class="number">1</span>] = m;</span><br><span class="line">            v[<span class="number">2</span>] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        BFS();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/06/POJ-2251-Dungeon-Master/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/06/POJ-2251-Dungeon-Master/" class="post-title-link" itemprop="url">POJ 2251 Dungeon Master</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-06 20:11:27" itemprop="dateCreated datePublished" datetime="2018-12-06T20:11:27+08:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. </p>
<p>　　Is an escape possible? If yes, how long will it take? </p>
<p>Input</p>
<p>　　The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).<br>　　L is the number of levels making up the dungeon.<br>　　R and C are the number of rows and columns making up the plan of each level.<br>Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.</p>
<p>Output</p>
<p>　　Each maze generates one line of output. If it is possible to reach the exit, print a line of the form </p>
<p> Escaped in x minute(s). </p>
<p> where x is replaced by the shortest time it takes to escape.<br>　　If it is not possible to escape, print the line  </p>
<p> Trapped! </p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line">###.#</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">##.##</span><br><span class="line">##...</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#.###</span><br><span class="line">####E</span><br><span class="line"></span><br><span class="line">1 3 3</span><br><span class="line">S##</span><br><span class="line">#E#</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Escaped in 11 minute(s).</span><br><span class="line">Trapped!</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题有多组测数据，每组数据包括第一行输入3个整数，分别为 l 地牢层数、 r 每次地牢行数， c 每层地牢列数。</p>
<p>　　之后输入 l 个矩阵，分别为地牢每层的状态。</p>
<p>　　其中’ # ‘表示该位置充满岩石；</p>
<p>　　‘ . ‘表示空地；</p>
<p>　　‘ S ‘表示起点；</p>
<p>　　‘ E ‘表示终点；</p>
<p>　　以 l r c 输入都为0为结束标准。</p>
<p>　　要求按格式输出从起点到终点的最短时间，若不能逃脱输出Trapped!</p>
<p>　　本题可以使用bfs基本思想为，从起点开始向周围东西南北上下6个方向搜索，使用一个队列记录当前可用起点，每次取出一个点并将其可以抵达且还没有抵达过的点加入队列，并将其步数记录为先前点的步数加一，当找到终点时，到终点的最短时间就是到终点所需的步数，若直到队列为空，即没有可用起点，则证明终点不可达，输出Trapped!</p>
<p>　　这里将 l 视为z、 将r 视为x，将c视为y，使用一个char型的三维数组mapn记录地牢，由于给出的每个矩阵代表每层的信息，所以输入矩阵时按层输入。用三维布尔数组vis记录地牢内该位置是否已经抵达过，用一个结构体node记录该点信息与抵达该点所需的步数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;   <span class="comment">//传入起点位置</span></span><br><span class="line">    Node.x = x;</span><br><span class="line">    Node.y = y;</span><br><span class="line">    Node.z = z;</span><br><span class="line">    Node.step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录抵达起点所需的步数为0</span></span><br><span class="line">    vis[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//标记起点为已抵达</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; Q;</span><br><span class="line">    Q.push(Node);</span><br><span class="line">    <span class="comment">//起点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        node top = Q.front();</span><br><span class="line">        <span class="comment">//取出队首点寻找其周围可达的位置</span></span><br><span class="line">        <span class="keyword">if</span>(top.x == ex &amp;&amp; top.y == ey &amp;&amp; top.z == ez)</span><br><span class="line">            <span class="keyword">return</span> top.step;    <span class="comment">//若队首为终点证明可以逃脱，返回所需步数</span></span><br><span class="line">        Q.pop();    <span class="comment">//队首点出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123; <span class="comment">//遍历周围四个位置</span></span><br><span class="line">            <span class="comment">//newX newY newZ为新的位置</span></span><br><span class="line">            <span class="keyword">int</span> newX = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> newY = top.y + Y[i];</span><br><span class="line">            <span class="keyword">int</span> newZ = top.z + Z[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(newX, newY, newZ))&#123;    <span class="comment">//判断新的位置是否可以走</span></span><br><span class="line">                Node.x = newX;</span><br><span class="line">                Node.y = newY;</span><br><span class="line">                Node.z = newZ;</span><br><span class="line">                Node.step = top.step + <span class="number">1</span>;   <span class="comment">//记录可以走的新的位置步数为top步数加一</span></span><br><span class="line">                vis[newX][newY][newZ] = <span class="literal">true</span>;   <span class="comment">//标记新位置为已抵达</span></span><br><span class="line">                Q.push(Node);   <span class="comment">//新位置入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//若不可达返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        判断位置可以走的要求时不超地牢边界不是岩石且之前没走过。</p>
<p>　　AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> l, r, c;    <span class="comment">//记录层数列数与行数</span></span><br><span class="line"><span class="keyword">int</span> bx, by, bz, ex, ey, ez;</span><br><span class="line"><span class="comment">//记录起点与终点坐标</span></span><br><span class="line"><span class="keyword">char</span> mapn[maxn][maxn][maxn];    <span class="comment">//记录地牢</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][maxn] = &#123;<span class="literal">false</span>&#125;;   <span class="comment">//某点是否走过</span></span><br><span class="line"><span class="comment">//周围6个方向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Y[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Z[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;    <span class="comment">//记录当前点位置</span></span><br><span class="line">    <span class="keyword">int</span> step;   <span class="comment">//记录当前点步数</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= r || y &lt; <span class="number">0</span> || y &gt;= c || z &lt; <span class="number">0</span> || z &gt;= l)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//超边界返回false</span></span><br><span class="line">    <span class="keyword">if</span>(mapn[x][y][z] == <span class="string">'#'</span> || vis[x][y][z])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//目标点为岩石或之前走过返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;   <span class="comment">//传入起点位置</span></span><br><span class="line">    Node.x = x;</span><br><span class="line">    Node.y = y;</span><br><span class="line">    Node.z = z;</span><br><span class="line">    Node.step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录抵达起点所需的步数为0</span></span><br><span class="line">    vis[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//标记起点为已抵达</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; Q;</span><br><span class="line">    Q.push(Node);</span><br><span class="line">    <span class="comment">//起点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        node top = Q.front();</span><br><span class="line">        <span class="comment">//取出队首点寻找其周围可达的位置</span></span><br><span class="line">        <span class="keyword">if</span>(top.x == ex &amp;&amp; top.y == ey &amp;&amp; top.z == ez)</span><br><span class="line">            <span class="keyword">return</span> top.step;    <span class="comment">//若队首为终点证明可以逃脱，返回所需步数</span></span><br><span class="line">        Q.pop();    <span class="comment">//队首点出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123; <span class="comment">//遍历周围四个位置</span></span><br><span class="line">            <span class="comment">//newX newY newZ为新的位置</span></span><br><span class="line">            <span class="keyword">int</span> newX = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> newY = top.y + Y[i];</span><br><span class="line">            <span class="keyword">int</span> newZ = top.z + Z[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(newX, newY, newZ))&#123;    <span class="comment">//判断新的位置是否可以走</span></span><br><span class="line">                Node.x = newX;</span><br><span class="line">                Node.y = newY;</span><br><span class="line">                Node.z = newZ;</span><br><span class="line">                Node.step = top.step + <span class="number">1</span>;   <span class="comment">//记录可以走的新的位置步数为top步数加一</span></span><br><span class="line">                vis[newX][newY][newZ] = <span class="literal">true</span>;   <span class="comment">//标记新位置为已抵达</span></span><br><span class="line">                Q.push(Node);   <span class="comment">//新位置入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//若不可达返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c) != EOF &amp;&amp; l &amp;&amp; r &amp;&amp;c)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; l; z++)&#123; <span class="comment">//按层输入</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; r; x++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; c; y++)&#123;</span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; mapn[x][y][z];</span><br><span class="line">                    <span class="keyword">if</span>(mapn[x][y][z] == <span class="string">'S'</span>)&#123;   <span class="comment">//获取起点终点位置</span></span><br><span class="line">                        bx = x, by = y, bz = z;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(mapn[x][y][z] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                        ex = x, ey = y, ez = z;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="comment">//初始化所有点为未抵达</span></span><br><span class="line">        <span class="keyword">int</span> ans = BFS(bx, by, bz);</span><br><span class="line">        <span class="comment">//获取步数</span></span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>)&#123;  <span class="comment">//-1为不逃脱</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Trapped!\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Escaped in %d minute(s).\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/05/HDU-3085-Nightmare-%E2%85%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/HDU-3085-Nightmare-%E2%85%A1/" class="post-title-link" itemprop="url">HDU 3085 Nightmare Ⅱ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 20:00:52" itemprop="dateCreated datePublished" datetime="2018-12-05T20:00:52+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>　　Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.<br>　　You may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.<br>　　Note: the new ghosts also can devide as the original ghost. </p>
<p>Input</p>
<p>　　The input starts with an integer T, means the number of test cases.<br>　　Each test case starts with a line contains two integers n and m, means the size of the maze. (1&lt;n, m&lt;800)<br>　　The next n lines describe the maze. Each line contains m characters. The characters may be:<br>　　‘.’ denotes an empty place, all can walk on.<br>　　‘X’ denotes a wall, only people can’t walk on.<br>　　‘M’ denotes little erriyue<br>　　‘G’ denotes the girl friend.<br>　　‘Z’ denotes the ghosts.<br>　　It is guaranteed that will contain exactly one letter M, one letter G and two letters Z.<br>Output</p>
<p>　　Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5 6</span><br><span class="line">XXXXXX</span><br><span class="line">XZ..ZX</span><br><span class="line">XXXXXX</span><br><span class="line">M.G...</span><br><span class="line">......</span><br><span class="line">5 6</span><br><span class="line">XXXXXX</span><br><span class="line">XZZ..X</span><br><span class="line">XXXXXX</span><br><span class="line">M.....</span><br><span class="line">..G...</span><br><span class="line"></span><br><span class="line">10 10</span><br><span class="line">..........</span><br><span class="line">..X.......</span><br><span class="line">..M.X...X.</span><br><span class="line">X.........</span><br><span class="line">.X..X.X.X.</span><br><span class="line">.........X</span><br><span class="line">..XX....X.</span><br><span class="line">X....G...X</span><br><span class="line">...ZX.X...</span><br><span class="line">...Z..X..X</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出测试数量t，每组测试包括两个整数n、m，之后给出一个n行m列的矩阵代表地图的初始状态。</p>
<p>地图中 :</p>
<p>　　“ . “代表空地；</p>
<p>　　“X “代表墙；</p>
<p>　　“M “代表 little erriyue的初始位置；</p>
<p>　　“G “代表 女友的初始位置；</p>
<p>　　“Z “代表鬼的初始位置</p>
<p>　　每个图中M与G都只会有唯一的一个，Z有两个。little erriyue每一回合可以移动3个格子，女友每回合只可以移动1个格子，而鬼每回合会产生出分身（分身可以继续变出分身），覆盖周围2格内所有空地（本题所有行动只能向上下左右4个方向行动，不能斜着前进），行动的顺序是鬼先分身，之后little erriyue与女友行动。如果两人终的任何一人到达有鬼魂的格子就会被宰杀。每一回合算一个小时，要求输出little erriyue最短的汇合时间，若不能汇合输出-1.</p>
<p>　　本题可以使用广域深度搜索，定义一个结构体node储存little erriyue、女友与鬼魂的位置。在输入后先确定little erriyue、女友与鬼魂的位置，用step记录回合数，每回合little erriyue、女友各行动一次，所搜所有可达位置，判断目标位置与鬼魂的曼哈顿距离。由于鬼每一次覆盖其周围所有距离为2的格子，即曼哈顿距离为2的所有位置，所以判断某位置是否已经被鬼的分身占据，只需判断当前的回合数<em>2与鬼位置的曼哈度距离大小即可。</em><br>*</p>
<p>　　曼哈顿距离：</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181205191058576-1094477089.jpg" alt="img"></p>
<p>　　上图红线、蓝线与黄线都为两点间等价的曼哈顿距离，绿线则代表欧氏距离（直线距离）。</p>
<p>　　曼哈顿距离就是图中两点间水平距离加竖直距离，也就是只能上下左右四个方向移动时两点间的最短距离。</p>
<p>　　本题与鬼魂曼哈顿距离判断函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//传入值为要判断点的坐标与当前回合数</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= m)  <span class="comment">//如果传入的点超过地图的边界，该点不能走，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mapn[x][y] == <span class="string">'X'</span>)  <span class="comment">//如果该点是墙，该点不能走，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果该点与第一个鬼魂的曼哈顿距离小于回合数的两倍则第一个鬼魂已经覆盖了该点，该点不能走，返回false</span></span><br><span class="line">    <span class="comment">//鬼魂每回合可以覆盖两格所以是回合数的两倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (<span class="built_in">abs</span>(x - lghost1.x) + <span class="built_in">abs</span>(y - lghost1.y)) &lt;= step * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果该点与第二个鬼魂的曼哈顿距离小于回合数的两倍则第而个鬼魂已经覆盖了该点，该点不能走，返回false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (<span class="built_in">abs</span>(x - lghost2.x) + <span class="built_in">abs</span>(y - lghost2.y)) &lt;= step * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//只有上述条件都不满足时返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对于little erriyue和女友我们可以利用广搜每回合搜索他们可以抵达的点判断是否可以汇合。</p>
<p>　　分别用两个队列表示little erriyue与女友当前回合可用的起始位置（上一回合的可达位置）</p>
<p>　　对于little erriyue，他每回合可以行动3格，我们就让他每次行动一格搜索3次即可</p>
<p>　　little erriyue：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfsLE</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;   <span class="comment">//传入的值为当前回合数</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">3</span>;  <span class="comment">//行动3次</span></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = littleErriyue.size(); </span><br><span class="line">        <span class="comment">//sum为当前队列中元素的数量，代表当前回合的起始位置数量（即上一回合可达位置数量）</span></span><br><span class="line">        <span class="keyword">while</span>(sum--)&#123;   <span class="comment">//遍历所有起始位置</span></span><br><span class="line">            node top = littleErriyue.front();   </span><br><span class="line">            littleErriyue.pop();</span><br><span class="line">            <span class="comment">//记录当前首位并出队</span></span><br><span class="line">            <span class="keyword">if</span>(!judge(top.x, top.y, step))  </span><br><span class="line">                <span class="comment">//由于每回合开始都是鬼鬼魂先分身，所以如果这里被鬼魂覆盖这点就不能用了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//遍历当前点可以到达的4个位置</span></span><br><span class="line">                <span class="keyword">int</span> NewX = top.x + X[i];</span><br><span class="line">                <span class="keyword">int</span> NewY = top.y + Y[i];</span><br><span class="line">                <span class="keyword">if</span>(!visLE[NewX][NewY] &amp;&amp; judge(NewX, NewY, step))&#123; </span><br><span class="line">                    <span class="comment">//判断四个位置是否可用，vis数组用来记录目标位置是否已经走过</span></span><br><span class="line">                    <span class="comment">//只有没有走过，且judge为true的位置才可以使用</span></span><br><span class="line">                    <span class="keyword">if</span>(visGF[NewX][NewY])   <span class="comment">//如果目标点本回合或之前女友亦可以抵达证明汇合成功</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//返回true</span></span><br><span class="line">                    Node.x = NewX;</span><br><span class="line">                    Node.y = NewY;</span><br><span class="line">                    littleErriyue.push(Node);   <span class="comment">//新位置入队</span></span><br><span class="line">                    visLE[NewX][NewY] = <span class="literal">true</span>;   <span class="comment">//新位置标记为已经走过</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 　　女友： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//女友行动与little erriyue类似，唯一的区别就是只行动一次</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfsGF</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;   <span class="comment">//传入的值为当前回合数</span></span><br><span class="line">    <span class="keyword">int</span> sum = girlFriend.size();</span><br><span class="line">    <span class="comment">//sum为当前队列中元素的数量，代表当前回合的起始位置数量（即上一回合可达位置数量）</span></span><br><span class="line">    <span class="keyword">while</span>(sum--)&#123;<span class="comment">//遍历所有起始位置</span></span><br><span class="line">        node top = girlFriend.front();</span><br><span class="line">        girlFriend.pop();</span><br><span class="line">         <span class="comment">//记录当前首位并出队</span></span><br><span class="line">        <span class="keyword">if</span>(!judge(top.x, top.y, step))</span><br><span class="line">            <span class="comment">//由于每回合开始都是鬼鬼魂先分身，所以如果这里被鬼魂覆盖这点就不能用了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;<span class="comment">//遍历当前点可以到达的4个位置</span></span><br><span class="line">            <span class="keyword">int</span> NewX = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> NewY = top.y + Y[i];</span><br><span class="line">            <span class="keyword">if</span>(!visGF[NewX][NewY] &amp;&amp; judge(NewX, NewY, step))&#123;</span><br><span class="line">                <span class="comment">//判断四个位置是否可用，vis数组用来记录目标位置是否已经走过</span></span><br><span class="line">                    <span class="comment">//只有没有走过，且judge为true的位置才可以使用</span></span><br><span class="line">                <span class="keyword">if</span>(visLE[NewX][NewY])<span class="comment">//如果目标点本回合或之前littel erriyue亦可以抵达证明汇合成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true</span></span><br><span class="line">                Node.x = NewX;</span><br><span class="line">                Node.y = NewY;</span><br><span class="line">                girlFriend.push(Node);<span class="comment">//新位置入队</span></span><br><span class="line">                visGF[NewX][NewY] = <span class="literal">true</span>; <span class="comment">//新位置标记为已经走过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> AC代码 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">810</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Y[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mapn[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> visLE[maxn][maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//little erriyue走过的位置</span></span><br><span class="line"><span class="keyword">bool</span> visGF[maxn][maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//女友走过的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;Node, lLE, lGF, lghost1, lghost2;</span><br><span class="line"><span class="comment">//lLE little erriyue起始位置 lGF 女友起始位置 两个lghost分别为两个鬼魂的起始位置</span></span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; littleErriyue;<span class="comment">//little erriyue当前回合可用的起始位置（上一回合的可达位置）</span></span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; girlFriend;<span class="comment">//女友当前回合可用的起始位置（上一回合的可达位置）</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> g2 = <span class="literal">false</span>;    <span class="comment">//鬼魂2位置未获取</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mapn[i][j] == <span class="string">'M'</span>)&#123;  <span class="comment">//获取little erriyue起始位置</span></span><br><span class="line">                lLE.x = i;</span><br><span class="line">                lLE.y = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mapn[i][j] == <span class="string">'G'</span>)&#123;<span class="comment">//获取女友起始位置</span></span><br><span class="line">                lGF.x = i;</span><br><span class="line">                lGF.y = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mapn[i][j] == <span class="string">'Z'</span>)&#123;    <span class="comment">//获取鬼魂起始位置</span></span><br><span class="line">                <span class="keyword">if</span>(!g2)&#123;</span><br><span class="line">                    lghost2.x = i;</span><br><span class="line">                    lghost2.y = j;</span><br><span class="line">                    g2 = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lghost1.x = i;</span><br><span class="line">                    lghost1.y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123; <span class="comment">//传入值为要判断点的坐标与当前回合数</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= m)  <span class="comment">//如果传入的点超过地图的边界，该点不能走，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mapn[x][y] == <span class="string">'X'</span>)  <span class="comment">//如果该点是墙，该点不能走，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果该点与第一个鬼魂的曼哈顿距离小于回合数的两倍则第一个鬼魂已经覆盖了该点，该点不能走，返回false</span></span><br><span class="line">    <span class="comment">//鬼魂每回合可以覆盖两格所以是回合数的两倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (<span class="built_in">abs</span>(x - lghost1.x) + <span class="built_in">abs</span>(y - lghost1.y)) &lt;= step * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果该点与第二个鬼魂的曼哈顿距离小于回合数的两倍则第而个鬼魂已经覆盖了该点，该点不能走，返回false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( (<span class="built_in">abs</span>(x - lghost2.x) + <span class="built_in">abs</span>(y - lghost2.y)) &lt;= step * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//只有上述条件都不满足时返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfsLE</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;   <span class="comment">//传入的值为当前回合数</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">3</span>;  <span class="comment">//行动3次</span></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = littleErriyue.size(); </span><br><span class="line">        <span class="comment">//sum为当前队列中元素的数量，代表当前回合的起始位置数量（即上一回合可达位置数量）</span></span><br><span class="line">        <span class="keyword">while</span>(sum--)&#123;   <span class="comment">//遍历所有起始位置</span></span><br><span class="line">            node top = littleErriyue.front();   </span><br><span class="line">            littleErriyue.pop();</span><br><span class="line">            <span class="comment">//记录当前首位并出队</span></span><br><span class="line">            <span class="keyword">if</span>(!judge(top.x, top.y, step))  </span><br><span class="line">                <span class="comment">//由于每回合开始都是鬼鬼魂先分身，所以如果这里被鬼魂覆盖这点就不能用了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//遍历当前点可以到达的4个位置</span></span><br><span class="line">                <span class="keyword">int</span> NewX = top.x + X[i];</span><br><span class="line">                <span class="keyword">int</span> NewY = top.y + Y[i];</span><br><span class="line">                <span class="keyword">if</span>(!visLE[NewX][NewY] &amp;&amp; judge(NewX, NewY, step))&#123; </span><br><span class="line">                    <span class="comment">//判断四个位置是否可用，vis数组用来记录目标位置是否已经走过</span></span><br><span class="line">                    <span class="comment">//只有没有走过，且judge为true的位置才可以使用</span></span><br><span class="line">                    <span class="keyword">if</span>(visGF[NewX][NewY])   <span class="comment">//如果目标点本回合或之前女友亦可以抵达证明汇合成功</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//返回true</span></span><br><span class="line">                    Node.x = NewX;</span><br><span class="line">                    Node.y = NewY;</span><br><span class="line">                    littleErriyue.push(Node);   <span class="comment">//新位置入队</span></span><br><span class="line">                    visLE[NewX][NewY] = <span class="literal">true</span>;   <span class="comment">//新位置标记为已经走过</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//女友行动与little erriyue类似，唯一的区别就是只行动一次</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfsGF</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;   <span class="comment">//传入的值为当前回合数</span></span><br><span class="line">    <span class="keyword">int</span> sum = girlFriend.size();</span><br><span class="line">    <span class="comment">//sum为当前队列中元素的数量，代表当前回合的起始位置数量（即上一回合可达位置数量）</span></span><br><span class="line">    <span class="keyword">while</span>(sum--)&#123;<span class="comment">//遍历所有起始位置</span></span><br><span class="line">        node top = girlFriend.front();</span><br><span class="line">        girlFriend.pop();</span><br><span class="line">         <span class="comment">//记录当前首位并出队</span></span><br><span class="line">        <span class="keyword">if</span>(!judge(top.x, top.y, step))</span><br><span class="line">            <span class="comment">//由于每回合开始都是鬼鬼魂先分身，所以如果这里被鬼魂覆盖这点就不能用了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;<span class="comment">//遍历当前点可以到达的4个位置</span></span><br><span class="line">            <span class="keyword">int</span> NewX = top.x + X[i];</span><br><span class="line">            <span class="keyword">int</span> NewY = top.y + Y[i];</span><br><span class="line">            <span class="keyword">if</span>(!visGF[NewX][NewY] &amp;&amp; judge(NewX, NewY, step))&#123;</span><br><span class="line">                <span class="comment">//判断四个位置是否可用，vis数组用来记录目标位置是否已经走过</span></span><br><span class="line">                    <span class="comment">//只有没有走过，且judge为true的位置才可以使用</span></span><br><span class="line">                <span class="keyword">if</span>(visLE[NewX][NewY])<span class="comment">//如果目标点本回合或之前littel erriyue亦可以抵达证明汇合成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回true</span></span><br><span class="line">                Node.x = NewX;</span><br><span class="line">                Node.y = NewY;</span><br><span class="line">                girlFriend.push(Node);<span class="comment">//新位置入队</span></span><br><span class="line">                visGF[NewX][NewY] = <span class="literal">true</span>; <span class="comment">//新位置标记为已经走过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);    <span class="comment">//输入测试数量</span></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);  <span class="comment">//输入n与m</span></span><br><span class="line">        <span class="built_in">memset</span>(visLE, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visLE));</span><br><span class="line">        <span class="built_in">memset</span>(visGF, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visGF));</span><br><span class="line">        <span class="comment">//初始化两个vis数组为false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//输入地图</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, mapn[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        getLocation();  <span class="comment">//获得各特殊元素位置</span></span><br><span class="line">        <span class="comment">//清空两个队列</span></span><br><span class="line">        <span class="keyword">while</span>(!littleErriyue.empty())&#123;</span><br><span class="line">            littleErriyue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!girlFriend.empty())&#123;</span><br><span class="line">            girlFriend.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//little erriyue与女友的初始位置入队</span></span><br><span class="line">        littleErriyue.push(lLE);</span><br><span class="line">        girlFriend.push(lGF);</span><br><span class="line">        visLE[lLE.x][lLE.y] = <span class="literal">true</span>;</span><br><span class="line">        visGF[lGF.x][lGF.y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;   <span class="comment">//step记录时间（回合数）</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//flag 记录是否可汇合</span></span><br><span class="line">        <span class="keyword">while</span>(!girlFriend.empty() || !littleErriyue.empty())&#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">if</span>(bfsLE(step))&#123;    <span class="comment">//little erriyue行动</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, step);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bfsGF(step))&#123;    <span class="comment">//女友行动</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, step);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;  <span class="comment">//不能汇合</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/02/CodeForces-1060-B-Maximum-Sum-of-Digits/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/02/CodeForces-1060-B-Maximum-Sum-of-Digits/" class="post-title-link" itemprop="url">CodeForces 1060 B Maximum Sum of Digits</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-02 19:43:58" itemprop="dateCreated datePublished" datetime="2018-12-02T19:43:58+08:00">2018-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　You are given a positive integer n.</p>
<p>　　Let S(x)S(x) be sum of digits in base 10 representation of xx , for example, S(123)=1+2+3=6S(123)=1+2+3=6 , S(0)=0S(0)=0 .</p>
<p>　　Your task is to find two integers a,ba,b , such that 0≤a,b≤n0≤a,b≤n , a+b=na+b=n and S(a)+S(b)S(a)+S(b) is the largest possible among all such pairs.</p>
<p>Input</p>
<p>　　The only line of input contains an integer nn (1≤n≤1012)(1≤n≤1012) .</p>
<p>Output</p>
<p>　　Print largest S(a)+S(b)S(a)+S(b) among all pairs of integers a,ba,b , such that 0≤a,b≤n0≤a,b≤n and a+b=na+b=n .</p>
<p>Examples</p>
<p>Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure>
<p>Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000000000</span><br></pre></td></tr></table></figure>
<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">91</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>　　In the first example, you can choose, for example, a=17a=17 and b=18b=18 , so that S(17)+S(18)=1+7+1+8=17S(17)+S(18)=1+7+1+8=17 . It can be shown that it is impossible to get a larger answer.</p>
<p>　　In the second test example, you can choose, for example, a=5000000001a=5000000001 and b=4999999999b=4999999999 , with S(5000000001)+S(4999999999)=91S(5000000001)+S(4999999999)=91 . It can be shown that it is impossible to get a larger answer.</p>
<p>解题思路：<br>　　给出一个数字n，将他拆分为2个数字，使拆分的两个数字每一位相加的和最大，输出相加后的和。</p>
<p>　　个人感觉不用管下面提示。我们本着贪心的思想，希望获得尽可能多的9，就是将35，拆分为9与26，将10000000000，拆分为9999999999与1，既将原始数字拆分为比其第一位的全由9组成的数字与另一个补偿数字，补偿数字为原始数字减去拆分的全9数字。之后将拆分的两个数字所有位都相加便可以得到答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//CodeForces不支持万能头文件bits/stdc++.h</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">string</span> n;</span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//快速幂</span></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> suma=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumb=<span class="number">0</span>;</span><br><span class="line">        a = power(<span class="number">10</span>, n.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//若想拆分出小于且9最多的数字，只需要找到n的位数n.size() - 1</span></span><br><span class="line">        <span class="comment">//之后便可以用10的n.size() - 1次幂找到与n位数相等数字中最小数字</span></span><br><span class="line">        <span class="comment">//减一便可以得到我们所要拆分的数字</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">cinn</span><span class="params">(n)</span></span>;</span><br><span class="line">        cinn &gt;&gt; b;</span><br><span class="line">        <span class="comment">//先用istringstream读取n中的值输入到整形b中</span></span><br><span class="line">        <span class="comment">//b - a就是补偿的数字。</span></span><br><span class="line">        a--;</span><br><span class="line">        b = b - a;</span><br><span class="line">        <span class="keyword">while</span>(a)    <span class="comment">//将a的每一位加起来</span></span><br><span class="line">        &#123;</span><br><span class="line">            suma += a % <span class="number">10</span>;</span><br><span class="line">            a/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            sumb += b % <span class="number">10</span>; <span class="comment">//将b的每一位加起来</span></span><br><span class="line">            b/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; suma + sumb &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//所有位数加和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/12/01/HDU-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/01/HDU-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">HDU 1166 敌兵布阵(树状数组)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-01 18:42:15" itemprop="dateCreated datePublished" datetime="2018-12-01T18:42:15+08:00">2018-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。<br>中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. </p>
<p>Input</p>
<p>　　第一行一个整数T，表示有T组数据。<br>　　每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。<br>　　接下来每行有一条命令，命令有4种形式：<br>　　(1)Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>　　(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>　　(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br>　　(4)End 表示结束，这条命令在每组数据最后出现;<br>　　每组数据最多有40000条命令<br>Output</p>
<p>　　对第i组数据,首先输出“Case i:”和回车,<br>　　对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。<br>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Query 1 3</span><br><span class="line">Add 3 6</span><br><span class="line">Query 2 7</span><br><span class="line">Sub 10 2</span><br><span class="line">Add 6 3</span><br><span class="line">Query 3 10</span><br><span class="line">End</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">6</span><br><span class="line">33</span><br><span class="line">59</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题有多组测试数据，给出测试数量t，元素个数n，之后给出一个有n个元素的整数序列a，之后给出操作语句以End为结束标值。</p>
<p>　　首先，对于查询一个整数序列前n个数之和，一般的做法是开一个sum[i]数组记录前i个整数之和可以将每次查询时间复杂度降至O(1)，但是在此处，Add与Sub操作随时可能对整除序列中的元素造成影响，假设更改了x号元素，若想继续维护sum数组就需要更新sum[x]、sum[x+1]、sum[x+2] …… sum[n]，这时虽然保证了查询的时间复杂度为O(1)，但是维护sum却需要O(n)的时间复杂度，对于本题来说是不可承受的。</p>
<p>　　这时便需要用到树状数组，我们用c[i]，来存放元素的和，c与sum的区别是，c[i]不是前i个元素的元素和而是下图的样子。</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181201170741378-1507510862.png" alt="图1"></p>
<p>　　不难发现其中c[i]中的元素数量为i可以整除的最大的2的次幂数+1，我们称其为lowbit( i )。</p>
<p>　　如何快速计算出lowbit？如果了解计算机组成原理可以得知，整数在计算机中的存储采用的是补码，若把 i 的二进制位每一位都取反后末位+1，便可得到-i，，这其实相当于把 i 的二进制位右起第一个1左方的所有位取反，之后 i &amp;( -i )便可取得最右位的1与其右方所有的0，这显然是2的次幂。这样我们就获得了lowbit( i )，例如12（1100）取反（0011）加一（0100），最右方的1与其右方的0（100）= 4。</p>
<p>　　根据上图分析数组c。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">长度：1 c[1] &#x3D; a[1]</span><br><span class="line">长度：2 c[2] &#x3D; a[1] + a[2]                                         &#x3D; c[1] + a[2]</span><br><span class="line">长度：1 c[3] &#x3D; a[3]</span><br><span class="line">长度：4 c[4] &#x3D; a[1] + a[2] + a[3] + a[4]                           &#x3D; c[2] + c[3] + c[1] + a[4]</span><br><span class="line">长度：1 c[5] &#x3D; a[5]</span><br><span class="line">长度：2 c[6] &#x3D; a[5] + a[6]                                         &#x3D; c[5] + a[6]</span><br><span class="line">长度：1 c[7] &#x3D; a[7]</span><br><span class="line">长度：8 c[8] &#x3D; a[1] + a[2] + a[3] + a[4] + a[5] +a[6] + a[7] +a[8] &#x3D; c[4] + c[6] + c[7] + a[8]</span><br></pre></td></tr></table></figure>
<p>　　由于c[ i ]的长度为lowbit( i )可以总结出c[ i ] = a[i - lowbit( i ) + 1] + a[i - lowbit( i ) + 2] + …… + a[ i ]。</p>
<p>　　从1 ~ i a的和为a[1] + a[2] + a[3] + …… + a[ i ]，将它疯狂拆分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  a[1] + a[2] + a[3] + …… + a[ i ]</span><br><span class="line">&#x3D; a[1] + a[2] + a[3] + …… + a[i - lowbit(i)] + a[i - lowbit(i) + 1] + …… + a[ i ]</span><br><span class="line">&#x3D; a[1] + a[2] + a[3] + …… + a[i - lowbit(i)] + c[i]</span><br><span class="line">&#x3D; a[1] + a[2] + a[3] + …… + a[ (i - lowbit(i) ) - lowbit(i - lowbit(i)) ]  + c[i - lowbit(i)] + c[ i ]</span><br></pre></td></tr></table></figure>
<p>找到了规律，获得了巨大的快乐。</p>
<p>　　之后我们写出获取从1 ~ i a的元素和的函数，至于题中要查询i ~ j的元素和，我等只需要查出1 ~ j的元素和与1 ~ i - 1的元素和即可，这样我们只需要O(logn)的时间复杂度就可以完成一次查询。</p>
<p>getSum函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;    <span class="comment">//sum记录和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;  <span class="comment">//拆分每一个C[i]</span></span><br><span class="line">        sum += C[i];    <span class="comment">//累计C[i]将求和范围缩小至</span></span><br><span class="line">        <span class="comment">//a[1] + a[2] + a[3] + …… + a[i - lowbit(i)] + c[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　解决了查询的问题就要开始处理题目中要求的加与减了。</p>
<p>　　如果我们想将a[ i ]加或减去一个数值，那么我们需要将所有包含a[ i ]的c[ i ]都加上或减去一个同样的值。</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201812/1447131-20181201181210054-926081251.png" alt="img"></p>
<p>　　也就是说若将a[3] + 1对应的c[3] c[4] c[8]都要+1，我们要想办法确定覆盖c[3]的最近的c[x]，由于c[x]中每个元素包含的a的数量为lowbit(x)，若想让c[x]包含c[3]，那必定lowbit(x) &gt; lowbit(3)，否则不可能覆盖。之后我们设x = 3 + y，当y = 3时根据我们之前对lowbit来源的解释，3 与 y相等，它们转化为二进制后最右方的1的位置一定相等，x 的最右方1的位置即为y最右方1左侧的第一个0的位置，那么lowbit(x)定然大于lowbit(3)，即x = 6时，这个3 + lowbit(6) = 4就是我们能找到的第一个包含c[3]的c的元素。</p>
<p>　　之后我们便可以写出更新函数update</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;  <span class="comment">//传入要更改的元素位置与要更改的数值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))&#123; <span class="comment">//让找到的每一个c[i]都加上v</span></span><br><span class="line">        C[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　有了getSum与update函数我们就可以做到本题一切要求了。</p>
<p>　　之后只需要根据输入的是Query、Add还是Sub进行操作即可。</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i)&amp;(-i))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//传入要更改的元素位置与要更改的数值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; maxn; i += lowbit(i))&#123;<span class="comment">//让找到的每一个c[i]都加上v</span></span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;    <span class="comment">//sum记录和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= lowbit(i))&#123;  <span class="comment">//拆分每一个C[i]</span></span><br><span class="line">        sum += c[i];</span><br><span class="line">        <span class="comment">//累计C[i]将求和范围缩小至a[1] + a[2] + a[3] + …… + a[i - lowbit(i)] + c[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x, t;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t) != EOF)&#123;  <span class="comment">//输入测试数量</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">//cnt记录当前测试编号</span></span><br><span class="line">        <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);    <span class="comment">//输入敌人工兵营地数量</span></span><br><span class="line">            <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));    <span class="comment">//初始化数组0的元素值都为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);    <span class="comment">//输入每个营地的初始人数</span></span><br><span class="line">                update(i, x);   <span class="comment">//更新c[i]增加x个人</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> s;   <span class="comment">//s记录输入的命令</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, cnt++);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">                <span class="keyword">if</span>(s == <span class="string">"Query"</span>)&#123;   <span class="comment">//查询</span></span><br><span class="line">                        <span class="keyword">int</span> a, b;</span><br><span class="line">                        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">                        <span class="keyword">int</span> ansa, ansb;</span><br><span class="line">                        ansa = getSum(a - <span class="number">1</span>);</span><br><span class="line">                        ansb = getSum(b);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ansb - ansa);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">"Add"</span>)&#123;   <span class="comment">//增加</span></span><br><span class="line">                    <span class="keyword">int</span> a, b;</span><br><span class="line">                        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">                        update(a, b);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">"Sub"</span>)&#123;   <span class="comment">//减少</span></span><br><span class="line">                    <span class="keyword">int</span> a, b;</span><br><span class="line">                        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">                        update(a, -b);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//收到End结束</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/28/HDOJ-2050-%E6%8A%98%E7%BA%BF%E5%88%86%E5%89%B2%E5%B9%B3%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/28/HDOJ-2050-%E6%8A%98%E7%BA%BF%E5%88%86%E5%89%B2%E5%B9%B3%E9%9D%A2/" class="post-title-link" itemprop="url">HDOJ 2050 折线分割平面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-28 21:13:14" itemprop="dateCreated datePublished" datetime="2018-11-28T21:13:14+08:00">2018-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><meta name="referrer" content="no-referrer"><br>我们看到过很多直线分割平面的题目，今天的这个题目稍微有些变化，我们要求的是n条折线分割平面的最大数目。比如，一条折线可以将平面分成两部分，两条折线最多可以将平面分成7部分，具体如下所示。<br><img src="http://acm.hdu.edu.cn/data/images/C40-1008-1.jpg" alt="img"> </p>
<p>Input输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(0&lt;n&lt;=10000),表示折线的数量。 </p>
<p>Output对于每个测试实例，请输出平面的最大分割数，每个实例的输出占一行。 </p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题给出测试数量c，每组测试给出一个数字n为折线的数量。要求计算出平面的最大分割数。</p>
<p>　　我们先不管折线，我们分析一下2n条直线可以将可以将平面分为多少份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">直线数量：0    分割数量：1</span><br><span class="line">直线数量：1    分割数量：1 + 1 &#x3D; 2</span><br><span class="line">直线数量：2    分割数量：2 + 2 &#x3D; 4</span><br><span class="line">直线数量：3    分割数量：4 + 3 &#x3D; 7</span><br><span class="line">直线数量：4    分割数量：7 + 4 &#x3D; 11</span><br><span class="line">直线数量：5    分割数量：11 + 5 &#x3D; 16</span><br><span class="line">直线数量：6    分割数量：16 + 6 &#x3D; 22</span><br><span class="line">……</span><br><span class="line">直线数量：n    分割数量：1 + 1 + 2 + 3 + 4 + …… + n</span><br></pre></td></tr></table></figure>
<p>现在在看一下折线</p>
<p>　　一条折线可以看作2条直线，现在再看这个图仿佛变了些什么</p>
<p><img src="https://img2018.cnblogs.com/blog/1447131/201811/1447131-20181128205529962-1876256551.png" alt="img"></p>
<p>　　每捏起一个点便会少分割两个平面，而一条折线相当与两条直线捏起一个点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">直线数量：0    分割数量：1                                    </span><br><span class="line">直线数量：1    分割数量：1 + 1 &#x3D; 2                                 </span><br><span class="line">直线数量：2    分割数量：2 + 2 &#x3D; 4       斜线数量：1     分割数量：2 &#x3D; 4 - 2  </span><br><span class="line">直线数量：3    分割数量：4 + 3 &#x3D; 7</span><br><span class="line">直线数量：4    分割数量：7 + 4 &#x3D; 11     斜线数量：2     分割数量：7 &#x3D; 11 - 4  </span><br><span class="line">直线数量：5    分割数量：11 + 5 &#x3D; 16</span><br><span class="line">直线数量：6    分割数量：16 + 6 &#x3D; 22   斜线数量：3     分割数量：16 &#x3D; 22 - 6 </span><br><span class="line">……</span><br><span class="line">直线数量：2n    分割数量：1 + 1 + 2 + …… + 2n   </span><br><span class="line">斜线数量：n   分割数量：1 + 1 + 2 + …… + 2n - 1</span><br><span class="line">找到了规律，获得了巨大的快乐</span><br></pre></td></tr></table></figure>
<p>　　这样求n条折线分割平面数量就转化为了求2n - 1条直线分割平面数量</p>
<p>　　而且n最大为1e4而且有多组数据，这当然要快乐打表。</p>
<p>AC代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1e4+10;</span><br><span class="line">int temp[2 * maxn + 100];   &#x2F;&#x2F;temp[i]记录i条直线最大分割平面数</span><br><span class="line">int ans[maxn + 10]; &#x2F;&#x2F;ans[i]记录i条折线最大分割平面数</span><br><span class="line">void init()&#123;</span><br><span class="line">    ans[1] &#x3D; 2;</span><br><span class="line">    temp[1] &#x3D; 2;</span><br><span class="line">    int cnt &#x3D; 1;    &#x2F;&#x2F;cnt记录直线数量</span><br><span class="line">    for(int i &#x3D; 2; i &lt; 2 * maxn; i++)&#123;  &#x2F;&#x2F;直线数量1~2 * maxn</span><br><span class="line">        temp[i] &#x3D; temp[i - 1] + i;</span><br><span class="line">        if(i % 2 &#x3D;&#x3D; 0 &amp;&amp; i &gt; 2)&#123;    &#x2F;&#x2F;每当i为2的倍数时记录折线答案</span><br><span class="line">            cnt++;</span><br><span class="line">            ans[cnt] &#x3D; temp[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int c;</span><br><span class="line">    init(); &#x2F;&#x2F;快乐打表</span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;c) !&#x3D; EOF)&#123;  &#x2F;&#x2F;输入测试数量</span><br><span class="line">        for(int i &#x3D; 0; i &lt; c; i++)&#123;</span><br><span class="line">            int n;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;n);    &#x2F;&#x2F;输入折线数量</span><br><span class="line">            printf(&quot;%d\n&quot;, ans[n]); &#x2F;&#x2F;输出答案</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/28/HDU-5879-Cure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/28/HDU-5879-Cure/" class="post-title-link" itemprop="url">HDU 5879 Cure</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-28 20:32:31" itemprop="dateCreated datePublished" datetime="2018-11-28T20:32:31+08:00">2018-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　Given an integer nn, we only want to know the sum of 1/k21/k2 where kk from 11 to nn.</p>
<p>Input</p>
<p>　　There are multiple cases.<br>　　For each test case, there is a single line, containing a single positive integer nn.<br>　　The input file is at most 1M.<br>Output</p>
<p>　　The required sum, rounded to the fifth digits after the decimal point.</p>
<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.00000</span><br><span class="line">1.25000</span><br><span class="line">1.42361</span><br><span class="line">1.52742</span><br><span class="line">1.58044</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题有多组测试数据，每组数据给出一个数n，数字k为从1到n所有整数，要求求和所有1/k^2。</p>
<p>　　由于k越来越大，1/k^2越来越小，而我们只需要输出小数点后5位，在疯狂wa11次尝试之后我发现当k到1e6左右，对于加上所有k&gt;1e6时的1/k^2对答案都没用影响了，小数点后5位就不会变动了。那么我们只需要将所有1~1e6的结果打表计算一次，如果输入的数大于1e6那之间输出1e6时的结果即可。</p>
<p>　　还有一个坑就是，本题没有给出输入的数n的范围，这证明什么？n无限大！还是用字符串存吧。</p>
<p>AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">double</span> sum[maxn];   <span class="comment">//sum记录对于从1~1e6所有n的答案</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;   <span class="comment">//s记录输入的数</span></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">    sum[<span class="number">1</span>] = <span class="number">1.0</span>;   <span class="comment">//n为1时1/1^2 = 1.0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++)&#123;</span><br><span class="line">            ans += (<span class="keyword">double</span>)(<span class="number">1.0</span> / i )* (<span class="keyword">double</span>)(<span class="number">1.0</span> / i );</span><br><span class="line">            sum[i] = ans;   <span class="comment">//打表所有1~1e6的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s)&#123;    <span class="comment">//输入字符串s</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">6</span>)&#123;  <span class="comment">//判断s所代表的数字长度是否超过6</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">                n = n * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符串长度不超过6将转换为数字后判断与1e6的关系</span></span><br><span class="line">            <span class="keyword">if</span>(n &lt; maxn)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.5f\n"</span>, sum[n]);</span><br><span class="line">                <span class="comment">//n小于1e6直接输出答案</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//n大于1e6直接输出1e6时的答案</span></span><br><span class="line">                ans = sum[maxn];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%.5f\n"</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//长度超过6连拆成数字都不用直接输出1e6时的答案</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.5f\n"</span>, sum[maxn]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.suvvm.work/2018/11/28/HDU-1878-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ortrait.jpg">
      <meta itemprop="name" content="SUVVM">
      <meta itemprop="description" content="SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SUVVM">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/28/HDU-1878-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/" class="post-title-link" itemprop="url">HDU 1878 欧拉回路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-28 20:21:53" itemprop="dateCreated datePublished" datetime="2018-11-28T20:21:53+08:00">2018-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-19 22:05:00" itemprop="dateModified" datetime="2020-12-19T22:05:00+08:00">2020-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">算法相关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>　　欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？</p>
<p>Input</p>
<p>　　测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是节点数N ( 1 &lt; N &lt; 1000 )和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。当N为0时输入结<br>束。</p>
<p>Output</p>
<p>　　每个测试用例的输出占一行，若欧拉回路存在则输出1，否则输出0。<br>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>解题思路：<br>　　本题有多组测试数据，每组给出顶点数n与边数m，之后m行给出每条边的信息，想要求出欧拉回路是否存在，学过离散数学的同志应该明白，只要无向连通图中每个点的度都为偶数，该图一定存在欧拉回路。</p>
<p>　　那么问题就转化为了判断该图是否连通与判断所有顶点的度是否都为偶数。</p>
<p>　　判断是否连通可以使用并查集判断所有顶点是否都再一个集合中，顶点的度用一个数组来记录，由于是无向图所以再输入时顶点每出现一次该顶点的度便加一。</p>
<p>　　AC代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> x)</span>    <span class="comment">//并查集找爹函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> f[x] = getFather(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m); <span class="comment">//输入顶点数与边数</span></span><br><span class="line">        <span class="keyword">int</span> a, b;   <span class="comment">//a，b记录边两边连接的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;<span class="comment">//初始化所有顶点的父亲为自己，即所有顶点不连通</span></span><br><span class="line">        <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(node));</span><br><span class="line">        <span class="comment">//初始化所有点度为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);  <span class="comment">//输入便连接的两个点</span></span><br><span class="line">            node[a]++;  <span class="comment">//连接的两个点度都加一</span></span><br><span class="line">            node[b]++;</span><br><span class="line">            <span class="keyword">int</span> fa, fb;</span><br><span class="line">            <span class="comment">//获取a与b的父亲</span></span><br><span class="line">            fa = f[a];</span><br><span class="line">            fb = f[b];</span><br><span class="line">            <span class="comment">//如果a与b不连通将它们标记为连通</span></span><br><span class="line">            <span class="keyword">if</span>(fa != fb)&#123;</span><br><span class="line">                f[b] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fx = f[<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//判断所有点是否再一个集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fx != f[i])&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;   <span class="comment">//如果图连通</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//判断所有点的度是否都为偶数</span></span><br><span class="line">                <span class="keyword">if</span>(node[i] % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123; </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SUVVM"
      src="/images/ortrait.jpg">
  <p class="site-author-name" itemprop="name">SUVVM</p>
  <div class="site-description" itemprop="description">SUVVM的个人博客，主要涉及编程知识分享、算法题解等方面</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">84</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/suvvm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suvvm" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/suvvm@foxmail.com" title="E-Mail → suvvm@foxmail.com"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SUVVM</span>
	<a href="http://www.beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">鲁ICP备19040043号-2</a>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  

</body>
</html>
